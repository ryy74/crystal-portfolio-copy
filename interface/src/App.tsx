// import libraries
import {
  getBlockNumber,
  readContracts,
  waitForTransactionReceipt,
  getTransactionCount
} from '@wagmi/core';
import React, {
  KeyboardEvent as ReactKeyboardEvent,
  useCallback,
  useEffect,
  useLayoutEffect,
  useMemo,
  useRef,
  useState,
  useReducer
} from 'react';
import {
  Link,
  Navigate,
  Route,
  Routes,
  useLocation,
  useNavigate,
  useSearchParams,
  useParams,
  matchPath
} from 'react-router-dom';
import { TransactionExecutionError, encodeFunctionData, maxUint256, decodeFunctionResult, decodeEventLog, decodeAbiParameters } from 'viem';
import { toUtf8Bytes, computeHmac } from 'ethers';
import { useLanguage } from './contexts/LanguageContext';
import getAddress from './utils/getAddress.ts';
import {
  loadWalletsFromStorage,
  saveWalletsToStorage,
  loadSelectedWalletsFromStorage,
  saveSelectedWalletsToStorage,
  deduplicateWallets
} from './utils/walletUtils';
import { config } from './wagmi.ts';
import {
  useLogout,
  useSmartAccountClient,
  useSendUserOperation,
  useAlchemyAccountContext,
  useUser,
  AuthCard,
  useSignTypedData,
  useSignMessage
} from "@account-kit/react";
import { Wallet, keccak256 } from 'ethers'
import { useQuery } from '@tanstack/react-query';

// import css
import './App.css';

// import scripts
import approve from './scripts/approve';
import limitOrder from './scripts/limitOrder';
import multiBatchOrders from './scripts/multiBatchOrders';
import cancelOrder from './scripts/cancelOrder';
import sendeth from './scripts/sendeth';
import sendtokens from './scripts/sendtokens';
import _swap from './scripts/swap';
import swapETHForExactTokens from './scripts/swapETHForExactTokens';
import swapExactETHForTokens from './scripts/swapExactETHForTokens';
import swapExactTokensForETH from './scripts/swapExactTokensForETH';
import swapExactTokensForTokens from './scripts/swapExactTokensForTokens';
import swapTokensForExactETH from './scripts/swapTokensForExactETH';
import swapTokensForExactTokens from './scripts/swapTokensForExactTokens';
import unwrapeth from './scripts/unwrapeth';
import wrapeth from './scripts/wrapeth';
import stake from './scripts/stake.ts';
import { fetchLatestPrice } from './utils/getPrice.ts';
import replaceOrder from './scripts/replaceOrder';

// import utils
import customRound from './utils/customRound';
import { formatTime } from './utils/formatTime.ts';
import { formatCommas, formatSubscript } from './utils/numberDisplayFormat';
import { formatDisplay, formatSig } from './components/OrderCenter/utils/formatDisplay.ts';
import { loadBuyPresets, loadSellPresets, saveBuyPresets, updateBuyPreset, updateSellPreset } from './utils/presetManager';

// import abis
import { CrystalDataHelperAbi } from './abis/CrystalDataHelperAbi';
import { CrystalRouterAbi } from './abis/CrystalRouterAbi';
import { CrystalReferralAbi } from './abis/CrystalReferralAbi.ts';
import { TokenAbi } from './abis/TokenAbi';
import { shMonadAbi } from './abis/shMonadAbi.ts';
import { CrystalVaultsAbi } from "./abis/CrystalVaultsAbi";

// import types
import { DataPoint } from './components/Chart/utils/chartDataGenerator.ts';

// import svg graphics
import tradearrow from './assets/arrow.svg';
import gas from './assets/gas.svg';
import slippageicon from './assets/slippage.svg';
import closebutton from './assets/close_button.png';
import sendSwitch from './assets/send_arrow.svg';
import walleticon from './assets/wallet_icon.svg';
import infoicon from './assets/icon.png';
import refreshicon from './assets/circulararrow.png';
import Xicon from './assets/Xicon.svg';
import reset from './assets/reset.svg';
import walletbackpack from './assets/walletbackpack.jpg'
import walletcoinbase from './assets/walletcoinbase.png'
import walletconnect from './assets/walletconnect.png'
import walletinjected from './assets/walletinjected.png'
import walletmetamask from './assets/walletmetamask.svg'
import walletphantom from './assets/walletphantom.svg'
import walletrabby from './assets/walletrabby.png'
import warningicon from './assets/warning_icon.png'
import walletsafe from './assets/walletsafe.png'
import wallettomo from './assets/wallettomo.jpg'
import wallethaha from './assets/wallethaha.png'
import crystalxp from './assets/CrystalX.png';
import part1image from './assets/part1intro.png';
import topright from './assets/topright.png';
import veryleft from './assets/veryleft.png';
import topmiddle from './assets/topmiddle.png';
import veryright from './assets/veryright.png';
import topleft from './assets/topleft.png';
import circleleft from './assets/circleleft.png';
import lbstand from './assets/lbstand.png';
import firstPlacePfp from './assets/leaderboard_first.png';
import secondPlacePfp from './assets/leaderboard_second.png';
import thirdPlacePfp from './assets/leaderboard_third.png';
import defaultPfp from './assets/leaderboard_default.png';
import iconusdc from './assets/iconusdc.png';
import edgeX from './assets/edgeX.svg';
import switchicon from './assets/switch.svg';
import printr from './assets/printr.png';
import flapsh from './assets/flapsh.png';
import kaching from './assets/ka-ching.mp3';

//audio
import stepaudio from './assets/step_audio.mp3';
import backaudio from './assets/back_audio.mp3';

// import routes
import Portfolio from './components/Portfolio/Portfolio.tsx';

// import main app components
import ChartComponent from './components/Chart/Chart.tsx';
import TokenInfoPopupContent from './components/Header/ChartHeader/TokenInfo/TokenInfoPopup/TokenInfoPopupContent.tsx';
import ChartOrderbookPanel from './components/ChartOrderbookPanel/ChartOrderbookPanel.tsx';
import Header from './components/Header/Header.tsx';
import LoadingOverlay from './components/loading/LoadingComponent.tsx';
import FullScreenOverlay from './components/loading/LoadingScreen.tsx';
import NavigationProgress from './components/NavigationProgress.tsx';
import OrderCenter from './components/OrderCenter/OrderCenter.tsx';
import SortArrow from './components/OrderCenter/SortArrow/SortArrow.tsx';
import PortfolioContent from './components/Portfolio/BalancesContent/BalancesContent.tsx';
import PortfolioPopupGraph from './components/Portfolio/PortfolioGraph/PortfolioGraph.tsx';
import ToggleSwitch from './components/ToggleSwitch/ToggleSwitch.tsx';
import TooltipLabel from './components/TooltipLabel/TooltipLabel.tsx';
import TransactionPopupManager from './components/TransactionPopupManager/TransactionPopupManager';
import MiniChart from './components/Header/ChartHeader/TokenInfo/MiniChart/MiniChart.tsx';
import Leaderboard from './components/Leaderboard/Leaderboard.tsx';
import Referrals from './components/Referrals/Referrals.tsx';
import SimpleOrdersContainer from './components/SimpleOrdersContainer/SimpleOrdersContainer';
import SidebarNav from './components/SidebarNav/SidebarNav';
import EarnVaults from './components/EarnVaults/EarnVaults.tsx';
import Launchpad from './components/Launchpad/Launchpad.tsx';
import TokenExplorer from './components/TokenExplorer/TokenExplorer.tsx';
import MemeInterface from './components/MemeInterface/MemeInterface.tsx';
import MemeTransactionPopupManager from './components/MemeTransactionPopup/MemeTransactionPopupManager';
import TokenBoard from './components/DegenToken/TokenBoard';
import TokenDetail from './components/DegenToken/TokenDetail';
import Tracker from './components/Tracker/Tracker.tsx';
import Earn from './components/Earn/Earn.tsx';
import Perps from './components/Perps/Perps.tsx';
import PNLComponent from './components/PNLComponent/PNLComponent.tsx';
import ImportWalletsPopup from './components/Tracker/ImportWalletsPopup.tsx';
import TradingPresetsPopup from './components/Tracker/TradingPresetsPopup/TradingPresetsPopup';
import LiveTradesSettingsPopup from './components/Tracker/ LiveTradesSettingsPopup/LiveTradesSettingsPopup.tsx';
import MemeSearch from './components/MemeSearch/MemeSearch.tsx';
import { showLoadingPopup, updatePopup } from './components/MemeTransactionPopup/MemeTransactionPopupManager';
import TrackerWidget from './components/TrackerWidget/TrackerWidget.tsx';
import SpectraWidget from './components/SpectraWidget/SpectraWidget.tsx';
import PNLWidget from './components/PNLWidget/PNLWidget.tsx';
import WalletTrackerWidget from './components/WalletTrackerWidget/WalletTrackerWidget.tsx';
import Footer from './components/Footer/Footer.tsx';
// import config
import { ChevronDown, Play, RotateCcw, SearchIcon, Volume2 } from 'lucide-react';
import { usePortfolioData } from './components/Portfolio/PortfolioGraph/usePortfolioData.ts';
import { settings } from './settings.ts';
import { useSharedContext } from './contexts/SharedContext.tsx';
import { QRCodeSVG } from 'qrcode.react';
import CopyButton from './components/CopyButton/CopyButton.tsx';
import { sMonAbi } from './abis/sMonAbi.ts';
import { defaultMetrics } from './components/TokenExplorer/TokenData.ts';
import { NadFunAbi } from './abis/NadFun.ts';
import { StorkAbi } from './abis/StorkAbi.ts';

type LaunchpadTrade = {
  id: string;
  timestamp: number;
  isBuy: boolean;
  price: number;
  tokenAmount: number;
  nativeAmount: number;
  caller: string;
};

type Holder = {
  address: string;
  balance: number;
  tokenNet: number;
  valueNet: number;
  amountBought: number;
  amountSold: number;
  valueBought: number;
  valueSold: number;
};

interface Token {
  id: string;
  dev: string;
  name: string;
  symbol: string;
  image: string;
  price: number;
  marketCap: number;
  change24h: number;
  volume24h: number;
  mini: any;
  holders: number;
  proTraders: number;
  sniperHolding: number;
  devHolding: number;
  bundleHolding: number;
  insiderHolding: number;
  top10Holding: number;
  buyTransactions: number;
  sellTransactions: number;
  globalFeesPaid: number;
  website: string;
  twitterHandle: string;
  progress: number;
  status: 'new' | 'graduating' | 'graduated';
  description: string;
  created: number;
  bondingAmount: number;
  volumeDelta: number;
  telegramHandle: string;
  discordHandle: string;
  graduatedTokens: number;
  launchedTokens: number;
  trades?: any;
  bondingPercentage: number;
  source?: 'crystal' | 'nadfun';
  market?: string;
}

type AudioGroups = 'swap' | 'order' | 'transfer' | 'approve';

interface AudioGroupSettings {
  swap: boolean;
  order: boolean;
  transfer: boolean;
  approve: boolean;
}

type State = {
  tokensByStatus: Record<Token['status'], Token[]>;
  hidden: Set<string>;
  loading: Set<string>;
};

type Action =
  | { type: 'INIT'; tokens: Token[] }
  | { type: 'ADD_MARKET'; token: Partial<Token> }
  | { type: 'ADD_METADATA'; id: string; updates: any }
  | { type: 'UPDATE_MARKET'; id: string; updates: any }
  | { type: 'GRADUATE_MARKET'; id: string; market?: any }
  | { type: 'HIDE_TOKEN'; id: string }
  | { type: 'SHOW_TOKEN'; id: string }
  | { type: 'SET_LOADING'; id: string; loading: boolean; buttonType?: 'primary' | 'secondary' }

interface AlertSettings {
  soundAlertsEnabled: boolean;
  volume: number;
  sounds: {
    newPairs: string;
    pairMigrating: string;
    migrated: string;
  };
}

interface TrackedWallet {
  id: string;
  address: string;
  name: string;
  emoji: string;
  createdAt: string;
  balance?: number;
  lastActiveAt?: number | null;
}

const SUBGRAPH_URL = 'https://gateway.thegraph.com/api/b9cc5f58f8ad5399b2c4dd27fa52d881/subgraphs/id/BJKD3ViFyTeyamKBzC1wS7a3XMuQijvBehgNaSBb197e';
const crystal = '/CrystalLogo.png';

const Loader = () => {
  const [ready, setReady] = useState(false);
  const [stateloading, setstateloading] = useState(true);
  const [addressinfoloading, setaddressinfoloading] = useState(true);
  const location = useLocation();

  useEffect(() => {
    if (true) {
      setReady(true)
      return;
    };
    (async () => {
      try {
        const query = `
          query {
            markets(first: 100, orderBy: volume, orderDirection: desc, where: {isCanonical:true}) {
              id
              baseAsset
              quoteAsset
              baseDecimals
              quoteDecimals
              baseTicker
              quoteTicker
              baseName
              quoteName
              marketType
              scaleFactor
              tickSize
              minSize
              maxPrice
              takerFee
              makerRebate
              volume
              latestPrice
              metadataCID
            }
          }
        `;
        const res = await fetch(SUBGRAPH_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query }),
        });
        const json = await res.json();
        const list = Array.isArray(json?.data?.markets) ? [...json.data.markets].reverse() : []

        const ETH_ADDR = settings.chainConfig[activechain].eth;
        const WETH_ADDR = settings.chainConfig[activechain].weth;
        const ETH_TICKER = settings.chainConfig[activechain].ethticker;
        const WETH_TICKER = settings.chainConfig[activechain].wethticker;
        const tokendict: { [key: string]: any } =
          settings.chainConfig[activechain].tokendict;
        const newMarkets: Record<string, any> = settings.chainConfig[activechain].markets;
        for (const m of list) {
          const baseAddr0 = getAddress(String(m.baseAsset || ''));
          const quoteAddr0 = getAddress(String(m.quoteAsset || ''));
          if (!tokendict[baseAddr0]) {
            tokendict[baseAddr0] = {
              address: baseAddr0,
              decimals: BigInt(Number(m.baseDecimals ?? 18)),
              image: m.metadataCID ?? '',
              name: m.baseName,
              ticker: m.baseTicker,
              website: '',
              autofetched: true,
            }
          }
          if (!tokendict[quoteAddr0]) {
            tokendict[quoteAddr0] = {
              address: quoteAddr0,
              decimals: BigInt(Number(m.quoteDecimals ?? 18)),
              image: m.metadataCID ?? '',
              name: m.quoteName,
              ticker: m.quoteTicker,
              website: '',
              autofetched: true,
            }
          }
          const scaleExp = (m.scaleFactor == '21' && m.quoteDecimals == '18') ? 9 : Number(m.scaleFactor ?? 0);
          const scaleFactor = (BigInt(10) ** BigInt(scaleExp));
          const baseDec = Number(m.baseDecimals ?? 18);
          const quoteDec = Number(m.quoteDecimals ?? 18);
          const pfExp = Math.max(0, quoteDec + scaleExp - baseDec);
          const priceFactor = (BigInt(10) ** BigInt(pfExp));

          const common = {
            address: String(m.id ?? '').toLowerCase(),
            marketType: Number(m.marketType ?? 0),
            precision: 5,
            scaleFactor,
            priceFactor,
            tickSize: BigInt(m.tickSize ?? 1),
            minSize: BigInt(m.minSize ?? 0),
            maxPrice: BigInt(m.maxPrice ?? 0),
            fee: BigInt(m.takerFee ?? 100000),
            makerRebate: BigInt(m.makerRebate ?? 100000),
            baseDecimals: BigInt(baseDec),
            quoteDecimals: BigInt(quoteDec),
          };

          const baseIsEthish = baseAddr0 === ETH_ADDR || baseAddr0 === WETH_ADDR;
          const quoteIsEthish = quoteAddr0 === ETH_ADDR || quoteAddr0 === WETH_ADDR;

          const variants: Array<{ baseAddr: string; quoteAddr: string, baseAsset: string, quoteAsset: string }> = [];
          if (baseIsEthish) {
            variants.push({ baseAddr: ETH_ADDR, quoteAddr: quoteAddr0, baseAsset: ETH_TICKER, quoteAsset: m.quoteTicker });
            variants.push({ baseAddr: WETH_ADDR, quoteAddr: quoteAddr0, baseAsset: WETH_TICKER, quoteAsset: m.quoteTicker });
          } else if (quoteIsEthish) {
            variants.push({ baseAddr: baseAddr0, quoteAddr: ETH_ADDR, baseAsset: m.baseTicker, quoteAsset: ETH_TICKER });
            variants.push({ baseAddr: baseAddr0, quoteAddr: WETH_ADDR, baseAsset: m.baseTicker, quoteAsset: WETH_TICKER });
          } else {
            variants.push({ baseAddr: baseAddr0, quoteAddr: quoteAddr0, baseAsset: m.baseTicker, quoteAsset: m.quoteTicker });
          }

          for (const v of variants) {
            const bTok = tokendict[v.baseAddr];

            const marketKey = `${v.baseAsset}${v.quoteAsset}`;
            const image = (bTok?.image ?? settings.chainConfig[activechain].image ?? null);
            const website = (bTok?.website ?? '');
            newMarkets[marketKey] = {
              baseAsset: v.baseAsset,
              quoteAsset: v.quoteAsset,
              baseAddress: v.baseAddr,
              quoteAddress: v.quoteAddr,
              path: [v.quoteAddr, v.baseAddr],
              image,
              website,
              marketKey,
              ...common,
            };
          }
        }
        settings.chainConfig[activechain].markets = newMarkets;
        const newAddrToMarket: Record<string, string> = {};
        Object.values(newMarkets).reverse().forEach((m: any) => {
          if (m?.address) newAddrToMarket[String(m.address).toLowerCase()] = m.marketKey;
        });
        settings.chainConfig[activechain].addresstomarket = newAddrToMarket;

        const temptradesByMarket: Record<string, any[]> = {};
        Object.keys(newMarkets).forEach((k) => { temptradesByMarket[k] = []; });

        const addrToKey: Record<string, string> = {};
        Object.values(newMarkets).forEach((m: any) => {
          if (m?.address) addrToKey[String(m.address).toLowerCase()] = m.marketKey;
        });
      } catch (error) {
        console.error("Error fetching data:", error);
      }
      finally {
        setReady(true)
      }
    })();
  }, []);

  return (
    <>
      {/* {<FullScreenOverlay isVisible={(stateloading || addressinfoloading)} />} */}
      {ready && <App stateloading={stateloading} setstateloading={setstateloading} addressinfoloading={addressinfoloading} setaddressinfoloading={setaddressinfoloading} />}
    </>
  );
}
interface Position {
  tokenId: string;
  symbol?: string;
  name?: string;
  metadataCID?: string;
  imageUrl?: string;
  boughtTokens: number;
  soldTokens: number;
  spentNative: number;
  receivedNative: number;
  remainingTokens: number;
  remainingPct: number;
  pnlNative: number;
  lastPrice?: number;
  source?: 'nadfun' | 'crystal' | string;
  status?: 'new' | 'graduating' | 'graduated';
  bondingPercentage?: number;
}
function App({ stateloading, setstateloading, addressinfoloading, setaddressinfoloading }: { stateloading: any, setstateloading: any, addressinfoloading: any, setaddressinfoloading: any }) {
  const [trackedWallets, setTrackedWallets] = useState<TrackedWallet[]>([]);
  const lastProcessedTradeId = useRef<string | null>(null);
  const shownTradeIds = useRef<Set<string>>(new Set());
  const NAD_FUN_EVENTS = {
    CurveCreate: '0xd37e3f4f651fe74251701614dbeac478f5a0d29068e87bbe44e5026d166abca9',
    CurveBuy: '0x00a7ba871905cb955432583640b5c9fc6bdd27d36884ab2b5420839224638862',
    CurveSell: '0x0eb25df0e2137de8ce042eeaf39080d25f0c8d451372c99db69a4c0a298d0fa1',
    CurveGraduate: '0xa1cae252e597e19f398a442722a17a17e62d17f9d4f3656786e18aabcd428908',
    CurveSync: '0xfd4bb47bd45abdbdb2ecd61052c9571773f9cde876e2a7745f488c20b30ab10a',
  };

  const CRYSTAL_EVENTS = {
    LaunchpadTrade: '0xc367a2f5396f96d105baaaa90fe29b1bb18ef54c712964410d02451e67c19d3e',
    MarketCreated: '0x24ad3570873d98f204dae563a92a783a01f6935a8965547ce8bf2cadd2c6ce3b',
    Trade: '0x9adcf0ad0cda63c4d50f26a48925cf6405df27d422a39c456b5f03f661c82982',
    Graduation: '0xa2e7361c23d7820040603b83c0cd3f494d377bac69736377d75bb56c651a5098',
    Transfer: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
  }

  const UNIV3_EVENTS = {
    Swap: '0xc42079f94a6350d7e6235f29174924f928cc2ac818eb64fed8004e115fbcca67'
  }

  const [settingsMode, setSettingsMode] = useState<'buy' | 'sell'>('buy');
  const [selectedBuyPreset, setSelectedBuyPreset] = useState(1);
  const [selectedSellPreset, setSelectedSellPreset] = useState(1);
  const [buySlippageValue, setBuySlippageValue] = useState(() => {
    const presets = loadBuyPresets();
    return presets[1]?.slippage || '20';
  });
  
  const [buyPriorityFee, setBuyPriorityFee] = useState(() => {
    const presets = loadBuyPresets();
    return presets[1]?.priority || '0.01';
  });

  const [sellSlippageValue, setSellSlippageValue] = useState(() => {
    const presets = loadSellPresets();
    return presets[1]?.slippage || '20';
  });

  const [sellPriorityFee, setSellPriorityFee] = useState(() => {
    const presets = loadSellPresets();
    return presets[1]?.priority || '0.01';
  });

  const handleBuyPresetSelect = useCallback(
    (preset: number) => {
      setSelectedBuyPreset(preset);
      const presets = loadBuyPresets();
      if (presets[preset]) {
        setBuySlippageValue(presets[preset].slippage);
        setBuyPriorityFee(presets[preset].priority);
      }
    },
    [],
  );

  const handleSellPresetSelect = useCallback(
    (preset: number) => {
      setSelectedSellPreset(preset);
      const presets = loadSellPresets();
      if (presets[preset]) {
        setSellSlippageValue(presets[preset].slippage);
        setSellPriorityFee(presets[preset].priority);
      }
    },
    [],
  );

  const handleSavePresets = useCallback((presets: Record<number, any>) => {
    saveBuyPresets(presets);
    setBuyPresets(presets);
  }, []);

  useEffect(() => {
    const loadWallets = () => {
      try {
        const stored = localStorage.getItem('tracked_wallets_data');
        if (stored) {
          const parsed = JSON.parse(stored);
          setTrackedWallets(parsed);
        }
      } catch (error) {
      }
    };

    loadWallets();

    const handleWalletUpdate = (e: CustomEvent) => {
      if (e.detail?.wallets) {
        setTrackedWallets(e.detail.wallets);
      }
    };

    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === 'tracked_wallets_data' && e.newValue) {
        try {
          const parsed = JSON.parse(e.newValue);
          setTrackedWallets(parsed);
        } catch (error) {
        }
      }
    };

    window.addEventListener('wallets-updated', handleWalletUpdate as EventListener);
    window.addEventListener('storage', handleStorageChange);

    return () => {
      window.removeEventListener('wallets-updated', handleWalletUpdate as EventListener);
      window.removeEventListener('storage', handleStorageChange);
    };
  }, []);

  useEffect(() => {
    const handleBuyPresetsUpdate = (event: CustomEvent) => {
      const newPresets = event.detail;
      setBuyPresets(newPresets);
      if (newPresets[selectedBuyPreset]) {
        setBuySlippageValue(newPresets[selectedBuyPreset].slippage);
        setBuyPriorityFee(newPresets[selectedBuyPreset].priority);
      }
    };

    const handleSellPresetsUpdate = (event: CustomEvent) => {
      const newPresets = event.detail;
      if (newPresets[selectedSellPreset]) {
        setSellSlippageValue(newPresets[selectedSellPreset].slippage);
        setSellPriorityFee(newPresets[selectedSellPreset].priority);
      }
    };

    window.addEventListener('buyPresetsUpdated', handleBuyPresetsUpdate as EventListener);
    window.addEventListener('sellPresetsUpdated', handleSellPresetsUpdate as EventListener);

    return () => {
      window.removeEventListener('buyPresetsUpdated', handleBuyPresetsUpdate as EventListener);
      window.removeEventListener('sellPresetsUpdated', handleSellPresetsUpdate as EventListener);
    };
  }, [selectedBuyPreset, selectedSellPreset]);

  useEffect(() => {
    if (selectedBuyPreset) {
      updateBuyPreset(selectedBuyPreset, {
        slippage: buySlippageValue,
        priority: buyPriorityFee,
      });
    }
  }, [buySlippageValue, buyPriorityFee, selectedBuyPreset]);

  useEffect(() => {
    if (selectedSellPreset) {
      updateSellPreset(selectedSellPreset, {
        slippage: sellSlippageValue,
        priority: sellPriorityFee,
      });
    }
  }, [sellSlippageValue, sellPriorityFee, selectedSellPreset]);

  // constants
  useEffect(() => {
    if (!localStorage.getItem("noSSR")) {
      localStorage.setItem("noSSR", "true");
    }
  }, []);

  const { config: alchemyconfig } = useAlchemyAccountContext() as any;
  const { client, address: scaAddress } = useSmartAccountClient({}) as { client: any; address: any };
  const { sendUserOperationAsync: rawSendUserOperationAsync } = useSendUserOperation({
    client,
    waitForTxn: false,
  });
  const [pnlShareData, setPnlShareData] = useState<{
    tokenAddress: string;
    tokenSymbol: string;
    tokenName: string;
    userAddress: string;
    externalUserStats: {
      balance: number;
      amountBought: number;
      amountSold: number;
      valueBought: number;
      valueSold: number;
      valueNet: number;
    };
    currentPrice: number;
  } | null>(null);

  const handleSharePNL = useCallback((shareData: any) => {
    setPnlShareData(shareData);
    setpopup(27);
  }, []); const { signTypedDataAsync } = useSignTypedData({ client })
  const { signMessageAsync } = useSignMessage({ client })
  const user = useUser();
  const { logout } = useLogout();
  const { t, language, setLanguage } = useLanguage();
  const [searchParams, setSearchParams] = useSearchParams();
  const { activechain, percentage, setPercentage, favorites } = useSharedContext();
  const userchain = alchemyconfig?._internal?.wagmiConfig?.state?.connections?.entries()?.next()?.value?.[1]?.chainId || client?.chain?.id
  const location = useLocation();
  const navigate = useNavigate();
  const [isTrackerWidgetOpen, setIsTrackerWidgetOpen] = useState(false);
  const [isSpectraWidgetOpen, setIsSpectraWidgetOpen] = useState(() => {
    const saved = localStorage.getItem('spectra-widget-open');
    return saved === 'true';
  });
  const getWidgetOpenState = (): boolean => {
    try {
      const stored = localStorage.getItem('wallet_tracker_widget_state');
      if (stored) return JSON.parse(stored).isOpen ?? false;
    } catch (error) {
    }
    return false;
  };
  useEffect(() => {
    localStorage.setItem('spectra-widget-open', String(isSpectraWidgetOpen));
  }, [isSpectraWidgetOpen]); const [isPNLWidgetOpen, setIsPNLWidgetOpen] = useState(false);
  const [isWalletTrackerWidgetOpen, setIsWalletTrackerWidgetOpen] = useState(() => getWidgetOpenState());

  const [trackerWidgetSnap, setTrackerWidgetSnap] = useState<'left' | 'right' | null>(null);
  const [trackerWidgetWidth, setTrackerWidgetWidth] = useState(400);

  const [spectraWidgetSnap, setSpectraWidgetSnap] = useState<'left' | 'right' | null>(null);
  const [spectraWidgetWidth, setSpectraWidgetWidth] = useState(600);

  const [pnlWidgetSnap, setPNLWidgetSnap] = useState<'left' | 'right' | null>(null);
  const [pnlWidgetWidth, setPNLWidgetWidth] = useState(480);

  const [walletTrackerWidgetSnap, setWalletTrackerWidgetSnap] = useState<'left' | 'right' | null>(null);
  const [walletTrackerWidgetWidth, setWalletTrackerWidgetWidth] = useState(600);

  const handleTrackerWidgetSnapChange = useCallback((snapSide: 'left' | 'right' | null, width: number) => {
    setTrackerWidgetSnap(snapSide);
    setTrackerWidgetWidth(width);
  }, []);

  const handleSpectraWidgetSnapChange = useCallback((snapSide: 'left' | 'right' | null, width: number) => {
    setSpectraWidgetSnap(snapSide);
    setSpectraWidgetWidth(width);
  }, []);

  const handlePNLWidgetSnapChange = useCallback((snapSide: 'left' | 'right' | null, width: number) => {
    setPNLWidgetSnap(snapSide);
    setPNLWidgetWidth(width);
  }, []);

  const handleWalletTrackerWidgetSnapChange = useCallback((snapSide: 'left' | 'right' | null, width: number) => {
    setWalletTrackerWidgetSnap(snapSide);
    setWalletTrackerWidgetWidth(width);
  }, []);

  const [windowWidth, setWindowWidth] = useState(window.innerWidth);
  const TOTAL_SUPPLY = 1e9;
  const nadFunBondingCurve = settings.chainConfig[activechain].nadFunBondingCurve;
  const HTTP_URL = settings.chainConfig[activechain].httpurl;
  const WS_URL = settings.chainConfig[activechain].wssurl;
  const eth = settings.chainConfig[activechain].eth as `0x${string}`;
  const weth = settings.chainConfig[activechain].weth as `0x${string}`;
  const usdc = settings.chainConfig[activechain].usdc as `0x${string}`;
  const ethticker = settings.chainConfig[activechain].ethticker;
  const wethticker = settings.chainConfig[activechain].wethticker;
  const balancegetter = settings.chainConfig[activechain].balancegetter;
  const router = settings.chainConfig[activechain].router;
  const crystalVaults = settings.chainConfig[activechain].crystalVaults;
  const markets: { [key: string]: any } =
    settings.chainConfig[activechain].markets;
  const tokendict: { [key: string]: any } =
    settings.chainConfig[activechain].tokendict;
  const addresstoMarket: { [key: string]: any } =
    settings.chainConfig[activechain].addresstomarket;
  const graph: Record<string, string[]> = (() => {
    let g: Record<string, string[]> = {};
    for (const [, market] of Object.entries(markets)) {
      const baseAddress = market.baseAddress;
      const quoteAddress = market.quoteAddress;

      if (!g[baseAddress]) g[baseAddress] = [];
      if (!g[quoteAddress]) g[quoteAddress] = [];

      g[baseAddress].push(quoteAddress);
      g[quoteAddress].push(baseAddress);
    }
    return g;
  })();

  const txReceiptResolvers = useRef(new Map<string, () => void>());
  // get market including multihop
  const getMarket = (token1: string, token2: string): any => {
    return (
      markets[`${tokendict[token1].ticker}${tokendict[token2].ticker}`] ||
      markets[`${tokendict[token2].ticker}${tokendict[token1].ticker}`] ||
      (() => {
        if (
          (token1 == eth && token2 == weth) ||
          (token1 == weth && token2 == eth)
        ) {
          let market = { ...getMarket(eth, usdc) };
          market['path'] = [token1, token2];
          market['fee'] = BigInt(10000);
          return market;
        }
      })() ||
      (() => {
        const path = findShortestPath(token1, token2);
        if (path && path.length > 2) {
          let fee = BigInt(1);
          for (let i = 0; i < path.length - 1; i++) {
            fee *= getMarket(path[i], path[i + 1]).fee;
          }
          fee /= BigInt(100000 ** (path.length - 2));
          if (path.at(-1) != usdc) {
            return {
              quoteAsset: getMarket(path.at(-2), path.at(-1)).quoteAsset,
              baseAsset: getMarket(path.at(-2), path.at(-1)).baseAsset,
              path: path,
              quoteAddress: getMarket(path.at(-2), path.at(-1)).quoteAddress,
              baseAddress: getMarket(path.at(-2), path.at(-1)).baseAddress,
              quoteDecimals: getMarket(path.at(-2), path.at(-1)).quoteDecimals,
              baseDecimals: getMarket(path.at(-2), path.at(-1)).baseDecimals,
              address: getMarket(path.at(-2), path.at(-1)).address,
              scaleFactor: getMarket(path.at(-2), path.at(-1)).scaleFactor,
              priceFactor: getMarket(path.at(-2), path.at(-1)).priceFactor,
              tickSize: getMarket(path.at(-2), path.at(-1)).tickSize,
              minSize: getMarket(path.at(-2), path.at(-1)).minSize,
              maxPrice: getMarket(path.at(-2), path.at(-1)).maxPrice,
              fee: fee,
              makerRebate: getMarket(path.at(-2), path.at(-1)).makerRebate,
              image: getMarket(path.at(-2), path.at(-1)).image,
              website: getMarket(path.at(-2), path.at(-1)).website,
            };
          }
          return {
            quoteAsset: getMarket(path.at(0), path.at(1)).quoteAsset,
            baseAsset: getMarket(path.at(0), path.at(1)).baseAsset,
            path: path,
            quoteAddress: getMarket(path.at(0), path.at(1)).quoteAddress,
            baseAddress: getMarket(path.at(0), path.at(1)).baseAddress,
            quoteDecimals: getMarket(path.at(0), path.at(1)).quoteDecimals,
            baseDecimals: getMarket(path.at(0), path.at(1)).baseDecimals,
            address: getMarket(path.at(0), path.at(1)).address,
            scaleFactor: getMarket(path.at(0), path.at(1)).scaleFactor,
            priceFactor: getMarket(path.at(0), path.at(1)).priceFactor,
            tickSize: getMarket(path.at(0), path.at(1)).tickSize,
            minSize: getMarket(path.at(0), path.at(1)).minSize,
            maxPrice: getMarket(path.at(0), path.at(1)).maxPrice,
            fee: fee,
            makerRebate: getMarket(path.at(-2), path.at(-1)).makerRebate,
            image: getMarket(path.at(0), path.at(1)).image,
            website: getMarket(path.at(0), path.at(1)).website,
          };
        }
      })()
    );
  };

  // find path between two tokens
  const findShortestPath = (start: string, end: string): any => {
    const queue: string[][] = [[start]];
    const visited: Set<string> = new Set();

    while (queue.length > 0) {
      const path = queue.shift()!;
      const current = path[path.length - 1];
      if (current === end) {
        return path;
      }
      if (!visited.has(current)) {
        visited.add(current);
        for (const neighbor of graph[current] || []) {
          if (!visited.has(neighbor)) {
            queue.push([...path, neighbor]);
          }
        }
      }
    }
    return null;
  };

  const [activeTradingMode, setActiveTradingMode] = useState<'spot' | 'perps' | 'spectra'>(() => {
    const saved = localStorage.getItem('crystal_trading_mode');
    return (saved === 'perps' || saved === 'spectra') ? saved : 'spot';
  });

  const [oneCTDepositAddress, setOneCTDepositAddress] = useState('');
  const [oneCTSigner, setOneCTSigner] = useState(() => {
    const signerKey = `crystal_active_wallet_private_key_${scaAddress?.toLowerCase() || 'default'}`;
    const saved = localStorage.getItem(signerKey);
    return saved ? saved : '';
  });

  const [oneCTSig, setOneCTSig] = useState(() => {
    const signatureKey = `crystal_onect_signature_${scaAddress?.toLowerCase() || 'default'}`;
    const saved = localStorage.getItem(signatureKey);
    return saved ? saved : '';
  });

  const validOneCT = !!oneCTSigner
  const onectclient = validOneCT ? new Wallet(oneCTSigner) : {
    address: '0x0000000000000000000000000000000000000000' as `0x${string}`,
    signTransaction: async () => '',
    signTypedData: async () => ''
  };
  const address = validOneCT && scaAddress ? onectclient.address as `0x${string}` : (client ? undefined : scaAddress) as `0x${string}`
  const connected = address != undefined
  const [currentWalletIcon, setCurrentWalletIcon] = useState(walleticon);
  const [subWallets, setSubWallets] = useState<Array<{ address: string, privateKey: string }>>(() =>
    loadWalletsFromStorage(scaAddress)
  );
  const [selectedWallets, setSelectedWallets] = useState<Set<string>>(() =>
    loadSelectedWalletsFromStorage(scaAddress)
  );

  useEffect(() => {
    setSelectedWallets(new Set());

    const newSubWallets = loadWalletsFromStorage(scaAddress);
    setSubWallets(newSubWallets);

    const newSelectedWallets = loadSelectedWalletsFromStorage(scaAddress);

    const validAddresses = new Set(newSubWallets.map(w => w.address));
    const validSelectedWallets = new Set(
      Array.from(newSelectedWallets).filter(addr => validAddresses.has(addr))
    );

    setSelectedWallets(validSelectedWallets);

    const signerKey = `crystal_active_wallet_private_key_${scaAddress?.toLowerCase() || 'default'}`;
    const savedSigner = localStorage.getItem(signerKey) || '';
    setOneCTSigner(savedSigner);

    const signatureKey = `crystal_onect_signature_${scaAddress?.toLowerCase() || 'default'}`;
    const savedSig = localStorage.getItem(signatureKey) || '';
    setOneCTSig(savedSig);
  }, [scaAddress]);

  useEffect(() => {
    saveSelectedWalletsToStorage(selectedWallets, scaAddress);
    saveWalletsToStorage(subWallets, scaAddress);
    const signerKey = `crystal_active_wallet_private_key_${scaAddress?.toLowerCase() || 'default'}`;
    localStorage.setItem(signerKey, oneCTSigner)
  }, [subWallets, selectedWallets, oneCTSigner]);

  useEffect(() => {
    if (connected) {
      setCurrentWalletIcon(() => {
        const connectorName = alchemyconfig?._internal?.wagmiConfig?.state?.connections?.entries()?.next()?.value?.[1]?.connector?.name || 'Unknown';

        switch (connectorName) {
          case 'MetaMask':
            return walletmetamask;
          case 'Coinbase Wallet':
            return walletcoinbase;
          case 'WalletConnect':
            return walletconnect;
          case 'Safe':
            return walletsafe;
          case 'Rabby Wallet':
          case 'Rabby':
            return walletrabby;
          case 'Backpack':
            return walletbackpack;
          case 'Phantom':
            return walletphantom;
          case 'Tomo':
            return wallettomo;
          case 'HaHa Wallet':
            return wallethaha;
          default:
            return walleticon;
        }
      });
    } else {
      setCurrentWalletIcon(walleticon);
    }
  }, [connected, alchemyconfig?._internal?.wagmiConfig?.state?.connections?.entries()?.next()?.value?.[1]?.connector?.name]);

  const [createVaultStep, setCreateVaultStep] = useState<'idle' | 'validating' | 'approve-quote' | 'approve-base' | 'creating' | 'success'>('idle');
  const [depositVaultStep, setDepositVaultStep] = useState<'idle' | 'validating' | 'approve-quote' | 'approve-base' | 'depositing' | 'success'>('idle');
  const [depositVaultError, setDepositVaultError] = useState<string>('');
  const [withdrawVaultStep, setWithdrawVaultStep] = useState<'idle' | 'validating' | 'withdrawing' | 'success'>('idle');
  const [withdrawVaultError, setWithdrawVaultError] = useState<string>('');
  const [createVaultError, setCreateVaultError] = useState<string>('');
  const [withdrawPercentage, setWithdrawPercentage] = useState('');
  const [createVaultForm, setCreateVaultForm] = useState({
    name: '',
    description: '',
    selectedMarket: '',
    quoteAsset: '',
    baseAsset: '',
    amountQuote: '',
    amountBase: '',
    social1: '',
    social2: '',
    showMarketDropdown: false,
    marketSearchTerm: ''
  });

  const createSubWallet = async (setMain: boolean = false) => {
    try {
      if (subWallets.length > 9) return;
      let tempsig

      const signatureKey = `crystal_onect_signature_${scaAddress?.toLowerCase() || 'default'}`;

      if (oneCTSig) {
        tempsig = oneCTSig
      }
      else {
        tempsig = await signTypedDataAsync({
          typedData: {
            types: {
              CrystalOneCT: [
                { name: 'version', type: 'string' },
                { name: 'account', type: 'uint256' },
              ],
            },
            primaryType: 'CrystalOneCT',
            message: {
              version: 'Crystal v0.0.1 Mainnet',
              account: 1,
            }
          }
        })
        localStorage.setItem(signatureKey, tempsig)
        setOneCTSig(tempsig)
      }

      const privateKey = '0x' + (BigInt(keccak256('0x' + (BigInt(tempsig) + BigInt(subWallets.length + 1)).toString(16))) % BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141")).toString(16).padStart(64, "0");

      const tempWallet = new Wallet(privateKey);
      const walletAddress = tempWallet.address as string;

      const newWallet = {
        address: walletAddress,
        privateKey: privateKey
      };

      const updatedWallets = [...subWallets, newWallet];
      setSelectedWallets(p => !p.size ? new Set(p).add(walletAddress) : p);
      lastNonceGroupFetch.current = 0;
      setSubWallets(updatedWallets);

      if (setMain || (!validOneCT && updatedWallets.length === 1)) {
        setOneCTSigner(privateKey);
        const signerKey = `crystal_active_wallet_private_key_${scaAddress?.toLowerCase() || 'default'}`;
        localStorage.setItem(signerKey, privateKey);
        refetch();
      }
      return walletAddress
    } catch (error) {
      console.error('Error creating subwallet:', error);
    }
  };

  const signTypedDataUnified = async (
    typedData: any,
    pk: string = '',
    mainWallet: boolean = false
  ): Promise<`0x${string}`> => {
    if (pk) {
      const w = new Wallet(pk)
      return await w.signTypedData(typedData.domain, typedData.types, typedData.message) as `0x${string}`
    }
    if (validOneCT && !mainWallet) {
      return await onectclient.signTypedData(typedData.domain, typedData.types, typedData.message) as `0x${string}`
    }
    return await signTypedDataAsync({ typedData }) as `0x${string}`
  }

  const sendUserOperationAsync = useCallback(
    async (params: any, gasLimit: bigint = 0n, prioFee: bigint = 0n, mainWallet: boolean = false, pk: string = '', nonce: number = 0, noReceipt: boolean = false, returnReceipt: boolean = false, retryCount: number = 0, addr: string = '') => {
      let hash: `0x${string}`;
      let receipt: any;
      let err: any;
      if (!!pk) {
        gasLimit = gasLimit > 0n ? gasLimit : 1000000n;
        const tx = {
          to: params.uo.target,
          value: params.uo.value,
          data: params.uo.data,
          gasLimit: gasLimit,
          maxFeePerGas: 220000000000n + (prioFee > 0n ? prioFee : BigInt(parseInt(buyPriorityFee || '0') * 1e9)) + BigInt(retryCount),
          maxPriorityFeePerGas: (prioFee > 0n ? prioFee : BigInt(parseInt(buyPriorityFee || '0') * 1e9)) + BigInt(retryCount),
          nonce: nonce,
          chainId: activechain
        }
        const signedTx = await (new Wallet(pk)).signTransaction(tx);
        hash = keccak256(signedTx) as `0x${string}`;

        const RPC_URLS = settings.chainConfig[activechain].RPC_URLS;
        RPC_URLS.forEach((url: any) => {
          fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            mode: 'no-cors',
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: 0,
              method: 'eth_sendRawTransaction',
              params: [signedTx]
            })
          }).catch();
        });
      }
      else if (validOneCT && !mainWallet) {
        gasLimit = gasLimit > 0n ? gasLimit : 1000000n;
        const wallet = nonces.current.get(onectclient.address);
        nonce = wallet.nonce
        const tx = {
          to: params.uo.target,
          value: params.uo.value,
          data: params.uo.data,
          gasLimit: gasLimit,
          maxFeePerGas: 220000000000n + (prioFee > 0n ? prioFee : BigInt(parseInt(buyPriorityFee || '0') * 1e9)) + BigInt(retryCount),
          maxPriorityFeePerGas: (prioFee > 0n ? prioFee : BigInt(parseInt(buyPriorityFee || '0') * 1e9)) + BigInt(retryCount),
          nonce: nonce,
          chainId: activechain
        }
        wallet?.pendingtxs.push([params, gasLimit, prioFee, mainWallet, pk, nonce]);
        if (wallet) wallet.nonce += 1;
        const signedTx = await onectclient.signTransaction(tx);
        hash = keccak256(signedTx) as `0x${string}`;

        const RPC_URLS = settings.chainConfig[activechain].RPC_URLS;
        RPC_URLS.forEach((url: any) => {
          fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            mode: 'no-cors',
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: 0,
              method: 'eth_sendRawTransaction',
              params: [signedTx]
            })
          }).catch();
        });
      }
      else {
        hash = (await rawSendUserOperationAsync(params))?.hash
      }
      try {
        await Promise.race([
          ...(returnReceipt ? [] : [new Promise<void>((resolve) => {
            txReceiptResolvers.current.set(hash, resolve);
          })]),
          waitForTransactionReceipt(config, { hash, pollingInterval: noReceipt ? 2000 : 500 }).then((r) => {
            txReceiptResolvers.current.delete(hash);
            hash = r.transactionHash;
            receipt = r
          }),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error('transaction timeout')), 3000)
          ),
        ]);
      }
      catch (e: any) {
        err = e
        if (retryCount > 0 && e?.message.includes("execution reverted")) {
          const wallet = nonces.current.get(addr);
          const retryParams = [params, gasLimit * 5n, prioFee, mainWallet, pk, wallet.nonce, noReceipt, returnReceipt, retryCount - 1, addr] as [
            any,
            bigint,
            bigint,
            boolean,
            string,
            number,
            boolean,
            boolean,
            number,
            string
          ];
          if (wallet) wallet.nonce += 1;
          wallet?.pendingtxs.push(retryParams);
          const res: any = await sendUserOperationAsync(...retryParams)
          if (wallet)
            wallet.pendingtxs = wallet.pendingtxs.filter(
              (p: any) => p[5] != retryParams[5],
            );
          return { hash: res.hash, receipt: res.receipt }
        }
      } finally {
        if (!pk && validOneCT && !mainWallet) {
          const wallet = nonces.current.get(onectclient.address);
          wallet.pendingtxs = wallet.pendingtxs.filter(
            (p: any) => p[5] != nonce,
          );
        }
      }
      if (err) throw err
      return { hash, receipt }
    },
    [validOneCT, buyPriorityFee]
  );

  const [perpsActiveMarketKey, setperpsActiveMarketKey] = useState(
    location.pathname.startsWith("/perps")
      ? location.pathname.split("/").pop()?.toUpperCase() == "PERPS" ? "BTCUSD" : location.pathname.split("/").pop()?.toUpperCase() || "BTCUSD"
      : "BTCUSD"
  );
  const [perpsMarketsData, setPerpsMarketsData] = useState<{ [key: string]: any }>({});
  const [perpsLimitChase, setPerpsLimitChase] = useState(true);
  const [perpsFilterOptions, setPerpsFilterOptions] = useState({});
  const [perpsKeystore, setPerpsKeystore] = useState<any>(() => {
    const saved = localStorage.getItem('crystal_perps_signer');
    return saved !== null ? JSON.parse(saved) : {};
  })
  const [perpsDepositAmount, setPerpsDepositAmount] = useState('');
  const [perpsWithdrawAmount, setPerpsWithdrawAmount] = useState('');
  const [perpsLeverage, setPerpsLeverage] = useState<string>(() => {
    const saved = localStorage.getItem('crystal_perps_leverage');
    return saved !== null ? saved : '10';
  });
  const [userLeverage, setUserLeverage] = useState<any>();

  const handlePerpsMarketSelect = useCallback((marketKey: any) => {
    setPerpsLimitChase(true);
    setperpsActiveMarketKey(marketKey);
    navigate(`/perps/${marketKey}`);
  }, [navigate]);

  // state vars
  const [showSendDropdown, setShowSendDropdown] = useState(false);
  const sendDropdownRef = useRef<HTMLDivElement | null>(null);
  const sendButtonRef = useRef<HTMLSpanElement | null>(null);
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [selectedDepositToken, setSelectedDepositToken] = useState(() => Object.keys(tokendict)[0]);
  const [mobileView, setMobileView] = useState('chart');
  const [showTrade, setShowTrade] = useState(false);
  const [showWelcomeScreen, setShowWelcomeScreen] = useState(true);
  const [selectedConnector, setSelectedConnector] = useState<any>(null);
  const [totalAccountValue, setTotalAccountValue] = useState<number | null>(null);
  const [totalVolume, setTotalVolume] = useState(0);
  const [copyTooltipVisible, setCopyTooltipVisible] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const [showHoverTooltip, setShowHoverTooltip] = useState(false);
  const [currentProText, setCurrentProText] = useState(location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market' || location.pathname.slice(1) == 'limit' ? 'pro' : t(location.pathname.slice(1).toLowerCase()));
  const [refLink, setRefLink] = useState('');
  const [showModal, setShowModal] = useState(false);
  const [totalClaimableFees, setTotalClaimableFees] = useState(0);
  const [switched, setswitched] = useState(false);
  const [orderSizePercent, setOrderSizePercent] = useState(100);
  const [originalOrderSize, setOriginalOrderSize] = useState(0);
  const [spotSliderMode, setSpotSliderMode] = useState(() => {
    const saved = localStorage.getItem('crystal_spot_slider_mode');
    return saved || 'slider';
  });
  const [trenchesSliderMode, setTrenchesSliderMode] = useState<'presets' | 'increment' | 'slider'>('presets');
  const [trenchesSliderPresets, setTrenchesSliderPresets] = useState([25, 50, 75, 100]);
  const [trenchesSliderIncrement, setTrenchesSliderIncrement] = useState(5);
  const [spotSliderPresets, setSpotSliderPresets] = useState<number[]>(() => {
    const saved = localStorage.getItem('crystal_spot_slider_presets');
    return saved ? JSON.parse(saved) : [25, 50, 75];
  });
  const [spotSliderIncrement, setSpotSliderIncrement] = useState<number>(() => {
    const saved = localStorage.getItem('crystal__spot_slider_increment');
    return saved ? parseFloat(saved) : 10;
  });
  const [claimableFees, setClaimableFees] = useState<{ [key: string]: number } | undefined>(
    undefined
  );
  const [tokenIn, setTokenIn] = useState(() => {
    if (location.pathname.slice(1) == 'send') {
      const token = searchParams.get('token');
      if (token && tokendict[getAddress(token)]) {
        return getAddress(token);
      }
    } else {
      let token = searchParams.get('tokenIn');
      if (token && tokendict[getAddress(token)]) {
        return getAddress(token);
      } else {
        token = searchParams.get('tokenOut');
        if (token) {
          token = getAddress(token);
          for (const market in markets) {
            if (markets[market].baseAddress == token) {
              return markets[market].quoteAddress;
            }
          }
          for (const market in markets) {
            if (markets[market].quoteAddress == token) {
              return markets[market].baseAddress;
            }
          }
        }
      }
    }
    return usdc;
  });
  const [tokenOut, setTokenOut] = useState(() => {
    let tokenIn =
      location.pathname.slice(1) == 'send'
        ? searchParams.get('token')
        : searchParams.get('tokenIn');
    let tokenOut = searchParams.get('tokenOut');
    if (tokenIn && tokenOut) {
      tokenIn = getAddress(tokenIn);
      tokenOut = getAddress(tokenOut);
      if (tokendict[tokenIn] && tokendict[tokenOut]) {
        if (getMarket(tokenIn, tokenOut)) {
          return tokenOut;
        } else {
          const path = findShortestPath(tokenIn, tokenOut);
          if (path && path.length > 1 && location.pathname.slice(1) == 'swap') {
            return tokenOut;
          } else {
            for (const market in markets) {
              if (markets[market].baseAddress == tokenIn) {
                return markets[market].quoteAddress;
              }
            }
            for (const market in markets) {
              if (markets[market].quoteAddress == tokenIn) {
                return markets[market].baseAddress;
              }
            }
          }
        }
      }
    } else if (tokenIn) {
      tokenIn = getAddress(tokenIn);
      if (tokendict[tokenIn]) {
        for (const market in markets) {
          if (markets[market].baseAddress == tokenIn) {
            return markets[market].quoteAddress;
          }
        }
        for (const market in markets) {
          if (markets[market].quoteAddress == tokenIn) {
            return markets[market].baseAddress;
          }
        }
      }
    } else if (tokenOut) {
      tokenOut = getAddress(tokenOut);
      if (tokendict[tokenOut]) {
        return tokenOut;
      }
    }
    return eth;
  });
  const activeMarket = getMarket(tokenIn, tokenOut);
  const activeMarketKey = (activeMarket.baseAsset + activeMarket.quoteAsset).replace(
    new RegExp(
      `^${wethticker}|${wethticker}$`,
      'g'
    ),
    ethticker
  );
  const multihop = activeMarket.path.length > 2;
  const [usedRefLink, setUsedRefLink] = useState('');
  const [usedRefAddress, setUsedRefAddress] = useState(
    '0x0000000000000000000000000000000000000000' as `0x${string}`,
  );
  const [simpleView, setSimpleView] = useState(false);
  const [hideNotificationPopups, setHideNotificationPopups] = useState(() => {
    return JSON.parse(localStorage.getItem('crystal_hide_notification_popups') || 'false');
  });
  const [rpcUrl, setRpcUrl] = useState(() => localStorage.getItem('crystal_rpc_url') || '')
  const [graphUrl, setGraphUrl] = useState(() => localStorage.getItem('crystal_graph_url') || '')
  const [notificationPosition, setNotificationPosition] = useState(() => {
    const saved = localStorage.getItem('crystal_notification_position');
    return saved || 'bottom-right';
  });
  const [showPreview, setShowPreview] = useState(false);
  const [previewPosition, setPreviewPosition] = useState<string | null>(null);
  const [previewTimer, setPreviewTimer] = useState<NodeJS.Timeout | null>(null);
  const [previewExiting, setPreviewExiting] = useState(false);
  const [selectedToken, setSelectedToken] = useState<any>(null);
  const [onSelectTokenCallback, setOnSelectTokenCallback] = useState<((token: any) => void) | null>(null);
  const [vaultDepositAmounts, setVaultDepositAmounts] = useState<any>({
    shares: 0n,
    quote: 0n,
    base: 0n
  });
  const [vaultQuoteExceedsBalance, setVaultQuoteExceedsBalance] = useState(false);
  const [vaultBaseExceedsBalance, setVaultBaseExceedsBalance] = useState(false);
  const [withdrawShares, setWithdrawShares] = useState('');
  const [withdrawExceedsBalance, setWithdrawExceedsBalance] = useState(false);
  const [withdrawPreview, setWithdrawPreview] = useState<{ amountQuote: bigint, amountBase: bigint } | null>(null);
  const [vaultInputStrings, setVaultInputStrings] = useState<{ quote: string, base: string }>({ quote: '', base: '' });
  const [selectedVault, setselectedVault] = useState<any | null>(null);
  const [isVaultDepositSigning, setIsVaultDepositSigning] = useState(false);
  const [isVaultWithdrawSigning, setIsVaultWithdrawSigning] = useState(false); const [trenchesSelectedWallets, setTrenchesSelectedWallets] = useState<string[]>([]);
  const [trenchesPositions, setTrenchesPositions] = useState<Position[]>([]);
  const [trenchesLoading, setTrenchesLoading] = useState(false);

  const fetchTrenchesPositions = useCallback(async (walletAddresses: string[]) => {
    if (walletAddresses.length === 0) {
      setTrenchesPositions([]);
      return;
    }

    setTrenchesLoading(true);

    try {
      const positionsPromises = walletAddresses.map(async (address) => {
        const response = await fetch(`/api/positions/${address}`);
        const data = await response.json();
        return data.positions || [];
      });

      const allPositionsArrays = await Promise.all(positionsPromises);

      const combinedPositions = allPositionsArrays.flat();

      const positionsMap = new Map<string, Position>();

      combinedPositions.forEach(position => {
        const existing = positionsMap.get(position.tokenId);

        if (existing) {
          existing.boughtTokens += position.boughtTokens;
          existing.soldTokens += position.soldTokens;
          existing.spentNative += position.spentNative;
          existing.receivedNative += position.receivedNative;
          existing.remainingTokens += position.remainingTokens;
          existing.pnlNative = existing.receivedNative + (existing.remainingTokens * (existing.lastPrice || 0)) - existing.spentNative;
          existing.remainingPct = existing.boughtTokens > 0 ? (existing.remainingTokens / existing.boughtTokens) * 100 : 0;
        } else {
          positionsMap.set(position.tokenId, { ...position });
        }
      });

      setTrenchesPositions(Array.from(positionsMap.values()));
    } catch (error) {
      console.error('Error fetching trenches positions:', error);
      setTrenchesPositions([]);
    } finally {
      setTrenchesLoading(false);
    }
  }, []);

  const handleTrenchesWalletsChange = useCallback((wallets: string[]) => {
    setTrenchesSelectedWallets(wallets);
    fetchTrenchesPositions(wallets);
  }, [fetchTrenchesPositions]);

  const updateNotificationPosition = (position: string) => {
    if (previewTimer) {
      clearTimeout(previewTimer);
      setPreviewTimer(null);
    }

    if (showPreview && previewPosition !== position) {
      setPreviewExiting(true);

      setTimeout(() => {
        setPreviewExiting(false);
        setShowPreview(false);

        setTimeout(() => {
          setPreviewPosition(position);
          setShowPreview(true);
          setNotificationPosition(position);
          localStorage.setItem('crystal_notification_position', position);

          const newTimer = setTimeout(() => {
            setPreviewExiting(true);
            setTimeout(() => {
              setShowPreview(false);
              setPreviewPosition(null);
              setPreviewExiting(false);
            }, 300);
          }, 3000);

          setPreviewTimer(newTimer);
        }, 50);
      }, 300);
    } else {
      setPreviewPosition(position);
      setShowPreview(true);
      setNotificationPosition(position);
      localStorage.setItem('crystal_notification_position', position);

      const newTimer = setTimeout(() => {
        setPreviewExiting(true);
        setTimeout(() => {
          setShowPreview(false);
          setPreviewPosition(null);
          setPreviewExiting(false);
        }, 300);
      }, 3000);

      setPreviewTimer(newTimer);
    }
  };
  const [hiddenPopupTypes, setHiddenPopupTypes] = useState(() => {
    return JSON.parse(localStorage.getItem('crystal_hidden_popup_types') || '{}');
  });
  const updateHiddenPopupType = (actionType: string, hide: boolean) => {
    const newHiddenTypes = { ...hiddenPopupTypes, [actionType]: hide };
    setHiddenPopupTypes(newHiddenTypes);
    localStorage.setItem('crystal_hidden_popup_types', JSON.stringify(newHiddenTypes));
  };
  const updateMultipleHiddenPopupTypes = (types: string[], hide: boolean) => {
    const newHiddenTypes = { ...hiddenPopupTypes };
    types.forEach(type => {
      newHiddenTypes[type] = hide;
    });
    setHiddenPopupTypes(newHiddenTypes);
    localStorage.setItem('crystal_hidden_popup_types', JSON.stringify(newHiddenTypes));
  };
  const [activeSettingsSection, setActiveSettingsSection] = useState(() => {
    const saved = localStorage.getItem('crystal_active_settings_section');
    return saved || 'general';
  });
  const updateActiveSettingsSection = (section: string) => {
    setActiveSettingsSection(section);
    localStorage.setItem('crystal_active_settings_section', section);
  };
  const [isMarksVisible, setIsMarksVisible] = useState(() => {
    const saved = localStorage.getItem('crystal_marks_visible');
    return saved !== null ? JSON.parse(saved) : true;
  });
  const [isOrdersVisible, setIsOrdersVisible] = useState(() => {
    const saved = localStorage.getItem('crystal_orders_visible');
    return saved !== null ? JSON.parse(saved) : true;
  });
  const [isOrderbookVisible, setIsOrderbookVisible] = useState(() => {
    const saved = localStorage.getItem('crystal_orderbook_visible');
    return saved !== null ? JSON.parse(saved) : true;
  });
  const [isOrderCenterVisible, setIsOrderCenterVisible] = useState(() => {
    const saved = localStorage.getItem('crystal_ordercenter_visible');
    return saved !== null ? JSON.parse(saved) : true;
  });
  const [orderbookWidth, setOrderbookWidth] = useState<number>(() => {
    const saved = localStorage.getItem('orderbookWidth');
    return saved ? parseInt(saved, 10) : 300;
  });
  const [orderCenterHeight, setOrderCenterHeight] = useState<number>(() => {
    const savedHeight = localStorage.getItem('orderCenterHeight');
    if (savedHeight !== null) {
      const parsedHeight = parseFloat(savedHeight);
      if (!isNaN(parsedHeight)) {
        return parsedHeight;
      }
    }

    if (window.innerHeight > 1080) return 367.58;
    if (window.innerHeight > 960) return 324.38;
    if (window.innerHeight > 840) return 282.18;
    if (window.innerHeight > 720) return 239.98;
    return 198.78;
  });
  const [selectedInterval, setSelectedInterval] = useState(() => {
    const savedTimeframe = localStorage.getItem('crystal_chart_timeframe');
    if (savedTimeframe !== null) {
      return (savedTimeframe === '1D'
        ? '1d'
        : savedTimeframe === '240'
          ? '4h'
          : savedTimeframe === '60'
            ? '1h'
            : savedTimeframe + 'm')
    }

    return '5m'
  });
  const [showChartOutliers, setShowChartOutliers] = useState(() => {
    return JSON.parse(localStorage.getItem('crystal_show_chart_outliers') || 'false');
  });
  const [isAudioEnabled, setIsAudioEnabled] = useState(() => {
    return JSON.parse(localStorage.getItem('crystal_audio_notifications') || 'false');
  });

  const [obInterval, setOBInterval] = useState<number>(() => {
    const stored = localStorage.getItem(
      `${activeMarket.baseAsset}_ob_interval`,
    );
    return stored !== null ? JSON.parse(stored) : 0.1;
  });
  // Spot settings
  const [spotOrderbookPosition, setSpotOrderbookPosition] = useState(() => {
    const saved = localStorage.getItem('crystal_spot_orderbook');
    return saved === 'left' ? 'left' : 'right';
  });

  const [spotLayoutSettings, setSpotLayoutSettings] = useState(() => {
    const saved = localStorage.getItem('crystal_spot_layout');
    return saved === 'alternative' ? 'alternative' : 'default';
  });

  // Perps settings
  const [perpsOrderbookPosition, setPerpsOrderbookPosition] = useState(() => {
    const saved = localStorage.getItem('crystal_perps_orderbook');
    return saved === 'left' ? 'left' : 'right';
  });

  const [perpsLayoutSettings, setPerpsLayoutSettings] = useState(() => {
    const saved = localStorage.getItem('crystal_perps_layout');
    return saved === 'alternative' ? 'alternative' : 'default';
  });

  // Spectra settings
  const [spectraOrderbookPosition, setSpectraOrderbookPosition] = useState(() => {
    const saved = localStorage.getItem('crystal_spectra_orderbook');
    return saved === 'left' ? 'left' : 'right';
  });

  const [spectraLayoutSettings, setSpectraLayoutSettings] = useState(() => {
    const saved = localStorage.getItem('crystal_spectra_layout');
    return saved === 'alternative' ? 'alternative' : 'default';
  });

  // Helper functions to get active settings
  const getActiveLayoutSettings = () => {
    switch (activeTradingMode) {
      case 'perps': return perpsLayoutSettings;
      case 'spectra': return spectraLayoutSettings;
      default: return spotLayoutSettings;
    }
  };

  const getActiveOrderbookPosition = () => {
    switch (activeTradingMode) {
      case 'perps': return perpsOrderbookPosition;
      case 'spectra': return spectraOrderbookPosition;
      default: return spotOrderbookPosition;
    }
  };
  const [popup, setpopup] = useState(0);

  const [slippage, setSlippage] = useState(() => {
    const saved = localStorage.getItem('crystal_slippage');
    return saved !== null ? BigInt(saved) : BigInt(9900);
  });
  const [slippageString, setSlippageString] = useState(() => {
    const saved = localStorage.getItem('crystal_slippage_string');
    return saved !== null ? saved : '1';
  });
  const [orderType, setorderType] = useState(() => {
    const saved = localStorage.getItem('crystal_order_type');
    return saved !== null ? JSON.parse(saved) : 1;
  });
  const [isStake, setIsStake] = useState(() => {
    return true
  })
  const [addliquidityonly, setAddLiquidityOnly] = useState(() => {
    const saved = localStorage.getItem('crystal_add_liquidity_only');
    return saved !== null ? JSON.parse(saved) : false;
  });
  const [tokenString, settokenString] = useState('');
  const [amountIn, setamountIn] = useState(() => {
    const amount = searchParams.get('amountIn');
    if (amount) {
      return BigInt(amount);
    }
    return BigInt(0);
  });
  const [amountOutSwap, setamountOutSwap] = useState(() => {
    if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
      const amount = searchParams.get('amountOut');
      if (amount) {
        setswitched(true);
        return BigInt(amount);
      }
      else if ((tokenIn == eth && tokenOut == weth) ||
        (tokenIn == weth && tokenOut == eth)) {
        return amountIn
      }
    }
    return BigInt(0);
  });
  const [inputString, setInputString] = useState(() => {
    const amount = searchParams.get('amountIn');
    if (amount && Number(amount) > 0) {
      return customRound(
        Number(amount) / 10 ** Number(tokendict[tokenIn].decimals),
        3,
      )
        .toString()
        .replace(/(\.\d*?[1-9])0+$/g, '$1')
        .replace(/\.0+$/, '');
    }
    return '';
  });
  const [outputString, setoutputString] = useState(() => {
    if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
      const amount = searchParams.get('amountOut');
      if (amount && Number(amount) > 0) {
        return customRound(
          Number(amount) / 10 ** Number(tokendict[tokenOut].decimals),
          3,
        )
          .toString()
          .replace(/(\.\d*?[1-9])0+$/g, '$1')
          .replace(/\.0+$/, '');
      }
      else if ((tokenIn == eth && tokenOut == weth) ||
        (tokenIn == weth && tokenOut == eth)) {
        return inputString
      }
    }
    return '';
  });

  const [quickAmounts, setQuickAmounts] = useState({
    new: localStorage.getItem('explorer-quickbuy-new') ?? '1000',
    graduating: localStorage.getItem('explorer-quickbuy-graduating') ?? '1000',
    graduated: localStorage.getItem('explorer-quickbuy-graduated') ?? '1000',
  });

  const [activePresets, setActivePresets] = useState({
    new: 1,
    graduating: 1,
    graduated: 1
  });

  const [buyPresets, setBuyPresets] = useState(() => loadBuyPresets());

  const buyPresetsWithAmount = {
    1: { ...buyPresets[1], amount: '5' },
    2: { ...buyPresets[2], amount: '20' },
    3: { ...buyPresets[3], amount: '100' }
  };

  const [sellPresets, setSellPresets] = useState(() => loadSellPresets());

  const [monPresets, setMonPresets] = useState(() => {
    try {
      const saved = localStorage.getItem('crystal_mon_presets');
      if (saved) {
        return JSON.parse(saved);
      }
      return [100, 500, 1000, 10000];
    } catch (error) {
      console.error('Error loading MON presets:', error);
      return [100, 500, 1000, 10000];
    }
  });

  const setQuickAmount = (category: string, amount: string) => {
    setQuickAmounts(prev => ({
      ...prev,
      [category]: amount
    }));
  };

  const setActivePreset = (category: string, preset: number) => {
    setActivePresets(prev => ({
      ...prev,
      [category]: preset
    }));
  };

  const handleInputFocus = () => {
  };
  const [isComposing, setIsComposing] = useState(false);
  const [sendInputString, setsendInputString] = useState('');
  const [limitPriceString, setlimitPriceString] = useState('');
  const [allowance, setallowance] = useState(BigInt(0));
  const [warning, setwarning] = useState(0);
  const [lowestAsk, setlowestAsk] = useState(BigInt(0));
  const [highestBid, sethighestBid] = useState(BigInt(0));
  const [reserveQuote, setReserveQuote] = useState(BigInt(0));
  const [reserveBase, setReserveBase] = useState(BigInt(0));
  const [priceImpact, setPriceImpact] = useState('');
  const [averagePrice, setAveragePrice] = useState('0');
  const [tradeFee, setTradeFee] = useState(`0 ${tokendict[tokenIn].ticker}`);
  const [stateIsLoading, setStateIsLoading] = useState(false);
  const [displayValuesLoading, setDisplayValuesLoading] = useState(false);
  const [portfolioColorValue, setPortfolioColorValue] = useState('#00b894');
  const [recipient, setrecipient] = useState('');
  const [limitPrice, setlimitPrice] = useState(BigInt(0));
  const [limitChase, setlimitChase] = useState(true);
  const [isLimitEditing, setIsLimitEditing] = useState(false)
  const [orders, setorders] = useState<any[]>([]);
  const [canceledorders, setcanceledorders] = useState<any[]>([]);
  const [tradehistory, settradehistory] = useState<any[]>([]);
  const [tradesByMarket, settradesByMarket] = useState<any>({});
  const [tokenBalances, setTokenBalances] = useState<any>({});
  const [balanceAddress, setBalanceAddress] = useState<string>('')
  const [transactions, setTransactions] = useState<any[]>([]);
  const [mids, setmids] = useState<any>({});
  const [sliderPercent, setSliderPercent] = useState(0);
  const [displayMode, setDisplayMode] = useState('token');
  const [swapButton, setSwapButton] = useState(5);
  const [swapButtonDisabled, setSwapButtonDisabled] = useState(true);
  const [limitButton, setLimitButton] = useState(8);
  const [limitButtonDisabled, setLimitButtonDisabled] = useState(true);
  const [sendButton, setSendButton] = useState(5);
  const [sendButtonDisabled, setSendButtonDisabled] = useState(true);
  const [sendPopupButton, setSendPopupButton] = useState(5);
  const [sendPopupButtonDisabled, setSendPopupButtonDisabled] = useState(true);
  const [scaleStart, setScaleStart] = useState(BigInt(0));
  const [scaleStartString, setScaleStartString] = useState('');
  const [scaleEnd, setScaleEnd] = useState(BigInt(0));
  const [scaleEndString, setScaleEndString] = useState('');
  const [scaleOrders, setScaleOrders] = useState(BigInt(0));
  const [scaleOrdersString, setScaleOrdersString] = useState('');
  const [scaleSkew, setScaleSkew] = useState(1);
  const [scaleSkewString, setScaleSkewString] = useState('1.00');
  const [scaleButton, setScaleButton] = useState(12)
  const [scaleButtonDisabled, setScaleButtonDisabled] = useState(true)
  const [isBlurred, setIsBlurred] = useState(false);
  const [prevOrderData, setPrevOrderData] = useState<any[]>([])
  const [tradesloading, settradesloading] = useState(true);
  const [chartDays, setChartDays] = useState<number>(1);
  const [marketsData, setMarketsData] = useState<any[]>([]);
  const [chartData, setChartData] = useState<[DataPoint[], string, boolean]>([[], '', showChartOutliers]);
  const [editingOrder, setEditingOrder] = useState<any>(null);
  const [isEditingSigning, setIsEditingSigning] = useState(false);
  const openEditOrderPopup = (order: any) => {
    setEditingOrder(order);
    const currentPrice = order[0] / Number(markets[order[4]].priceFactor);
    setCurrentLimitPrice(currentPrice);
    setpopup(19);
  };
  const openEditOrderSizePopup = (order: any) => {
    setEditingOrderSize(order);

    const marketKey = order[4];
    const market = (markets as any)[marketKey];
    const isBuyOrder = order[3] === 1;

    const scaleFactor = Number(market.scaleFactor);
    const quoteDecimals = Number(market.quoteDecimals);
    const baseDecimals = Number(market.baseDecimals);

    let originalSize;

    if (isBuyOrder) {
      let quotePrice = 1;
      if (market.quoteAsset !== 'USDC') {
        const chainConfig = (settings.chainConfig as any)[activechain];
        const quotePriceKey = (market.quoteAsset == chainConfig?.wethticker ?
          chainConfig.ethticker : market.quoteAsset) + 'USDC';

        quotePrice = (trades as any)[quotePriceKey]?.[0]?.[3] /
          Number((markets as any)[quotePriceKey]?.priceFactor) || 1;
      }

      originalSize = parseFloat((order[8] * quotePrice / (scaleFactor * 10 ** quoteDecimals)).toFixed(2));
    } else {
      originalSize = parseFloat((order[2] / (10 ** baseDecimals)).toFixed(6));
    }

    setOriginalOrderSize(originalSize);
    setCurrentOrderSize(originalSize);
    setOrderSizePercent(100);
    setHasEditedSize(false);
    setpopup(20);
  };
  const handleEditLimitPriceConfirm = async () => {
    if (isEditingSigning || !editingOrder) return;

    try {
      setIsEditingSigning(true);
      await handleSetChain();
      const scaledPrice = Math.round(currentLimitPrice * Number(markets[editingOrder[4]].priceFactor));

      await sendUserOperationAsync({
        uo: replaceOrder(
          router,
          BigInt(0),
          (editingOrder[3] == 1 ? markets[editingOrder[4]].quoteAsset : markets[editingOrder[4]].baseAsset) == settings.chainConfig[activechain].ethticker ? settings.chainConfig[activechain].weth : editingOrder[3] == 1 ? markets[editingOrder[4]].quoteAddress : markets[editingOrder[4]].baseAddress,
          (editingOrder[3] == 1 ? markets[editingOrder[4]].baseAsset : markets[editingOrder[4]].quoteAsset) == settings.chainConfig[activechain].ethticker ? settings.chainConfig[activechain].weth : editingOrder[3] == 1 ? markets[editingOrder[4]].baseAddress : markets[editingOrder[4]].quoteAddress,
          false,
          false,
          BigInt(editingOrder[0]),
          BigInt(editingOrder[1]),
          BigInt(scaledPrice),
          BigInt(0),
          BigInt(Math.floor(Date.now() / 1000) + 900),
          usedRefAddress
        )
      });

      refetch();
      setpopup(0);
      setEditingOrder(null);
    } catch (error) {
      console.error('Error editing order:', error);
      const originalPrice = editingOrder[0] / Number(markets[editingOrder[4]].priceFactor);
      setCurrentLimitPrice(originalPrice);
    } finally {
      setIsEditingSigning(false);
    }
  };
  const [editingOrderSize, setEditingOrderSize] = useState<any>(null);
  const [currentOrderSize, setCurrentOrderSize] = useState<number>(0);
  const [hasEditedSize, setHasEditedSize] = useState(false);
  const [isEditingSizeSigning, setIsEditingSizeSigning] = useState(false);
  const handleEditOrderSizeConfirm = async () => {
    if (isEditingSizeSigning || !editingOrderSize) return;

    try {
      setIsEditingSizeSigning(true);
      await handleSetChain();
      const tokenAddress = editingOrderSize[3] === 1
        ? markets[editingOrderSize[4]].quoteAddress
        : markets[editingOrderSize[4]].baseAddress;
      const tokenDecimals = Number(tokendict[tokenAddress].decimals);
      const scaledSize = BigInt(
        Math.round(currentOrderSize * 10 ** tokenDecimals)
      );
      await sendUserOperationAsync({
        uo: replaceOrder(
          router,
          BigInt(0),
          (
            (editingOrderSize[3] === 1
              ? markets[editingOrderSize[4]].quoteAsset
              : markets[editingOrderSize[4]].baseAsset
            ) === settings.chainConfig[activechain].ethticker
              ? settings.chainConfig[activechain].weth
              : editingOrderSize[3] === 1
                ? markets[editingOrderSize[4]].quoteAddress
                : markets[editingOrderSize[4]].baseAddress
          ),
          (
            (editingOrderSize[3] === 1
              ? markets[editingOrderSize[4]].baseAsset
              : markets[editingOrderSize[4]].quoteAsset
            ) === settings.chainConfig[activechain].ethticker
              ? settings.chainConfig[activechain].weth
              : editingOrderSize[3] === 1
                ? markets[editingOrderSize[4]].baseAddress
                : markets[editingOrderSize[4]].quoteAddress
          ),
          false,
          false,
          BigInt(editingOrderSize[0]),
          BigInt(editingOrderSize[1]),
          BigInt(editingOrderSize[0]),
          scaledSize,
          BigInt(Math.floor(Date.now() / 1000) + 900),
          usedRefAddress
        )
      });

      refetch();
      setpopup(0);
      setEditingOrderSize(null);

    } catch (error) {
      console.error('Error editing order size:', error);
      setCurrentOrderSize(originalOrderSize);
    } finally {
      setIsEditingSizeSigning(false);
    }
  };
  const { chartData: portGraph, portChartLoading } = usePortfolioData(
    address,
    Object.values(tokendict),
    chartDays,
    tokenBalances,
    setTotalAccountValue,
    marketsData,
    stateIsLoading,
    (popup == 4 && connected) || location.pathname.slice(1) == 'portfolio',
    balanceAddress
  );
  const [tokenData, setTokenData] = useState<Partial<Token>>();
  const [isVertDragging, setIsVertDragging] = useState(false);
  const [trades, setTrades] = useState<
    [boolean, string, string, string, string][]
  >([]);
  const [spreadData, setSpreadData] = useState<any>({});
  const [activeSection, setActiveSection] = useState<
    'orders' | 'tradeHistory' | 'orderHistory' | 'balances'
  >(() => {
    const section = localStorage.getItem('crystal_oc_tab');
    return ['orders', 'tradeHistory', 'orderHistory', 'balances'].includes(
      String(section),
    )
      ? (section as 'orders' | 'tradeHistory' | 'orderHistory' | 'balances')
      : 'orders';
  });
  const [filter, setFilter] = useState<'all' | 'buy' | 'sell'>(() => {
    const f = localStorage.getItem('crystal_oc_filter');
    return ['all', 'buy', 'sell'].includes(String(f))
      ? (f as 'all' | 'buy' | 'sell')
      : 'all';
  });
  const [onlyThisMarket, setOnlyThisMarket] = useState<boolean>(() => {
    const only = localStorage.getItem('crystal_only_this_market');
    return only !== null ? JSON.parse(only) : false;
  });
  const [baseInterval, setBaseInterval] = useState<number>(0.1);
  const [viewMode, setViewMode] = useState<'both' | 'buy' | 'sell'>(() => {
    const stored = localStorage.getItem('ob_viewmode');
    return ['both', 'buy', 'sell'].includes(String(stored))
      ? (stored as 'both' | 'buy' | 'sell')
      : 'both';
  });
  const [obTab, setOBTab] = useState<'orderbook' | 'trades'>(() => {
    const stored = localStorage.getItem('ob_active_tab');

    if (['orderbook', 'trades'].includes(stored ?? '')) {
      return stored as 'orderbook' | 'trades';
    }

    return mobileView === 'trades' ? 'trades' : 'orderbook';
  });
  const [amountsQuote, setAmountsQuote] = useState(() => {
    const stored = localStorage.getItem('ob_amounts_quote');

    return ['Quote', 'Base'].includes(String(stored))
      ? (stored as string)
      : 'Quote';
  });
  const [roundedBuyOrders, setRoundedBuyOrders] = useState<{ orders: any[], key: string, amountsQuote: string }>({ orders: [], key: '', amountsQuote });
  const [roundedSellOrders, setRoundedSellOrders] = useState<{ orders: any[], key: string, amountsQuote: string }>({ orders: [], key: '', amountsQuote });
  const [liquidityBuyOrders, setLiquidityBuyOrders] = useState<{ orders: any[], market: string }>({ orders: [], market: '' });
  const [liquiditySellOrders, setLiquiditySellOrders] = useState<{ orders: any[], market: string }>({ orders: [], market: '' });
  const [processedLogs, setProcessedLogs] = useState<Set<string>>(new Set());
  const [selectedIndex, setSelectedIndex] = useState<number>(0);
  const emptyFunction = useCallback(() => { }, []);
  const memoizedTokenList = useMemo(
    () => Object.values(tokendict),
    [tokendict],
  );
  const memoizedSortConfig = useMemo(() => ({ column: 'balance', direction: 'desc' }), []);
  const [isMobileDragging, setIsMobileDragging] = useState(false);
  const [mobileDragY, setMobileDragY] = useState(0);
  const [mobileStartY, setMobileStartY] = useState(0);
  const [currentLimitPrice, setCurrentLimitPrice] = useState<number>(0);
  const [currentLimitPriceString, setCurrentLimitPriceString] = useState('');
  const [keybindError, setKeybindError] = useState<string | null>(null);
  const [duplicateKeybind, setDuplicateKeybind] = useState<string | null>(null);
  const [keybinds, setKeybinds] = useState(() => {
    const saved = localStorage.getItem('crystal_keybinds');
    return saved ? JSON.parse(saved) : {
      submitTransaction: 'Enter',
      switchTokens: 'KeyZ',
      maxAmount: 'KeyA',
      focusInput: 'KeyF',
      openSettings: 'KeyP',
      openWallet: 'KeyI',
      openTokenInSelect: 'KeyQ',
      openTokenOutSelect: 'KeyE',
      cancelAllOrders: 'KeyC',
      cancelTopOrder: 'KeyX',
      toggleFavorite: 'KeyM',
      toggleSimpleView: 'KeyV',
      refreshQuote: 'KeyR',
    };
  });
  const [editingKeybind, setEditingKeybind] = useState<string | null>(null);
  const [isListeningForKey, setIsListeningForKey] = useState(false);
  const [mainWalletBalances, setMainWalletBalances] = useState<any>({})
  const [selectedTokenIndex, setSelectedTokenIndex] = useState(0);
  const scrollToToken = (index: number) => {
    const tokenListContainer = document.querySelector('.tokenlist');
    if (!tokenListContainer) return;

    const tokenButtons = tokenListContainer.querySelectorAll('.tokenbutton');
    const selectedButton = tokenButtons[index];

    if (selectedButton) {
      selectedButton.scrollIntoView({
        behavior: 'auto',
        block: 'nearest',
      });
    }
  };
  const handleTokenSelectKeyDown = (e: React.KeyboardEvent) => {
    const currentTokenList = Object.values(tokendict).filter(
      (token) =>
        token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
        token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
        token.address.toLowerCase().includes(tokenString.toLowerCase())
    );

    if (!currentTokenList || currentTokenList.length === 0) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedTokenIndex((prev) => {
          const newIndex = prev < currentTokenList.length - 1 ? prev + 1 : prev;
          scrollToToken(newIndex);
          return newIndex;
        });
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedTokenIndex((prev) => {
          const newIndex = prev > 0 ? prev - 1 : prev;
          scrollToToken(newIndex);
          return newIndex;
        });
        break;
      case 'Enter':
        e.preventDefault();
        if (currentTokenList[selectedTokenIndex]) {
          const tokenButtons = document.querySelectorAll('.tokenbutton');
          if (tokenButtons[selectedTokenIndex]) {
            (tokenButtons[selectedTokenIndex] as HTMLElement).click();
          }
        }
        break;
      case 'Escape':
        e.preventDefault();
        setpopup(0);
        settokenString('');
        break;
    }
  };
  const [orderSizeString, setOrderSizeString] = useState('');
  const displayValue = hasEditedSize
    ? orderSizeString
    : (originalOrderSize === 0 ? '' : originalOrderSize.toString());
  const [hasEditedPrice, setHasEditedPrice] = useState(false);
  const defaultGroups: AudioGroupSettings = {
    swap: true,
    order: true,
    transfer: true,
    approve: true,
  };

  const [audioGroups, setAudioGroups] = useState<AudioGroupSettings>(() => {
    const saved = localStorage.getItem('crystal_audio_groups');
    return saved ? JSON.parse(saved) : defaultGroups;
  });

  const toggleAudioGroup = (group: AudioGroups) => {
    setAudioGroups(prev => {
      const next = { ...prev, [group]: !prev[group] };
      localStorage.setItem('crystal_audio_groups', JSON.stringify(next));
      return next;
    });
  };

  function getGroupForAction(action: string): AudioGroups {
    if (action === 'swap' || action === 'swapFailed') return 'swap';
    if (['limit', 'fill', 'cancel', 'limitFailed'].includes(action)) return 'order';
    if (['send', 'sendFailed', 'wrap', 'unwrap', 'stake'].includes(action)) return 'transfer';
    if (action === 'approve') return 'approve';
    return 'swap';
  }
  // refs
  const popupref = useRef<HTMLDivElement>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);
  const realtimeCallbackRef = useRef<any>({});
  const initialMousePosRef = useRef(0);
  const initialHeightRef = useRef(0);
  const txPending = useRef(false);
  const lastRefGroupFetch = useRef(0);
  const lastNonceGroupFetch = useRef(0);
  const nonces = useRef<any>(new Map())
  const blockNumber = useRef(0n);
  const wsRef = useRef<WebSocket | null>(null);
  const pingIntervalRef = useRef<any>(null);
  const reconnectIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const prevAmountsQuote = useRef(amountsQuote)
  const backAudioRef = useRef<HTMLAudioElement>(null);
  // more constants
  const languageOptions = [
    { code: 'EN', name: 'English' },
    { code: 'ES', name: 'Espaol' },
    { code: 'CN', name: '' },
    { code: 'JP', name: '' },
    { code: 'KR', name: '' },
    { code: 'RU', name: '' },
    { code: 'ID', name: 'Indonesia' },
    { code: 'VN', name: 'Ting Vit' },
    { code: 'PH', name: 'Filipino' },
  ];

  const isWrap =
    (tokenIn == eth && tokenOut == weth) ||
    (tokenIn == weth && tokenOut == eth);

  const loading = stateloading
  // (stateloading ||
  //   tradesloading ||
  //   addressinfoloading);

  const { data: storkData } = useQuery({
    queryKey: ['stork'],
    queryFn: async () => {
      const storkBody = JSON.stringify({
        jsonrpc: '2.0',
        id: 1,
        method: 'eth_call',
        params: [{
          to: settings.chainConfig[activechain].stork,
          data: encodeFunctionData({
            abi: StorkAbi,
            functionName: 'getTemporalNumericValueUnsafeV1',
            args: ['0xa4f6b07ae0c89e3f3cc03c1badcc3e9adffdf7206bafcd56d142979800887385']
          })
        }]
      })
      const [storkRes] = await Promise.all([
        fetch(HTTP_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: storkBody }).then(r => r.json())
      ])
      return { price: (Number('0x' + storkRes?.result.slice(66)) / 1e18) }
    },
    enabled: true,
    refetchInterval: 5000,
    gcTime: 0
  })

  const monUsdPrice = storkData?.price || 0.05;

  const [walletTokenBalances, setWalletTokenBalances] = useState<any>({});
  const [walletsLoading, _setWalletsLoading] = useState(false);
  const [isTokenExplorerLoading, setIsTokenExplorerLoading] = useState(true);
  const [isUsernameSigning, setIsUsernameSigning] = useState(false);
  const [typedRefCode, setTypedRefCode] = useState(() => searchParams.get('ref') || '');
  const [usernameInput, setUsernameInput] = useState("");
  const [usernameError, setUsernameError] = useState("");
  const [isRefSigning, setIsRefSigning] = useState(false);
  const [error, setError] = useState('');
  const [username, setUsername] = useState('');
  const [sendAmountIn, setSendAmountIn] = useState(BigInt(0));
  const [sendInputAmount, setSendInputAmount] = useState('');
  const [sendUsdValue, setSendUsdValue] = useState('');
  const [sendTokenIn, setSendTokenIn] = useState(eth);
  const [isSigning, setIsSigning] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [sortField, setSortField] = useState<
    'volume' | 'price' | 'change' | 'favorites' | null
  >('volume');
  const [sortDirection, setSortDirection] = useState<
    'asc' | 'desc' | undefined
  >('desc');
  const { toggleFavorite } = useSharedContext();
  const [selectedVaultStrategy, setSelectedVaultStrategy] = useState<string | null>(null);
  const [vaultList, setVaultList] = useState<any>([]);
  const [isVaultsLoading, setIsVaultsLoading] = useState(true);
  const [depositors, setDepositors] = useState<any[]>([]);
  const [depositHistory, setDepositHistory] = useState<any[]>([]);
  const [withdrawHistory, setWithdrawHistory] = useState<any[]>([]);
  const [openOrders, setOpenOrders] = useState<any[]>([]);
  const [_allOrders, setAllOrders] = useState<any[]>([]);

  const audio = useMemo(() => {
    const a = new Audio(stepaudio);
    a.volume = 1;
    return a;
  }, []);

  const sortedMarkets = (marketsData.sort((a, b) => {
    if (!sortField || !sortDirection) return 0;

    let aValue: number = 0;
    let bValue: number = 0;

    switch (sortField) {
      case 'volume':
        aValue = parseFloat(a.volume.toString().replace(/,/g, ''));
        bValue = parseFloat(b.volume.toString().replace(/,/g, ''));
        break;
      case 'price':
        aValue = parseFloat(a.currentPrice.toString().replace(/,/g, ''));
        bValue = parseFloat(b.currentPrice.toString().replace(/,/g, ''));
        break;
      case 'change':
        aValue = parseFloat(a.priceChange.replace(/[+%]/g, ''));
        bValue = parseFloat(b.priceChange.replace(/[+%]/g, ''));
        break;
      case 'favorites':
        aValue = favorites.includes(a.baseAddress.toLowerCase()) ? 1 : 0;
        bValue = favorites.includes(b.baseAddress.toLowerCase()) ? 1 : 0;
        break;
      default:
        return 0;
    }

    return sortDirection === 'asc' ? aValue - bValue : bValue - aValue;
  }));

  const newTxPopup = useCallback((
    _transactionHash: any,
    _currentAction: any,
    _tokenIn: any,
    _tokenOut: any,
    _amountIn: any,
    _amountOut: any,
    _price: any = 0,
    _address: any = '',
  ) => {
    const shouldPlay = isAudioEnabled && audioGroups[getGroupForAction(_currentAction)];
    if (shouldPlay) {
      audio.currentTime = 0;
      audio.play().catch(console.error);
    }
    setTransactions((prevTransactions) => {
      const newTransaction = {
        explorerLink: `${settings.chainConfig[activechain].explorer}/tx/${_transactionHash}`,
        currentAction: _currentAction,
        tokenIn: _tokenIn,
        tokenOut: _tokenOut,
        amountIn: _amountIn,
        amountOut: _amountOut,
        price: _price,
        address: _address,
        timestamp: Date.now(),
        isNew: true,
        isExiting: false,
        identifier: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      };

      return [...prevTransactions, newTransaction];
    });
  }, [activechain, audio, isAudioEnabled, audioGroups]);

  const handleSetChain = useCallback(async () => {
    return await alchemyconfig?._internal?.wagmiConfig?.state?.connections?.entries()?.next()?.value?.[1]?.connector?.switchChain({ chainId: activechain as any });
  }, [activechain]);

  const formatDisplayValue = (
    rawAmount: number | bigint,
    decimals = 18,
    precision = 3,
  ) => {
    const actualAmount = customRound(
      Number(rawAmount) / 10 ** Number(decimals),
      precision,
    );

    if (parseFloat(actualAmount) < 1) {
      return actualAmount.toString();
    }

    if (parseFloat(actualAmount) >= 1e12) {
      return `${(parseFloat(actualAmount) / 1e12).toFixed(2)}T`;
    } else if (parseFloat(actualAmount) >= 1e9) {
      return `${(parseFloat(actualAmount) / 1e9).toFixed(2)}B`;
    } else if (parseFloat(actualAmount) >= 1e6) {
      return `${(parseFloat(actualAmount) / 1e6).toFixed(2)}M`;
    }

    return actualAmount.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
  };

  const formatUSDDisplay = (amount: number, k: boolean = false) => {
    if (amount === 0) return '$0.00';

    const absAmount = Math.abs(amount);
    if (absAmount >= 1e12) {
      return `$${(amount / 1e12).toFixed(2)}T`;
    } else if (absAmount >= 1e9) {
      return `$${(amount / 1e9).toFixed(2)}B`;
    } else if (absAmount >= 1e6) {
      return `$${(amount / 1e6).toFixed(2)}M`;
    } else if (k && absAmount >= 1e3) {
      return `$${(amount / 1e3).toFixed(2)}K`;
    }

    if (absAmount >= 1) {
      return `$${amount.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',')}`;
    }

    if (absAmount < 0.01) {
      return '<$0.01';
    }
    return `$${amount.toFixed(2)}`;
  };

  const calculateUSDValue = (
    amount: bigint,
    trades: any[],
    tokenAddress: string,
    market: any,
  ) => {
    if (amount === BigInt(0)) return 0;
    if (tokenAddress == market.quoteAddress && tokenAddress == usdc) {
      return Number(amount) / 10 ** 6;
    }
    else if (tokenAddress == eth || tokenAddress == weth) {
      return Number(amount) * monUsdPrice / 10 ** 18
    }
    else if (tokenAddress == market.quoteAddress) {
      return Number(amount) * tradesByMarket[(market.quoteAsset == wethticker ? ethticker : market.quoteAsset) + 'USDC']?.[0]?.[3]
        / Number(markets[(market.quoteAsset == wethticker ? ethticker : market.quoteAsset) + 'USDC']?.priceFactor) / 10 ** 18;
    }
    const latestPrice = fetchLatestPrice(trades, market);
    if (!latestPrice) return 0;
    const quotePrice = market.quoteAsset == 'USDC' ? 1 : tradesByMarket[(market.quoteAsset == wethticker ? ethticker : market.quoteAsset) + 'USDC']?.[0]?.[3]
      / Number(markets[(market.quoteAsset == wethticker ? ethticker : market.quoteAsset) + 'USDC']?.priceFactor)
    const usdValue = (Number(amount) * latestPrice * quotePrice / 10 ** Number(tokendict[tokenAddress].decimals));
    return Number(usdValue);
  };

  // calculate token value of usd
  const calculateTokenAmount = (
    usdValue: string,
    trades: any[],
    tokenAddress: string,
    market: any,
  ): bigint => {
    const usdNumeric = parseFloat(usdValue);
    if (!usdNumeric || usdNumeric == 0) return BigInt(0);

    if (tokenAddress === usdc) {
      return BigInt(Math.round(usdNumeric * 10 ** 6));
    }
    else if (tokenAddress == eth || tokenAddress == weth) {
      return BigInt(Math.round(usdNumeric / monUsdPrice * 10 ** 18))
    }

    const latestPrice = fetchLatestPrice(trades, market);
    if (!latestPrice) return BigInt(0);
    const quotePrice = market.quoteAsset == 'USDC' ? 1 : tradesByMarket[(market.quoteAsset == wethticker ? ethticker : market.quoteAsset) + 'USDC']?.[0]?.[3]
      / Number(markets[(market.quoteAsset == wethticker ? ethticker : market.quoteAsset) + 'USDC']?.priceFactor)
    return BigInt(
      Math.round(
        (usdNumeric / (latestPrice * quotePrice)) *
        10 ** Number(tokendict[tokenAddress].decimals),
      ),
    );
  };

  // vaults
  const [valueSeries, setValueSeries] = useState<Array<{ name: string; value: number; ts: number }>>([]);
  const [pnlSeries, setPnlSeries] = useState<Array<{ name: string; value: number; ts: number }>>([]);
  const [seriesLoading, setSeriesLoading] = useState(false);
  const [seriesError, setSeriesError] = useState<string | null>(null);
  const [activeVaultPerformance, _setActiveVaultPerformance] = useState<any>([
    { name: 'Jan', value: 12.4 },
    { name: 'Feb', value: 14.8 },
    { name: 'Mar', value: 18.2 },
    { name: 'Apr', value: 16.9 },
    { name: 'May', value: 21.3 },
    { name: 'Jun', value: 22.7 },
    { name: 'Jul', value: 24.5 },
  ]);
  const [vaultStrategyTimeRange, setVaultStrategyTimeRange] = useState<
    '1D' | '1W' | '1M' | 'All'
  >('1D');
  const [vaultStrategyChartType, setVaultStrategyChartType] = useState<
    'value' | 'pnl'
  >('value');

  const vaultChartData = vaultStrategyChartType === 'value' ? valueSeries : pnlSeries;

  const calculateSharesFromPercentage = (percentage: string, userShares: any) => {
    if (!percentage || !userShares) return '0';
    const percentageDecimal = parseFloat(percentage) / 100;
    const sharesToWithdraw = BigInt(Math.floor(Number(userShares) * percentageDecimal));
    return sharesToWithdraw.toString();
  };

  const handleWithdrawPercentageChange = (value: string) => {
    const cleanValue = value.replace(/[^\d.]/g, '');

    const numericValue = parseFloat(cleanValue);
    if (numericValue > 100) {
      setWithdrawPercentage('100');
    } else {
      setWithdrawPercentage(cleanValue);
    }

    setWithdrawExceedsBalance(false);
    const sharesToWithdraw = calculateSharesFromPercentage(cleanValue, selectedVault?.userShares);
    const userSharesBalance = BigInt(selectedVault?.userShares || 0);
    setWithdrawShares(sharesToWithdraw)
    setWithdrawPreview({ amountQuote: selectedVault?.quoteBalance * BigInt(sharesToWithdraw) / selectedVault?.totalShares, amountBase: selectedVault?.baseBalance * BigInt(sharesToWithdraw) / selectedVault?.totalShares });
    if (BigInt(sharesToWithdraw) > userSharesBalance) {
      setWithdrawExceedsBalance(true);
    }
  };

  const handleVaultDepositAmountChange = (type: 'quote' | 'base', value: string) => {
    if (/^\d*\.?\d{0,18}$/.test(value) && selectedVault) {
      const vaultTokenData = type == 'quote' ? tokendict[selectedVault?.quoteAsset] : tokendict[selectedVault?.baseAsset];
      if (vaultTokenData) {
        const tokenDecimals = Number(vaultTokenData.decimals) || 18;
        const enteredAmount = parseFloat(value) || 0;

        if (type === 'quote') {
          const amountBase = BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)) * selectedVault?.baseBalance / selectedVault?.quoteBalance
          const a = BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)) * selectedVault?.totalShares / selectedVault?.quoteBalance;
          const b = amountBase * selectedVault?.totalShares / selectedVault?.baseBalance
          const shares = a > b ? b : a
          setVaultInputStrings({
            [type]: value,
            'base': amountBase == 0n ? '' : customRound(
              Number(amountBase) /
              10 ** Number(tokendict[selectedVault?.baseAsset].decimals),
              3,
            ).toString()
          })
          setVaultDepositAmounts({
            shares,
            [type]: BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)),
            'base': amountBase,
          });
          setVaultQuoteExceedsBalance(BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)) > tokenBalances[vaultTokenData.address]);
          setVaultBaseExceedsBalance(amountBase > tokenBalances[selectedVault?.baseAsset]);
        } else {
          const amountQuote = BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)) * selectedVault?.quoteBalance / selectedVault?.baseBalance
          const a = BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)) * selectedVault?.totalShares / selectedVault?.baseBalance;
          const b = amountQuote * selectedVault?.totalShares / selectedVault?.quoteBalance
          const shares = a > b ? b : a
          setVaultInputStrings({
            [type]: value,
            'quote': amountQuote == 0n ? '' : customRound(
              Number(amountQuote) /
              10 ** Number(tokendict[selectedVault?.quoteAsset].decimals),
              3,
            ).toString()
          })
          setVaultDepositAmounts({
            shares,
            [type]: BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)),
            'quote': amountQuote,
          });
          setVaultBaseExceedsBalance(BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)) > tokenBalances[vaultTokenData.address]);
          setVaultQuoteExceedsBalance(amountQuote > tokenBalances[selectedVault?.quoteAsset]);
        }
      }
    }
  };

  const isVaultDepositEnabled = () => {
    return vaultDepositAmounts.quote > 0n && vaultDepositAmounts.base > 0n &&
      !vaultQuoteExceedsBalance && !vaultBaseExceedsBalance && vaultDepositAmounts;
  };

  const getVaultDepositButtonText = () => {
    if (vaultQuoteExceedsBalance || vaultBaseExceedsBalance) {
      return 'Insufficient Balance';
    }
    if (!vaultDepositAmounts) {
      return 'Enter Amounts';
    }
    return 'Deposit';
  };

  const getWithdrawButtonText = () => {
    if (withdrawExceedsBalance) {
      return 'Insufficient Shares';
    }
    if (!withdrawPreview) {
      return 'Enter Amount';
    }
    return 'Withdraw';
  };

  const handleVaultDeposit = async () => {
    if (!isVaultDepositEnabled()) return;

    try {
      setIsVaultDepositSigning(true);
      setDepositVaultError('');

      // Step 1: Validating
      setDepositVaultStep('validating');
      await new Promise(resolve => setTimeout(resolve, 500));

      await handleSetChain();

      const crystalVaultsAddress = settings.chainConfig[activechain]?.crystalVaults;
      const quoteTokenAddress = selectedVault.quoteAsset;
      const baseTokenAddress = selectedVault.baseAsset;

      const amountQuoteDesired = vaultDepositAmounts.quote;
      const amountBaseDesired = vaultDepositAmounts.base;

      const amountQuoteMin = (amountQuoteDesired * 50n) / 100n;
      const amountBaseMin = (amountBaseDesired * 50n) / 100n;

      // Step 2: Approve Quote Token if needed
      if (quoteTokenAddress !== '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' && vaultDepositAmounts.quote > 0n) {
        setDepositVaultStep('approve-quote');
        const approveQuoteUo = {
          target: quoteTokenAddress as `0x${string}`,
          data: encodeFunctionData({
            abi: [{
              inputs: [
                { name: "spender", type: "address" },
                { name: "amount", type: "uint256" }
              ],
              name: "approve",
              outputs: [{ name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            }],
            functionName: "approve",
            args: [crystalVaultsAddress as `0x${string}`, maxUint256],
          }),
          value: 0n,
        };
        await sendUserOperationAsync({ uo: approveQuoteUo });
      }

      // Step 3: Approve Base Token if needed
      if (baseTokenAddress !== '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' && vaultDepositAmounts.base > 0n) {
        setDepositVaultStep('approve-base');
        const approveBaseUo = {
          target: baseTokenAddress as `0x${string}`,
          data: encodeFunctionData({
            abi: [{
              inputs: [
                { name: "spender", type: "address" },
                { name: "amount", type: "uint256" }
              ],
              name: "approve",
              outputs: [{ name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            }],
            functionName: "approve",
            args: [crystalVaultsAddress as `0x${string}`, maxUint256],
          }),
          value: 0n,
        };
        await sendUserOperationAsync({ uo: approveBaseUo });
      }

      // Step 4: Deposit
      setDepositVaultStep('depositing');

      const ethValue =
        quoteTokenAddress === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' ? amountQuoteDesired :
          baseTokenAddress === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' ? amountBaseDesired : 0n;

      const depositUo = {
        target: crystalVaultsAddress as `0x${string}`,
        data: encodeFunctionData({
          abi: CrystalVaultsAbi,
          functionName: "deposit",
          args: [
            selectedVault.address as `0x${string}`,
            quoteTokenAddress as `0x${string}`,
            baseTokenAddress as `0x${string}`,
            amountQuoteDesired,
            amountBaseDesired,
            amountQuoteMin,
            amountBaseMin,
          ],
        }),
        value: ethValue,
      };

      await sendUserOperationAsync({ uo: depositUo });

      // Step 5: Success
      setDepositVaultStep('success');

      setTimeout(() => {
        setpopup(0);
        setselectedVault(null);
        setVaultDepositAmounts({ shares: 0n, quote: 0n, base: 0n });
        setVaultInputStrings({ quote: '', base: '' });
        setVaultQuoteExceedsBalance(false);
        setVaultBaseExceedsBalance(false);
        setDepositVaultStep('idle');
        setDepositVaultError('');
        refetch?.();
      }, 2000);

    } catch (e: any) {
      console.error('Vault deposit error:', e);
      setDepositVaultError(e?.message || 'An error occurred while depositing. Please try again.');
      setDepositVaultStep('idle');
    } finally {
      setIsVaultDepositSigning(false);
    }
  }

  const handleVaultWithdraw = async () => {
    if (withdrawShares == '' || parseFloat(withdrawShares) == 0 ||
      withdrawExceedsBalance || !withdrawPreview) return;

    try {
      setIsVaultWithdrawSigning(true);
      setWithdrawVaultError('');

      setWithdrawVaultStep('validating');
      await new Promise(resolve => setTimeout(resolve, 500));

      await handleSetChain();

      const crystalVaultsAddress = settings.chainConfig[activechain]?.crystalVaults;

      const amountQuoteMin = (withdrawPreview.amountQuote * 50n) / 100n;
      const amountBaseMin = (withdrawPreview.amountBase * 50n) / 100n;

      // Step 2: Withdrawing
      setWithdrawVaultStep('withdrawing');

      const withdrawUo = {
        target: crystalVaultsAddress as `0x${string}`,
        data: encodeFunctionData({
          abi: CrystalVaultsAbi,
          functionName: "withdraw",
          args: [
            selectedVault.address as `0x${string}`,
            selectedVault.quoteAsset as `0x${string}`,
            selectedVault.baseAsset as `0x${string}`,
            BigInt(withdrawShares),
            amountQuoteMin,
            amountBaseMin,
          ],
        }),
        value: 0n,
      };

      await sendUserOperationAsync({ uo: withdrawUo });

      // Step 3: Success
      setWithdrawVaultStep('success');

      setTimeout(() => {
        setpopup(0);
        setselectedVault(null);
        setWithdrawPercentage('');
        setWithdrawExceedsBalance(false);
        setWithdrawPreview(null);
        setWithdrawVaultStep('idle');
        setWithdrawVaultError('');
        refetch?.();
      }, 2000);

    } catch (e: any) {
      console.error('Vault withdrawal error:', e);
      setWithdrawVaultError(e?.message || 'An error occurred while withdrawing. Please try again.');
      setWithdrawVaultStep('idle');
    } finally {
      setIsVaultWithdrawSigning(false);
    }
  }

  const fetchSubgraph = async (endpoint: string, query: string, variables?: Record<string, any>) => {
    const res = await fetch(endpoint, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ query, variables }),
    });
    if (!res.ok) throw new Error(`subgraph http ${res.status}`);
    const json = await res.json();
    if (json.errors?.length) throw new Error(json.errors.map((e: any) => e.message).join('; '));
    return json.data;
  };

  // fetch vaults list
  useEffect(() => {
    if (!['earn'].includes(location.pathname.split('/')[1]) || !address) return;
    let cancelled = false;

    (async () => {
      setIsVaultsLoading(true);
      try {
        const resp = await fetch(`https://api.crystal.exchange/vaults/list?limit=1000`);
        if (!resp.ok) throw new Error(`backend ${resp.status}`);
        const payload = await resp.json();
        const rows: any[] = Array.isArray(payload?.vaults) ? payload.vaults : [];

        const mappedBase = rows.map((v: any) => {
          const qAddr = getAddress(v.quote) as `0x${string}`;
          const bAddr = getAddress(v.base) as `0x${string}`;

          const quoteDecimals =
            Number(v.quoteDecimals ?? tokendict[qAddr]?.decimals ?? 18);
          const baseDecimals =
            Number(v.baseDecimals ?? tokendict[bAddr]?.decimals ?? 18);

          const oc = v.latest ?? { quoteBalance: 0, baseBalance: 0 };
          const qb = BigInt(String(oc.quoteBalance ?? 0));
          const bb = BigInt(String(oc.baseBalance ?? 0));

          return {
            id: getAddress(v.vault),
            address: getAddress(v.vault),
            owner: String(v.owner || '').toLowerCase(),
            quoteAsset: qAddr,
            baseAsset: bAddr,
            quoteDecimals,
            baseDecimals,
            quoteTicker: tokendict[qAddr]?.ticker ?? 'QUOTE',
            baseTicker: tokendict[bAddr]?.ticker ?? 'BASE',
            totalShares: BigInt(String(v.circulatingShares ?? 0)),
            maxShares: BigInt(String(v.maxShares ?? 0)),
            quoteBalance: qb,
            baseBalance: bb,
            lockup: 0,
            locked: Boolean(v.locked),
            closed: Boolean(v.closed),
            name: v.name || 'Vault',
            desc: v.description ?? '',
            social1: v.socials?.social1 ?? '',
            social2: v.socials?.social2 ?? '',
            social3: v.socials?.social3 ?? '',
            type: 'Spot',
            userShares: 0n,
            decreaseOnWithdraw: false,
            tvlUsd: Number(v.tvlUsd ?? v.latest.usdValue ?? 0),
            snapshot: v.snapshot || null,
          };
        });

        if (cancelled) return;

        const concurrency = 6;
        const tfForProbe = 1;
        const chunks: typeof mappedBase[] = [];
        for (let i = 0; i < mappedBase.length; i += concurrency) {
          chunks.push(mappedBase.slice(i, i + concurrency));
        }

        let enriched: typeof mappedBase = [];
        for (const chunk of chunks) {
          if (cancelled) return;
          const results = await Promise.all(
            chunk.map(async (v) => {
              try {
                const r = await fetch(
                  `https://api.crystal.exchange/vaults/${v.address}/${address.toLowerCase()}/${tfForProbe}?limit=1`
                );
                if (!r.ok) throw new Error(String(r.status));
                const j = await r.json();
                const s = j?.userBalance?.shares ?? 0;
                const userShares = typeof s === 'bigint' ? s : BigInt(String(s));
                return { ...v, userShares };
              } catch {
                return v;
              }
            })
          );
          enriched = enriched.concat(results);
        }

        if (!cancelled) {
          setVaultList(enriched);
        }
      } catch (err) {
        console.error('backend vaults fetch failed', err);
        if (!cancelled) setVaultList([]);
      } finally {
        if (!cancelled) setIsVaultsLoading(false);
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [address, activechain, tokendict, !['earn'].includes(location.pathname.split('/')[1])]);

  // details when a vault is selected
  useEffect(() => {
    if (!['earn'].includes(location.pathname.split('/')[1])) return;
    let cancelled = false;
    let inFlight = false;

    const run = async () => {
      if (inFlight) return;
      inFlight = true;

      if (!selectedVaultStrategy) {
        setDepositors([]);
        setDepositHistory([]);
        setWithdrawHistory([]);
        setOpenOrders([]);
        setAllOrders([]);
        inFlight = false;
        return;
      }

      try {
        const mapRangeToTf = (r: '1D' | '1W' | '1M' | 'All') => {
          if (r === '1D') return 1;
          if (r === '1W') return 2;
          if (r === '1M') return 3;
          return 4;
        };

        const fmtLabel = (ts: number, r: '1D' | '1W' | '1M' | 'All') => {
          const d = new Date(ts * 1000);
          const pad = (n: number) => n.toString().padStart(2, '0');
          if (r === '1D') return `${pad(d.getHours())}:${pad(d.getMinutes())}`;
          if (r === '1W' || r === '1M') return `${pad(d.getMonth() + 1)}/${pad(d.getDate())}`;
          return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
        };

        const tf = mapRangeToTf(vaultStrategyTimeRange);
        const userAddr = address ?? '0x0000000000000000000000000000000000000000';
        const url = `https://api.crystal.exchange/vaults/${selectedVaultStrategy}/${userAddr}/${tf}`;

        const res = await fetch(url, { method: 'GET' });
        if (!res.ok) throw new Error(`backend ${res.status}`);
        const data = await res.json();

        const respDepositors = Array.isArray(data?.depositors) ? data.depositors : [];
        const paramsTotal = data?.vault?.params?.circulatingShares ?? 0;
        const paramsBI = typeof paramsTotal === 'bigint' ? paramsTotal : BigInt(String(paramsTotal || 0));
        const sumBI = respDepositors.reduce((acc: bigint, d: any) => acc + BigInt(String(d.shares ?? 0)), 0n);
        const totalShares = paramsBI > 0n ? paramsBI : sumBI;

        const normDepositors = respDepositors.map((d: any) => {
          const shares = BigInt(String(d.shares ?? 0));
          const pct = totalShares > 0n ? Number(shares) / Number(totalShares) : 0;
          return {
            id: `${(d.address || '').toLowerCase()}-${String(selectedVaultStrategy).toLowerCase()}`,
            account: { id: (d.address || '').toLowerCase() },
            shares,
            depositCount: Number(d.deposits ?? d.depositCount ?? 0),
            withdrawCount: Number(d.withdraws ?? d.withdrawCount ?? 0),
            lastDepositAt: Number(d.lastDeposit ?? d.lastDepositAt ?? 0),
            lastWithdrawAt: Number(d.lastWithdraw ?? d.lastWithdrawAt ?? 0),
            sharePct: pct,
          };
        });
        setDepositors(normDepositors);

        const toRow = (e: any) => ({
          id: e.id ?? `${String(e.hash || e.txHash || '')}-${String(e.timestamp || 0)}`,
          account: { id: (e.user || e.account?.id || '').toLowerCase() },
          shares: BigInt(String(e.shares ?? 0)),
          amountQuote: BigInt(String(e.quoteAmount ?? e.amountQuote ?? 0)),
          amountBase: BigInt(String(e.baseAmount ?? e.amountBase ?? 0)),
          txHash: e.hash ?? e.txHash ?? '',
          timestamp: Number(e.timestamp ?? 0),
        });
        setDepositHistory((Array.isArray(data?.depositHistory) ? data.depositHistory : []).map(toRow));
        setWithdrawHistory((Array.isArray(data?.withdrawHistory) ? data.withdrawHistory : []).map(toRow));

        setSeriesLoading(true);
        setSeriesError(null);
        try {
          const tvlArr = Array.isArray(data?.history?.series?.tvl) ? data.history.series.tvl : [];
          const pnlArr = Array.isArray(data?.history?.series?.pnl) ? data.history.series.pnl : [];

          const vSeries = tvlArr.map((p: any) => {
            const ts = Number(p.timestamp || 0);
            return { ts, name: fmtLabel(ts, vaultStrategyTimeRange), value: Number(p.tvlUsd || 0) };
          });

          const pSeries = pnlArr.map((p: any) => {
            const ts = Number(p.timestamp || 0);
            return { ts, name: fmtLabel(ts, vaultStrategyTimeRange), value: Number(p.pnlUsd || 0) };
          });

          if (!cancelled) {
            setValueSeries(vSeries);
            setPnlSeries(pSeries);
          }
        } catch (e: any) {
          if (!cancelled) setSeriesError(e?.message || 'failed to load history');
        } finally {
          if (!cancelled) setSeriesLoading(false);
        }

        const baseVault = (vaultList || []).find(
          (v: any) => (v?.address || '').toLowerCase() === String(selectedVaultStrategy).toLowerCase()
        );

        const latestQuote = BigInt(String(data?.latestBalance?.quoteBalance ?? 0));
        const latestBase = BigInt(String(data?.latestBalance?.baseBalance ?? 0));
        const userSharesBI = BigInt(String(data?.userBalance?.shares ?? 0));

        if (baseVault) {
          const nextSelected = {
            ...baseVault,
            totalShares: totalShares,
            quoteBalance: latestQuote,
            baseBalance: latestBase,
            userShares: userSharesBI,
            locked: !!data?.status?.locked,
            closed: !!data?.status?.closed,
            tvlUsd: data?.tvlUsd ?? data?.latestBalance?.usdValue,
            userQuoteBalance: BigInt(String(data?.userBalance?.quoteBalance ?? 0)),
            userBaseBalance: BigInt(String(data?.userBalance?.baseBalance ?? 0)),
            desc: data?.vault?.description ?? baseVault?.desc,
            social1: data?.vault?.socials?.social1 ?? baseVault?.social1,
            social2: data?.vault?.socials?.social2 ?? baseVault?.social2,
            quoteDecimals: Number(data?.vault?.decimals?.quoteDecimals ?? baseVault?.quoteDecimals ?? 18),
            baseDecimals: Number(data?.vault?.decimals?.baseDecimals ?? baseVault?.baseDecimals ?? 18),
          } as any;

          setselectedVault(nextSelected);

          setVaultList((prev: any[]) =>
            (Array.isArray(prev) ? prev : []).map((v: any) =>
              String(v?.address || '').toLowerCase() === String(baseVault.address).toLowerCase()
                ? {
                  ...v,
                  totalShares: totalShares,
                  quoteBalance: latestQuote,
                  baseBalance: latestBase,
                  userShares: userSharesBI,
                  locked: !!data?.status?.locked,
                  closed: !!data?.status?.closed,
                  tvlUsd: nextSelected.tvlUsd,
                  quoteDecimals: nextSelected.quoteDecimals,
                  baseDecimals: nextSelected.baseDecimals,
                }
                : v
            )
          );
        } else {
          if (!cancelled) setselectedVault(null);
        }

        const VAULT_DETAIL_QUERY = `
          query VaultDetail($acct: ID!) {
            account(id: $acct) {
              id
              openOrderMap {
                shards(first: 1000) {
                  batches(first: 1000) {
                    orders(first: 1000) {
                      id
                      market { id baseAsset quoteAsset }
                      isBuy
                      price
                      originalSize
                      remainingSize
                      status
                      placedAt
                      updatedAt
                      txHash
                    }
                  }
                }
              }
              orderMap {
                shards(first: 1000) {
                  batches(first: 1000) {
                    orders(first: 1000) {
                      id
                      market { id baseAsset quoteAsset }
                      isBuy
                      price
                      originalSize
                      remainingSize
                      status
                      placedAt
                      updatedAt
                      txHash
                    }
                  }
                }
              }
              tradeMap {
                shards(first: 1000) {
                  batches(first: 1000) {
                    trades(first: 1000) {
                      id
                      market { id baseAsset quoteAsset }
                      amountIn
                      amountOut
                      startPrice
                      endPrice
                      isBuy
                      timestamp
                      tx
                    }
                  }
                }
              }
            }
          }
        `;

        const sgData = await fetchSubgraph(SUBGRAPH_URL, VAULT_DETAIL_QUERY, { acct: selectedVaultStrategy });
        if (cancelled) return;

        const acct = sgData?.account ?? null;
        const flattenMap = (mapObj: any, key: 'orders' | 'trades') =>
          (mapObj?.shards ?? []).flatMap((s: any) => s?.batches ?? []).flatMap((b: any) => b?.[key] ?? []);
        setOpenOrders(flattenMap(acct?.openOrderMap, 'orders') || []);
        setAllOrders(flattenMap(acct?.orderMap, 'orders') || []);
      } catch (e) {
        console.error('vault detail fetch failed:', e);
        if (cancelled) return;
        setDepositors([]);
        setDepositHistory([]);
        setWithdrawHistory([]);
        setOpenOrders([]);
        setAllOrders([]);
      } finally {
        inFlight = false;
      }
    };

    run();
    const intervalId = window.setInterval(run, 5000);

    return () => {
      cancelled = true;
      window.clearInterval(intervalId);
    };
  }, [selectedVaultStrategy, !['earn'].includes(location.pathname.split('/')[1])]);

  useEffect(() => {
    if (!['earn'].includes(location.pathname.split('/')[1])) return;
    if (!selectedVaultStrategy) return;

    let cancelled = false;

    const mapRangeToTf = (r: '1D' | '1W' | '1M' | 'All') => {
      if (r === '1D') return 1;
      if (r === '1W') return 2;
      if (r === '1M') return 3;
      return 4;
    };

    const fmtLabel = (ts: number, r: '1D' | '1W' | '1M' | 'All') => {
      const d = new Date(ts * 1000);
      const pad = (n: number) => n.toString().padStart(2, '0');
      if (r === '1D') return `${pad(d.getHours())}:${pad(d.getMinutes())}`;
      if (r === '1W' || r === '1M') return `${pad(d.getMonth() + 1)}/${pad(d.getDate())}`;
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
    };

    const run = async () => {
      setSeriesLoading(true);
      setSeriesError(null);
      try {
        const tf = mapRangeToTf(vaultStrategyTimeRange);
        const url = `https://api.crystal.exchange/vaults/${selectedVaultStrategy}/${tf}`;
        const res = await fetch(url, { method: 'GET' });
        if (!res.ok) throw new Error(`backend ${res.status}`);
        const j = await res.json();

        const tvlArr = Array.isArray(j?.history?.series?.tvl) ? j.history.series.tvl : [];
        const pnlArr = Array.isArray(j?.history?.series?.pnl) ? j.history.series.pnl : [];

        const vSeries = tvlArr.map((p: any) => {
          const ts = Number(p.timestamp || 0);
          return {
            ts,
            name: fmtLabel(ts, vaultStrategyTimeRange),
            value: Number(p.tvlUsd || 0),
          };
        });

        const pSeries = pnlArr.map((p: any) => {
          const ts = Number(p.timestamp || 0);
          return {
            ts,
            name: fmtLabel(ts, vaultStrategyTimeRange),
            value: Number(p.pnlUsd || 0),
          };
        });

        if (!cancelled) {
          setValueSeries(vSeries);
          setPnlSeries(pSeries);
        }
      } catch (e: any) {
        if (!cancelled) setSeriesError(e?.message || 'failed to load history');
      } finally {
        if (!cancelled) setSeriesLoading(false);
      }
    };

    run();
    return () => { cancelled = true; };
  }, [vaultStrategyTimeRange, selectedVaultStrategy, !['earn'].includes(location.pathname.split('/')[1])]);

  const findMarketForToken = useCallback((tokenAddress: string) => {
    for (const [marketKey, marketData] of Object.entries(markets)) {
      if (marketData.baseAddress === tokenAddress || marketData.quoteAddress === tokenAddress) {
        return { marketKey, marketData, trades: tradesByMarket[marketKey] };
      }
    }
    return null;
  }, [markets, tradesByMarket]);

  const saveSubWallets = useCallback((wallets: { address: string; privateKey: string; }[] | ((prevState: { address: string; privateKey: string; }[]) => { address: string; privateKey: string; }[])) => {
    setSubWallets((prevWallets) => {
      const newWallets = typeof wallets === 'function' ? wallets(prevWallets) : wallets;

      const deduplicated = deduplicateWallets(newWallets);
      return deduplicated;
    });
  }, []);

  // on market select
  const onMarketSelect = useCallback((market: { quoteAddress: any; baseAddress: any; }) => {
    if (!['swap', 'limit', 'send', 'scale', 'market'].includes(location.pathname.slice(1))) {
      if (simpleView) {
        navigate('/swap');
      }
      else {
        navigate('/market');
      }
    }

    setTokenIn(market.quoteAddress);
    setTokenOut(market.baseAddress);
    setswitched(false);
    setInputString('');
    setsendInputString('');
    setamountIn(BigInt(0));
    setSliderPercent(0);
    setamountOutSwap(BigInt(0));
    setoutputString('');
    setlimitChase(true);
    setScaleStart(BigInt(0))
    setScaleEnd(BigInt(0))
    setScaleStartString('')
    setScaleEndString('')
    const slider = document.querySelector('.balance-amount-slider');
    const popup = document.querySelector('.slider-percentage-popup');
    if (slider && popup) {
      (popup as HTMLElement).style.left = `${15 / 2}px`;
    }
  }, [location.pathname, simpleView]);

  // update limit amount
  const updateLimitAmount = useCallback((price: number, priceFactor: number, displayPriceFactor?: number) => {
    let newPrice = BigInt(Math.round(Number(price.toFixed(Math.floor(Math.log10(displayPriceFactor ? displayPriceFactor : priceFactor)))) * priceFactor));
    setlimitPrice(newPrice);
    setlimitPriceString(price.toFixed(Math.floor(Math.log10(displayPriceFactor ? Math.min(displayPriceFactor, priceFactor) : priceFactor))));
    setlimitChase(false);
    if (location.pathname.slice(1) == 'limit') {
      if (switched) {
        debouncedSetAmount(
          newPrice !== BigInt(0) && amountOutSwap !== BigInt(0)
            ? tokenIn === activeMarket?.baseAddress
              ? (amountOutSwap *
                (activeMarket.scaleFactor || BigInt(1))) /
              newPrice
              : (amountOutSwap * newPrice) /
              (activeMarket.scaleFactor || BigInt(1))
            : BigInt(0),
        );
        setInputString(
          (newPrice !== BigInt(0) && amountOutSwap !== BigInt(0)
            ? tokenIn === activeMarket?.baseAddress
              ? customRound(
                Number(
                  (amountOutSwap *
                    (activeMarket.scaleFactor || BigInt(1))) /
                  newPrice,
                ) /
                10 ** Number(tokendict[tokenIn].decimals),
                3,
              )
              : customRound(
                Number(
                  (amountOutSwap * newPrice) /
                  (activeMarket.scaleFactor || BigInt(1)),
                ) /
                10 ** Number(tokendict[tokenIn].decimals),
                3,
              )
            : ''
          ).toString(),
        );
        const percentage =
          tokenBalances[tokenIn] === BigInt(0)
            ? 0
            : Math.min(
              100,
              Math.floor(
                Number(
                  (newPrice !== BigInt(0) &&
                    amountOutSwap !== BigInt(0)
                    ? tokenIn === activeMarket?.baseAddress
                      ? (amountOutSwap *
                        (activeMarket.scaleFactor ||
                          BigInt(1))) /
                      newPrice
                      : (amountOutSwap * newPrice) /
                      (activeMarket.scaleFactor || BigInt(1))
                    : BigInt(0)) * BigInt(100) / tokenBalances[tokenIn]
                )
              ),
            );
        setSliderPercent(percentage);
        const slider = document.querySelector(
          '.balance-amount-slider',
        );
        const popup = document.querySelector(
          '.slider-percentage-popup',
        );
        if (slider && popup) {
          const rect = slider.getBoundingClientRect();
          (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
            }px`;
        }
      }
      else {
        setamountOutSwap(
          newPrice != BigInt(0) && amountIn != BigInt(0)
            ? tokenIn === activeMarket?.baseAddress
              ? (amountIn * newPrice) / (activeMarket.scaleFactor || BigInt(1))
              : (amountIn * (activeMarket.scaleFactor || BigInt(1))) / newPrice
            : BigInt(0),
        );
        setoutputString(
          (newPrice != BigInt(0) && amountIn != BigInt(0)
            ? tokenIn === activeMarket?.baseAddress
              ? customRound(
                Number(
                  (amountIn * newPrice) / (activeMarket.scaleFactor || BigInt(1)),
                ) /
                10 ** Number(tokendict[tokenOut].decimals),
                3,
              )
              : customRound(
                Number(
                  (amountIn * (activeMarket.scaleFactor || BigInt(1))) / newPrice,
                ) /
                10 ** Number(tokendict[tokenOut].decimals),
                3,
              )
            : ''
          ).toString(),
        );
      }
    }
  }, [activeMarket?.scaleFactor,
  activeMarket?.baseAddress,
    switched,
    amountIn,
    amountOutSwap,
    tokenIn,
    tokenOut,
  tokenBalances[tokenIn],
    tokendict,
  location.pathname.slice(1),
  ]);

  // set amount for a token
  const debouncedSetAmount = (amount: bigint) => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    setStateIsLoading(true);
    debounceTimerRef.current = setTimeout(() => {
      setamountIn(amount);
      debounceTimerRef.current = null;
    }, 300);
  };

  // set amountout for a token
  const debouncedSetAmountOut = (amount: bigint) => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    setStateIsLoading(true);
    debounceTimerRef.current = setTimeout(() => {
      setamountOutSwap(amount);
      debounceTimerRef.current = null;
    }, 300);
  };

  // data loop, reuse to have every single rpc call method in this loop
  /* const { data: rpcQueryData, isLoading, dataUpdatedAt, refetch } = useQuery({
    queryKey: [
      'crystal_rpc_reads',
      switched,
      String(amountOutSwap),
      String(amountIn),
      tokenIn,
      tokenOut,
      address,
      activeMarketKey,
      isStake,
    ],
    queryFn: async () => {
      let gasEstimateCall: any = null;
      let gasEstimate: bigint = 0n;

      if (address && (amountIn || amountOutSwap)) {
        try {
          const deadline = BigInt(Math.floor(Date.now() / 1000) + 900);

          const path = activeMarket.path[0] === tokenIn ? activeMarket.path : [...activeMarket.path].reverse();

          let tx: any = null;

          if (tokenIn === eth && tokenOut === weth) {
            tx = wrapeth(amountIn, weth);
          } else if (tokenIn === weth && tokenOut === eth) {
            tx = unwrapeth(amountIn, weth);
          } else if (tokenIn === eth && tokendict[tokenOut]?.lst && isStake) {
            tx = stake(tokenOut, address, amountIn);
          } else if (orderType === 1 || multihop) {
            const slippageAmount = !switched
              ? (amountOutSwap * slippage + 5000n) / 10000n
              : (amountIn * 10000n + slippage / 2n) / slippage;

            if (tokenIn === eth && tokenOut !== eth) {
              tx = !switched
                ? swapExactETHForTokens(router, amountIn, slippageAmount, path, address, deadline, usedRefAddress)
                : swapETHForExactTokens(router, amountOutSwap, slippageAmount, path, address, deadline, usedRefAddress);
            } else if (tokenIn !== eth && tokenOut === eth) {
              tx = !switched
                ? swapExactTokensForETH(router, amountIn, slippageAmount, path, address, deadline, usedRefAddress)
                : swapTokensForExactETH(router, amountOutSwap, slippageAmount, path, address, deadline, usedRefAddress);
            } else {
              tx = !switched
                ? swapExactTokensForTokens(router, amountIn, slippageAmount, path, address, deadline, usedRefAddress)
                : swapTokensForExactTokens(router, amountOutSwap, slippageAmount, path, address, deadline, usedRefAddress);
            }
          } else {
            const amount = !switched ? amountIn : amountOutSwap;
            const limitPrice = tokenIn === activeMarket.quoteAddress
              ? (lowestAsk * 10000n + slippage / 2n) / slippage
              : (highestBid * slippage + 5000n) / 10000n;

            tx = _swap(
              router,
              tokenIn === eth
                ? (!switched ? amountIn : BigInt((amountIn * 10000n + slippage / 2n) / slippage))
                : BigInt(0),
              activeMarket.path[0] === tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
              activeMarket.path[0] === tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
              !switched,
              BigInt(0),
              amount,
              limitPrice,
              deadline,
              usedRefAddress
            );
          }

          if (tx) {
            gasEstimateCall = {
              jsonrpc: '2.0',
              id: 1,
              method: 'eth_estimateGas',
              params: [{
                from: address as `0x${string}`,
                to: tx.target,
                data: tx.data,
                value: tx.value ? `0x${tx.value.toString(16)}` : '0x'
              }]
            };
          }
        } catch (e) {
          gasEstimateCall = null;
        }
      }

      const mainGroup: any = [
        {
          disabled: (switched ? amountOutSwap : amountIn) > maxUint256,
          to: router,
          abi: CrystalRouterAbi,
          functionName: switched ? 'getAmountsIn' : 'getAmountsOut',
          args: [
            switched ? amountOutSwap : amountIn,
            activeMarket.path[0] === tokenIn ? activeMarket.path : [...activeMarket.path].reverse()
          ]
        },
        {
          disabled: !address,
          to: tokenIn === eth ? weth : tokenIn,
          abi: TokenAbi,
          functionName: 'allowance',
          args: [
            address as `0x${string}`,
            router
          ]
        },
        {
          disabled: !address,
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'batchBalanceOf',
          args: [
            address as `0x${string}`,
            [...Object.values(tokendict).map((t: any) => t.address), ...Object.values(markets).map((t: any) => t.address)]
          ]
        },
        {
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'getMarketData',
          args: [router, activeMarket?.address, BigInt(1000000), BigInt(1), BigInt(100)]
        },
        {
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'getPrices',
          args: [
            router, Array.from(new Set(Object.values(markets).map((m: any) => m.address)))
          ]
        },
        ...(isStake && tokenIn == eth && (tokendict[tokenOut] as any)?.lst
          ? [{
            to: tokenOut,
            abi: tokenOut === '0xe1d2439b75fb9746E7Bc6cB777Ae10AA7f7ef9c5' ? sMonAbi : shMonadAbi,
            functionName: switched ? 'convertToAssets' : 'convertToShares',
            args: [switched ? amountOutSwap : amountIn]
          }]
          : [])
      ];

      const refGroup: any = [
        {
          to: settings.chainConfig[activechain].referralManager,
          abi: CrystalReferralAbi as any,
          functionName: 'getRefInfo',
          args: [address ?? '0x0000000000000000000000000000000000000000'],
        },
        ...Array.from(
          new Set(
            Object.values(tokendict).map(
              (market) => market.address as `0x${string}`
            )
          )
        ).flatMap((marketAddress: any) => ({
          to: router as `0x${string}`,
          abi: CrystalRouterAbi,
          functionName: 'claimableRewards',
          args: [marketAddress, address ?? '0x0000000000000000000000000000000000000000'],
        })),
      ]

      const oneCTDepositGroup: any = [
        {
          disabled: !scaAddress,
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'batchBalanceOf',
          args: [
            scaAddress as `0x${string}`,
            Object.values(tokendict).map((t: any) => t.address)
          ]
        },
      ]

      const groups: any = {
        mainGroup
      };

      if (Date.now() - lastRefGroupFetch.current >= 9500) {
        lastRefGroupFetch.current = Date.now();
        groups.refGroup = refGroup;
      }

      if (popup == 25) {
        groups.oneCTDepositGroup = oneCTDepositGroup;
      }

      const callData: any = []
      const callMapping: any = []

      const groupResults: any = {};
      Object.keys(groups).forEach(groupKey => {
        groupResults[groupKey] = [];
      });

      Object.entries(groups).forEach(([groupKey, group]: [string, any]) => {
        group.forEach((call: any, callIndex: number) => {
          if (!call.disabled) {
            try {
              callData.push({
                target: call.to || call.address,
                callData: encodeFunctionData({
                  abi: call.abi,
                  functionName: call.functionName,
                  args: call.args
                })
              });

              callMapping.push({
                groupKey,
                callIndex
              });
            } catch (e: any) {
              while (groupResults[groupKey].length < callIndex) {
                groupResults[groupKey].push(null);
              }
              groupResults[groupKey][callIndex] = { error: e.message, result: undefined, status: "failure" };
            }
          }
          else {
            while (groupResults[groupKey].length < callIndex) {
              groupResults[groupKey].push(null);
            }
            groupResults[groupKey][callIndex] = { error: "param missing", result: undefined, status: "failure" };
          }
        });
      });

      const multicallData: any = encodeFunctionData({
        abi: [{
          inputs: [
            { name: 'requireSuccess', type: 'bool' },
            {
              components: [
                { name: 'target', type: 'address' },
                { name: 'callData', type: 'bytes' }
              ], name: 'calls', type: 'tuple[]'
            }
          ],
          name: 'tryBlockAndAggregate',
          outputs: [
            { name: 'blockNumber', type: 'uint256' },
            { name: 'blockHash', type: 'bytes32' },
            {
              components: [
                { name: 'success', type: 'bool' },
                { name: 'returnData', type: 'bytes' }
              ], name: 'returnData', type: 'tuple[]'
            }
          ],
          stateMutability: 'view',
          type: 'function'
        }],
        functionName: 'tryBlockAndAggregate',
        args: [false, callData]
      })

      const response: any = await fetch(HTTP_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify([{
          jsonrpc: '2.0',
          id: 1,
          method: 'eth_call',
          params: [{ to: settings.chainConfig[activechain].multicall3, data: multicallData }, 'latest']
        }, ...(gasEstimateCall ? [gasEstimateCall] : [])])
      })

      const json: any = await response.json()


      const returnData: any = decodeFunctionResult({
        abi: [{
          inputs: [
            { name: 'requireSuccess', type: 'bool' },
            {
              components: [
                { name: 'target', type: 'address' },
                { name: 'callData', type: 'bytes' }
              ], name: 'calls', type: 'tuple[]'
            }
          ],
          name: 'tryBlockAndAggregate',
          outputs: [
            { name: 'blockNumber', type: 'uint256' },
            { name: 'blockHash', type: 'bytes32' },
            {
              components: [
                { name: 'success', type: 'bool' },
                { name: 'returnData', type: 'bytes' }
              ], name: 'returnData', type: 'tuple[]'
            }
          ],
          stateMutability: 'view',
          type: 'function'
        }],
        functionName: 'tryBlockAndAggregate',
        data: json[0].result
      })

      blockNumber.current = returnData?.[0]
      returnData?.[2]?.forEach((data: any, responseIndex: number) => {
        const { groupKey, callIndex } = callMapping[responseIndex] || {};
        if (groupKey === undefined) return;
        const originalCall = groups[groupKey][callIndex];
        while (groupResults[groupKey].length <= callIndex) {
          groupResults[groupKey].push(null);
        }
        if (data?.success == true) {
          try {
            const decodedResult = decodeFunctionResult({
              abi: originalCall.abi,
              functionName: originalCall.functionName,
              data: data?.returnData
            });
            groupResults[groupKey][callIndex] = { result: decodedResult, status: "success" };
          } catch (e: any) {
            groupResults[groupKey][callIndex] = { error: e.message, result: undefined, status: "failure" };
          }
        }
        else {
          groupResults[groupKey][callIndex] = { error: 'call reverted', result: undefined, status: "failure" };
        }
      });

      if (json?.[1]?.result) {
        gasEstimate = BigInt(json[1].result)
      }

      return { readContractData: groupResults, gasEstimate: gasEstimate }
    },
    enabled: !!activeMarket && !!tokendict && !!markets,
    refetchInterval: ['market', 'limit', 'send', 'scale'].includes(location.pathname.slice(1)) && !simpleView ? 300 : 5000,
    gcTime: 0,
  }) */

  const handleImportWallets = (walletsText: string, addToSingleGroup: boolean) => {
    try {
      const lines = walletsText.trim().split('\n');
      const newWallets = lines.map((line, index) => {
        const parts = line.split(',');
        return {
          id: `wallet-${Date.now()}-${index}-${Math.random().toString(36).substr(2, 9)}`,
          address: parts[0]?.trim() || '',
          name: parts[1]?.trim() || `Imported Wallet ${index + 1}`,
          emoji: parts[2]?.trim() || '',
          balance: 0,
          lastActiveAt: null,
          createdAt: new Date().toISOString()
        };
      }).filter(w => w.address);

      setTrackedWallets(prev => [...prev, ...newWallets]);
      setpopup(0);
    } catch (e) {
      console.error('Failed to parse wallets:', e);
    }
  };

  const handleSearchKeyDown = (
    e: ReactKeyboardEvent<HTMLInputElement>,
  ): void => {
    if (e.key === 'Enter' && sortedMarkets.length > 0) {
      e.preventDefault();
      const selectedMarket = sortedMarkets[selectedIndex];
      setSearchQuery('');
      setpopup(0);
      onMarketSelect(selectedMarket)
    } else if (e.key === 'Escape') {
      setSearchQuery('');
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      const newIndex = selectedIndex < sortedMarkets.length - 1 ? selectedIndex + 1 : selectedIndex;
      setSelectedIndex(newIndex);

      const selectedItem = document.getElementById(`search-market-item-${newIndex}`);
      if (selectedItem) {
        selectedItem.scrollIntoView({ block: 'nearest', behavior: 'auto' });
      }

      refocusSearchInput();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      const newIndex = selectedIndex > 0 ? selectedIndex - 1 : 0;
      setSelectedIndex(newIndex);

      const selectedItem = document.getElementById(`search-market-item-${newIndex}`);
      if (selectedItem) {
        selectedItem.scrollIntoView({ block: 'nearest', behavior: 'auto' });
      }

      refocusSearchInput();
    }
  };

  useEffect(() => {
    if (showSendDropdown) {
      const handleClick = (event: MouseEvent) => {
        if (sendButtonRef.current && sendButtonRef.current.contains(event.target as Node)) {
          return;
        }

        if (sendDropdownRef.current && !sendDropdownRef.current.contains(event.target as Node)) {
          setShowSendDropdown(false);
        }
      };

      document.addEventListener('mousedown', handleClick);
      return () => {
        document.removeEventListener('mousedown', handleClick);
      };
    }
  }, [showSendDropdown])

  useEffect(() => {
    setSelectedIndex(0);
    setSelectedTokenIndex(0);
  }, [searchQuery, tokenString, popup]);

  const refocusSearchInput = () => {
    if (searchInputRef.current) {
      searchInputRef.current.focus();
    }
  };

  const handleSort = (field: 'volume' | 'price' | 'change' | 'favorites') => {
    if (sortField === field) {
      if (sortDirection === 'asc') {
        setSortDirection('desc');
      } else if (sortDirection === 'desc') {
        setSortField(null);
        setSortDirection(undefined);
      }
    } else {
      setSortField(field);
      setSortDirection('asc');
    }
  };

  const setScaleOutput = (
    amountIn: number,
    startPrice: number,
    endPrice: number,
    numOrders: number,
    skew: number,
  ) => {
    const prices: number[] = Array.from({ length: numOrders }, (_, i) =>
      Math.round(
        startPrice +
        ((endPrice - startPrice) * i) /
        (numOrders - 1)
      )
    );

    let orderSizes: number[];
    let factorSum: number;

    if (tokenIn == activeMarket.quoteAddress) {
      factorSum = prices.reduce(
        (sum, price, i) => sum + price * (1 + ((skew - 1) * i) / (numOrders - 1)),
        0
      );
      const x = (Number(amountIn) * Number(activeMarket.scaleFactor)) / factorSum;
      orderSizes = Array.from({ length: numOrders }, (_, i) =>
        Math.round(x * (1 + ((skew - 1) * i) / (numOrders - 1)))
      );
    } else {
      factorSum = Array.from({ length: numOrders }).reduce(
        (sum: number, _, i) => sum + (1 + ((skew - 1) * i) / (numOrders - 1)),
        0
      );
      const x = Number(amountIn) / factorSum;
      orderSizes = Array.from({ length: numOrders }, (_, i) =>
        Math.round(x * (1 + ((skew - 1) * i) / (numOrders - 1)))
      );
    }
    const orderUsdValues: number[] = prices.map((price, i) =>
      Math.round((price * orderSizes[i]) / Number(activeMarket.scaleFactor)))
    let totalUsdValue = orderUsdValues.reduce((sum, val) => sum + val, 0);
    let totalTokenValue = orderSizes.reduce((sum, val) => sum + val, 0);
    if (tokenIn == activeMarket.quoteAddress) {
      if (totalUsdValue != amountIn) {
        orderUsdValues[orderUsdValues.length - 1] += (amountIn - totalUsdValue)
        totalUsdValue = amountIn
      }
      setamountOutSwap(BigInt(totalTokenValue))
      setoutputString(
        totalTokenValue
          /
          10 ** Number(tokendict[tokenOut].decimals)
          ? customRound(
            totalTokenValue
            /
            10 ** Number(tokendict[tokenOut].decimals),
            3,
          ) : ''
      );
    }
    else {
      if (totalTokenValue != amountIn) {
        orderSizes[orderSizes.length - 1] += (amountIn - totalTokenValue)
        totalTokenValue = amountIn
      }
      setamountOutSwap(BigInt(totalUsdValue))
      setoutputString(
        totalUsdValue
          /
          10 ** Number(tokendict[tokenOut].decimals)
          ? customRound(
            totalUsdValue
            /
            10 ** Number(tokendict[tokenOut].decimals),
            3,
          ) : ''
      );
    }
  }

  const calculateScaleOutput = (
    amountIn: bigint,
    startPrice: number,
    endPrice: number,
    numOrders: number,
    skew: number,
  ) => {
    const prices: number[] = Array.from({ length: numOrders }, (_, i) => {
      const p = startPrice + ((endPrice - startPrice) * i) / (numOrders - 1)
      return activeMarket.marketType !== 0 ? Math.round(Number(p.toPrecision(5))) : Math.round(p)
    })

    let orderSizes: bigint[];
    let factorSum: number;

    if (tokenIn == activeMarket.quoteAddress) {
      factorSum = prices.reduce(
        (sum, price, i) => sum + price * (1 + ((skew - 1) * i) / (numOrders - 1)),
        0
      );
      const x = (Number(amountIn) * Number(activeMarket.scaleFactor)) / factorSum;
      orderSizes = Array.from({ length: numOrders }, (_, i) =>
        BigInt(Math.round(x * (1 + ((skew - 1) * i) / (numOrders - 1))))
      );
    } else {
      factorSum = Array.from({ length: numOrders }).reduce(
        (sum: number, _, i) => sum + (1 + ((skew - 1) * i) / (numOrders - 1)),
        0
      );
      const x = Number(amountIn) / factorSum;
      orderSizes = Array.from({ length: numOrders }, (_, i) =>
        BigInt(Math.round(x * (1 + ((skew - 1) * i) / (numOrders - 1))))
      );
    }
    const orderUsdValues: bigint[] = prices.map((price, i) =>
      ((BigInt(price) * orderSizes[i]) / activeMarket.scaleFactor))
    let totalUsdValue = orderUsdValues.reduce((sum, val) => sum + val, BigInt(0));
    let totalTokenValue = orderSizes.reduce((sum, val) => sum + val, BigInt(0));
    if (tokenIn == activeMarket.quoteAddress) {
      if (totalUsdValue != amountIn) {
        orderUsdValues[orderUsdValues.length - 1] += amountIn - totalUsdValue
      }
    }
    else {
      if (totalTokenValue != amountIn) {
        orderSizes[orderSizes.length - 1] += amountIn - totalTokenValue
      }
    }
    return prices.map((price, i) => [price, orderSizes[i], orderUsdValues[i]])
  }

  const calculateScaleInput = (
    desiredOutput: bigint,
    startPrice: number,
    endPrice: number,
    numOrders: number,
    skew: number,
  ): bigint => {
    if (numOrders <= 1) {
      return 0n;
    }

    const prices: bigint[] = Array.from({ length: numOrders }, (_, i) =>
      BigInt(Math.round(startPrice + ((endPrice - startPrice) * i) / (numOrders - 1)))
    );

    const weights: bigint[] = Array.from({ length: numOrders }, (_, i) =>
      BigInt(Math.round(1e8 + ((skew - 1) * i * 1e8) / (numOrders - 1)))
    );

    const S_p = prices.reduce((sum, price, i) => sum + (price * weights[i]), 0n);
    const S_w = weights.reduce((sum, w) => sum + w, 0n);

    if (S_p === 0n || S_w === 0n || desiredOutput === 0n) {
      return 0n;
    }

    let requiredInput: bigint;

    if (tokenIn === activeMarket.quoteAddress) {
      requiredInput = (desiredOutput * S_p) / (BigInt(activeMarket.scaleFactor) * S_w);
    } else {
      requiredInput = (desiredOutput * BigInt(activeMarket.scaleFactor) * S_w) / S_p;
    }

    return requiredInput;
  };

  // oc resizers
  const handleVertMouseDown = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();

    initialMousePosRef.current = e.clientY;
    initialHeightRef.current = orderCenterHeight;

    setIsVertDragging(true);
    document.body.style.cursor = 'row-resize';
    document.body.style.userSelect = 'none';
  };

  // order processing
  const processOrders = (buyOrdersRaw: any[], sellOrdersRaw: any[]) => {
    const mapOrdersBuy = (orderData: bigint[]) => {
      const orders = orderData
        .filter(
          (order) =>
            (order & BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF')) !==
            BigInt(0),
        )
        .map((order) => {
          const price =
            Number(order >> BigInt(128)) / Number(activeMarket.priceFactor);
          const size =
            Number(order & BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF')) /
            (10 ** Number(activeMarket.quoteDecimals));
          return {
            price,
            size,
            totalSize: 0,
          };
        });

      let runningTotal = 0;
      return orders.map((order) => {
        runningTotal += order.size;
        return {
          ...order,
          totalSize: runningTotal,
        };
      });
    };

    const mapOrdersSell = (orderData: bigint[]) => {
      const orders = orderData
        .filter(
          (order) =>
            (order & BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF')) !==
            BigInt(0),
        )
        .map((order) => {
          const price =
            Number(order >> BigInt(128)) / Number(activeMarket.priceFactor);
          const size =
            Number(order & BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF')) * Number(order >> BigInt(128)) /
            Number(activeMarket.scaleFactor) / (10 ** Number(activeMarket.quoteDecimals));
          return {
            price,
            size,
            totalSize: 0,
          };
        });

      let runningTotal = 0;
      return orders.map((order) => {
        runningTotal += order.size;
        return {
          ...order,
          totalSize: runningTotal,
        };
      });
    };

    return {
      buyOrders: mapOrdersBuy(buyOrdersRaw as bigint[]),
      sellOrders: mapOrdersSell(sellOrdersRaw as bigint[]),
    };
  }

  const processOrdersForDisplay = (
    orders: Order[],
    amountsQuote: string,
    latestPrice: number,
    userOrders: any[],
    isBuyOrderList: boolean
  ) => {
    const priceDecimals = Math.max(
      0,
      Math.floor(Math.log10(Number(activeMarket.priceFactor))) +
      Math.floor(
        Math.log10(Number(latestPrice))
      ) + (Math.log10(Number(latestPrice)) < -1 ? Math.log10(Number(latestPrice)) + 1 : 0)
    )

    const priceMap: { [key: string]: boolean } = {};
    if (userOrders && userOrders.length > 0 && orders && orders.length > 0) {
      const filteredUserOrders = userOrders.filter((order) => {
        return isBuyOrderList == (Number(order[3]) === 1) && String(order[4]) === ((activeMarket.baseAsset == wethticker ? ethticker : activeMarket.baseAsset) + (activeMarket.quoteAsset == wethticker ? ethticker : activeMarket.quoteAsset));
      });

      filteredUserOrders.forEach((order) => {
        priceMap[Number(order[0]).toFixed(
          Math.floor(Math.log10(Number(activeMarket.priceFactor)))
        )] = true;
      });
    }

    const roundedOrders = orders.map((order) => {
      const roundedSize =
        amountsQuote === 'Base'
          ? Number((order.size / order.price).toFixed(priceDecimals))
          : Number(order.size.toFixed(2));
      const roundedTotalSize =
        amountsQuote === 'Base'
          ? Number((order.totalSize / order.price).toFixed(priceDecimals))
          : Number(order.totalSize.toFixed(2));

      const userPrice = priceMap[Number(order.price * Number(activeMarket.priceFactor)).toFixed(
        Math.floor(Math.log10(Number(activeMarket.priceFactor)))
      )] == true;

      return {
        price: Number(Number(order.price).toFixed(
          Math.floor(Math.log10(Number(activeMarket.priceFactor)))
        )),
        size: roundedSize,
        totalSize: roundedTotalSize,
        shouldFlash: false,
        userPrice,
      };
    });

    const defaultOrders = orders.map((order) => ({
      price: Number(
        Number(order.price).toFixed(
          Math.floor(Math.log10(Number(activeMarket.priceFactor))),
        ),
      ),
      size: Number(Number(order.size).toFixed(2)),
      totalSize: Number(Number(order.totalSize).toFixed(2)),
    }));

    return { roundedOrders, defaultOrders };
  };

  function v2ToOrderbook(
    reserve1Raw: number | bigint,
    reserve2Raw: number | bigint,
    baseDecimals: number,
    quoteDecimals: number,
    amountsQuote: string
  ): { bids: Order[]; asks: Order[] } {
    if (reserve1Raw == 0 || reserve2Raw == 0) return { bids: [], asks: [] };

    const oneMinusFee = 1 - (25 / 10000);
    const x0 = Number(reserve1Raw);
    const y0 = Number(reserve2Raw);
    const k = x0 * y0;
    const pMid = y0 / x0;

    const xFromP = (p: number) => Math.sqrt(k * p);

    const bids: any[] = [];
    const asks: any[] = [];
    const MAX_LEVELS_PER_SIDE = 2000;

    {
      let tHere = pMid;
      for (let i = 0; i < MAX_LEVELS_PER_SIDE; i++) {
        const tLow = tHere * oneMinusFee;
        if (tLow <= 0) break;
        const xLow = xFromP(tLow);
        const xHi = xFromP(tHere);
        const baseIn = Math.max(0, (xHi - xLow));
        if (baseIn <= 0) break;

        const effectivePrice = tLow * (10 ** baseDecimals) / (10 ** quoteDecimals);
        const size = amountsQuote == 'Quote' ? baseIn / (10 ** quoteDecimals) : baseIn / effectivePrice / (10 ** baseDecimals)
        bids.push({
          price: effectivePrice,
          size: size,
          shouldFlash: false,
          userPrice: false,
        });

        tHere = tLow;
      }
    }

    {
      let tHere = pMid;
      for (let i = 0; i < MAX_LEVELS_PER_SIDE; i++) {
        const tHigh = tHere / oneMinusFee;
        const xA = xFromP(tHere);
        const xN = xFromP(tHigh);
        const baseOut = Math.max(0, (xN - xA));
        if (baseOut <= 0) break;

        const effectivePrice = tHigh * (10 ** baseDecimals) / (10 ** quoteDecimals);
        const size = amountsQuote == 'Quote' ? baseOut / (10 ** quoteDecimals) : baseOut / effectivePrice / (10 ** baseDecimals)
        asks.push({
          price: effectivePrice,
          size: size,
          shouldFlash: false,
          userPrice: false,
        });

        tHere = tHigh;
      }
    }

    return { bids, asks };
  }

  // tokenexplorer
  function reducer(state: State, action: Action): State {
    switch (action.type) {
      case 'INIT': {
        const buckets: State['tokensByStatus'] = {
          new: [],
          graduating: [],
          graduated: [],
        };
        action.tokens.forEach((t) => buckets[t.status].push(t));
        buckets.graduating = buckets.graduating
          .slice()
          .sort((a, b) => (b.bondingPercentage ?? 0) - (a.bondingPercentage ?? 0));

        return { ...state, tokensByStatus: buckets };
      }

      case 'ADD_MARKET': {
        const { token } = action;
        const list = [token, ...state.tokensByStatus[token?.status as Token['status']]].slice(
          0,
          30,
        );
        return {
          ...state,
          tokensByStatus: { ...state.tokensByStatus, [token?.status as Token['status']]: list },
        };
      }

      case 'ADD_METADATA': {
        const buckets = { ...state.tokensByStatus };
        (Object.keys(buckets) as Token['status'][]).forEach((s) => {
          buckets[s] = buckets[s].flatMap((t: any) => {
            if (t.id.toLowerCase() !== action.id.toLowerCase()) return [t];
            const {
              twitterHandle = '',
              discordHandle = '',
              telegramHandle = '',
              website = '',
              image = '',
              description = '',
              ...rest
            } = action.updates;

            return [{
              ...t,
              twitterHandle: t.twitterHandle || twitterHandle,
              discordHandle: t.discordHandle || twitterHandle,
              telegramHandle: t.telegramHandle || telegramHandle,
              website: t.website || website,
              image: t.image || image,
              description: t.description || description,
            }];
          });
        });

        return { ...state, tokensByStatus: buckets };
      }

      case 'UPDATE_MARKET': {
        const buckets = { ...state.tokensByStatus };
        let movedToken: any;
        let status: string = '';
        (Object.keys(buckets) as Token['status'][]).forEach((s) => {
          buckets[s] = buckets[s].flatMap((t: any) => {
            if (t.id.toLowerCase() !== action.id.toLowerCase()) return [t];

            const {
              volumeDelta = 0,
              buyTransactions = 0,
              sellTransactions = 0,
              otherVolumeDelta = 0,
              trader = '',
              ...rest
            } = action.updates;
            status = s == 'graduated'
              ? 'graduated'
              : (rest?.price ?? t?.price) * TOTAL_SUPPLY > (t.source == 'crystal' ? 12500 : 1290000)
                ? 'graduating'
                : 'new'
            const bondingPercentage = status == 'graduated' ? 1 : (rest?.price ?? t?.price) * TOTAL_SUPPLY / (t.source == 'crystal' ? 12500 : 1290000);

            if (status != s) {
              movedToken = {
                ...t,
                ...rest,
                volume24h: t.volume24h + volumeDelta,
                buyTransactions: t.buyTransactions + buyTransactions,
                sellTransactions: t.sellTransactions + sellTransactions,
                status: status,
                bondingPercentage: bondingPercentage,
                devHolding: trader == t.dev ? (buyTransactions > 0 ? t.devHolding + (otherVolumeDelta / TOTAL_SUPPLY) : t.devHolding - (otherVolumeDelta / TOTAL_SUPPLY)) : t.devHolding,
              }
              return []
            }
            return [{
              ...t,
              ...rest,
              volume24h: t.volume24h + volumeDelta,
              buyTransactions: t.buyTransactions + buyTransactions,
              sellTransactions: t.sellTransactions + sellTransactions,
              status: status,
              bondingPercentage: bondingPercentage,
              devHolding: trader == t.dev ? (buyTransactions > 0 ? t.devHolding + (otherVolumeDelta / TOTAL_SUPPLY) : t.devHolding - (otherVolumeDelta / TOTAL_SUPPLY)) : t.devHolding,
            }];
          });
        });

        if (movedToken?.status) {
          buckets[movedToken?.status as Token['status']].unshift(movedToken);
          if (buckets.new) {
            buckets.new = [...buckets.new].sort(
              (a, b) => (b.created ?? 0) - (a.created ?? 0)
            );
          }
        }

        if (status == 'graduating') {
          if (buckets.graduating) {
            buckets.graduating = [...buckets.graduating].sort(
              (a, b) => (b.bondingPercentage ?? 0) - (a.bondingPercentage ?? 0)
            );
          }
        }

        return { ...state, tokensByStatus: buckets };
      }

      case 'GRADUATE_MARKET': {
        const buckets = { ...state.tokensByStatus };
        let movedToken: any;
        (Object.keys(buckets) as Token['status'][]).forEach((s) => {
          buckets[s] = buckets[s].flatMap((t: any) => {
            if (t.id.toLowerCase() !== action.id.toLowerCase()) return [t];

            const status = 'graduated'

            if (status != s) {
              movedToken = {
                ...t,
                status: status,
                market: action.market ? action.market : t.market,
                progress: 100,
              }
              return []
            }
            return [{
              ...t,
              status: status,
              progress: 100,
            }];
          });
        });
        if (movedToken?.status) {
          buckets[movedToken?.status as Token['status']].unshift(movedToken);
        }
        return { ...state, tokensByStatus: buckets };
      }

      case 'HIDE_TOKEN': {
        const h = new Set(state.hidden).add(action.id);
        localStorage.setItem('explorer-hidden-tokens', JSON.stringify(Array.from(h)));
        return { ...state, hidden: h };
      }

      case 'SHOW_TOKEN': {
        const h = new Set(state.hidden);
        h.delete(action.id);
        localStorage.setItem('explorer-hidden-tokens', JSON.stringify(Array.from(h)));
        return { ...state, hidden: h };
      }
      case 'SET_LOADING': {
        const l = new Set(state.loading);
        const key = action.buttonType ? `${action.id}-${action.buttonType}` : action.id;
        action.loading ? l.add(key) : l.delete(key);
        return { ...state, loading: l };
      }

      default:
        return state;
    }
  }

  const addMarket = useCallback(
    async (log: any) => {
      const { args } = decodeEventLog({
        abi: CrystalRouterAbi,
        data: log.data,
        topics: log.topics,
      }) as any;

      const socials = [args.social1, args.social2, args.social3, args.social4].map((s) =>
        s ? (/^https?:\/\//.test(s) ? s : `https://${s}`) : s,
      );
      const twitter = socials.find(
        (s) =>
          s?.startsWith('https://x.com') ||
          s?.startsWith('https://twitter.com'),
      );
      if (twitter) {
        socials.splice(socials.indexOf(twitter), 1);
      }
      const telegram = socials.find((s) => s?.startsWith('https://t.me'));
      if (telegram) {
        socials.splice(socials.indexOf(telegram), 1);
      }
      const discord = socials.find(
        (s) =>
          s?.startsWith('https://discord.gg') ||
          s?.startsWith('https://discord.com'),
      );
      if (discord) {
        socials.splice(socials.indexOf(discord), 1);
      }
      const website = socials[0];

      const token: Partial<Token> = {
        ...defaultMetrics,
        id: args.token,
        name: args.name,
        symbol: args.symbol,
        image: args.metadataCID || '',
        description: args.description ?? '',
        twitterHandle: twitter ?? '',
        website: website ?? '',
        status: 'new',
        marketCap: defaultMetrics.price * TOTAL_SUPPLY,
        created: Math.floor(Date.now() / 1000),
        volumeDelta: 0,
        telegramHandle: telegram ?? '',
        discordHandle: discord ?? '',
        dev: args.creator,
        launchedTokens: 0,
        graduatedTokens: 0,
        bondingPercentage: 0,
      };

      if (token.status && pausedColumnRef.current == token.status) {
        pausedTokenQueueRef.current[token.status].push(args.token);
      }
      dispatch({ type: 'ADD_MARKET', token });
      if (alertSettingsRef.current.soundAlertsEnabled) {
        try {
          const audio = new Audio(alertSettingsRef.current.sounds.newPairs);
          audio.volume = alertSettingsRef.current.volume / 100;
          audio.play().catch(console.error);
        } catch (error) {
          console.error('Failed to play new pairs sound:', error);
        }
      }
    },
    [],
  );

  const updateMarket = useCallback(
    (log: any) => {
      if (log.topics?.[0] !== CRYSTAL_EVENTS.LaunchpadTrade) return;

      const tokenAddr = `0x${log.topics[1].slice(26)}`.toLowerCase();

      const hex = log.data.replace(/^0x/, '');
      const words: string[] = [];
      for (let i = 0; i < hex.length; i += 64) words.push(hex.slice(i, i + 64));

      const isBuy = BigInt('0x' + words[0]);
      const amountIn = BigInt('0x' + words[1]);
      const amountOut = BigInt('0x' + words[2]);
      const virtualNativeReserve = BigInt('0x' + words[3]);
      const virtualTokenReserve = BigInt('0x' + words[4]);
      const price =
        virtualTokenReserve == 0n
          ? 0
          : Number(virtualNativeReserve) / Number(virtualTokenReserve);

      dispatch({
        type: 'UPDATE_MARKET',
        id: tokenAddr,
        updates: {
          price: price,
          marketCap: price * TOTAL_SUPPLY,
          buyTransactions: isBuy ? 1 : 0,
          sellTransactions: isBuy ? 0 : 1,
          volumeDelta:
            isBuy > 0 ? Number(amountIn) / 1e18 : Number(amountOut) / 1e18,
          otherVolumeDelta: isBuy == 0n ? Number(amountIn) / 1e18 : Number(amountOut) / 1e18,
        },
      });
    },
    [],
  );

  const normalizeTrade = useCallback((trade: any, wallets: any[]): any => {
    const tradeAccountAddr = (trade.account?.id || trade.caller || '').toLowerCase();
    const connectedAddr = address?.toLowerCase();

    const trackedWallet = wallets.find(
      w => w.address.toLowerCase() === tradeAccountAddr
    );

    const isConnectedWallet = connectedAddr && tradeAccountAddr === connectedAddr;

    let walletName: string;
    let emoji: string;

    if (trackedWallet) {
      walletName = trackedWallet.name;
      emoji = trackedWallet.emoji || '';
    } else if (isConnectedWallet) {
      walletName = 'You';
      emoji = '';
    } else {
      walletName = `${tradeAccountAddr.slice(0, 6)}...${tradeAccountAddr.slice(-4)}`;
      emoji = '';
    }

    const isBuy = !!trade.isBuy;
    const nativeAmount = Number(isBuy ? trade.amountIn : trade.amountOut);
    const price = Number(trade.price);

    const TOTAL_SUPPLY = 1e9;
    const marketCap = price * TOTAL_SUPPLY;

    const timestamp = trade.timestamp
      ? (trade.timestamp > 1e12 ? Number(trade.timestamp) / 1000 : Number(trade.timestamp))
      : Math.floor(Date.now() / 1000);
    const now = Math.floor(Date.now() / 1000);
    const secondsAgo = Math.max(0, now - timestamp);
    let timeAgo = 'now';
    if (secondsAgo < 60) timeAgo = `${Math.floor(secondsAgo)}s`;
    else if (secondsAgo < 3600) timeAgo = `${Math.floor(secondsAgo / 60)}m`;
    else if (secondsAgo < 86400) timeAgo = `${Math.floor(secondsAgo / 3600)}h`;
    else timeAgo = `${Math.floor(secondsAgo / 86400)}d`;

    const tokenAddress = (
      trade.tokenAddress ||
      trade.token?.address ||
      trade.token?.id ||
      undefined
    )?.toLowerCase();

    const tokenSymbol = trade.symbol || trade.token?.symbol || 'TKN';
    const tokenName = trade.name || trade.token?.name || trade.token?.symbol || tokenSymbol;
    const tokenIcon = trade.tokenIcon || trade.token?.imageUrl || trade.icon || undefined;

    return {
      id: trade.id || `${trade.transactionHash || trade.txHash}-${Date.now()}`,
      walletName: walletName,
      walletAddress: tradeAccountAddr,
      emoji: emoji,
      token: tokenSymbol,
      tokenName: tokenName,
      tokenAddress: tokenAddress,
      tokenIcon: tokenIcon,
      amount: nativeAmount,
      price: price,
      marketCap: marketCap,
      time: timeAgo,
      timestamp: timestamp * 1000,
      txHash: trade.transaction?.id || trade.transactionHash || trade.id,
      type: isBuy ? 'buy' : 'sell',
      createdAt: new Date(timestamp * 1000).toISOString(),
    };
  }, [address]);

  const ALERT_DEFAULTS: AlertSettings = {
    soundAlertsEnabled: true,
    volume: 100,
    sounds: {
      newPairs: stepaudio,
      pairMigrating: stepaudio,
      migrated: stepaudio,
    },
  };

  const [alertSettings, setAlertSettings] = useState<AlertSettings>(() => {
    const saved = localStorage.getItem('explorer-alert-settings');
    if (!saved) return ALERT_DEFAULTS;
    try {
      const parsed = JSON.parse(saved);
      return {
        ...ALERT_DEFAULTS,
        ...parsed,
        sounds: { ...ALERT_DEFAULTS.sounds, ...(parsed?.sounds || {}) },
      };
    } catch {
      return ALERT_DEFAULTS;
    }
  });

  const initialState: State = {
    tokensByStatus: { new: [], graduating: [], graduated: [] },
    hidden: (() => {
      const s = localStorage.getItem('explorer-hidden-tokens');
      if (!s) return new Set();
      try { return new Set(JSON.parse(s)); }
      catch { return new Set(); }
    })(),
    loading: new Set(),
  };

  const [{ tokensByStatus, hidden, loading: teLoading }, dispatch] = useReducer(
    reducer,
    initialState,
  );

  const tokensByStatusRef = useRef(tokensByStatus);

  useEffect(() => {
    tokensByStatusRef.current = tokensByStatus;
  }, [tokensByStatus]);

  const tokenAddress = (matchPath('/meme/:tokenAddress', location.pathname) || matchPath('/board/:tokenAddress', location.pathname))?.params?.tokenAddress?.toLowerCase();
  const [wsReady, setWsReady] = useState(false);
  const explorerWsRef = useRef<WebSocket | null>(null);
  const explorerPingIntervalRef = useRef<any>(null);
  const explorerReconnectIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const pausedColumnRef = useRef<any>(null);
  const pausedTokenQueueRef = useRef<{
    new: string[];
    graduating: string[];
    graduated: string[];
  }>({
    new: [],
    graduating: [],
    graduated: []
  });
  const alertSettingsRef = useRef<any>(alertSettings);
  const memeRealtimeCallbackRef = useRef<any>({});
  const trackedWalletsRef = useRef<any>(
    (() => {
      try {
        return JSON.parse(localStorage.getItem('tracked_wallets_data') || '[]');
      } catch {
        return [];
      }
    })()
  );
  const trackedWalletTradesRef = useRef<any>([]);
  const [trackedWalletTrades, setTrackedWalletTrades] = useState<any[]>([]);
  const wsPendingLogsRef = useRef(new Map());
  const transferPendingLogsRef = useRef(new Map());
  const [memeTrades, setMemeTrades] = useState<LaunchpadTrade[]>([]);
  const [memeHolders, setMemeHolders] = useState<Holder[]>([]);
  const [memeTopTraders, setMemeTopTraders] = useState<Holder[]>([]);
  const [memePositions, setMemePositions] = useState<any[]>([]);
  const [memeDevTokens, setMemeDevTokens] = useState<any[]>([]);
  const [memeTop10HoldingPct, setMemeTop10HoldingPct] = useState(0);
  const [memeUserStats, setMemeUserStats] = useState({
    balance: 0, amountBought: 0, amountSold: 0, valueBought: 0, valueSold: 0, valueNet: 0,
  });
  const [memeSimilarTokens, setMemeSimilarTokens] = useState<any[]>([]);
  const [memeSelectedInterval, setMemeSelectedInterval] = useState(
    () => localStorage.getItem('meme_chart_timeframe') || '15s',
  );
  const memeSelectedIntervalRef = useRef<string>(memeSelectedInterval);
  const uniSubRef = useRef<string>('');
  const transferSubRef = useRef<string>('');
  const processedTradeIds = useRef<Set<string>>(new Set());

  const [page, _setPage] = useState(0);
  const [currentTokenData, setCurrentTokenData] = useState({
    address: '',
    symbol: '',
    name: '',
    price: 0,
  });
  const memeRef = useRef<any>();
  const memeDevTokenIdsRef = useRef<Set<string>>(new Set());
  const [trackedAddresses, setTrackedAddresses] = useState<string[]>([]);
  const [isLoadingTrades, setIsLoadingTrades] = useState(false);

  // reload if throttled
  useEffect(() => {
    if (!['board', 'spectra', 'meme', 'launchpad', 'trackers'].includes(location.pathname.split('/')[1])) return;
    let last = Date.now();
    let throttled = false;

    const check = setInterval(() => {
      const now = Date.now();
      if (!throttled && now - last > 10000) throttled = true;
      last = now;
    }, 1000);

    const onFocus = () => {
      if (throttled) window.location.reload();
    };

    window.addEventListener('focus', onFocus);

    return () => {
      clearInterval(check);
      window.removeEventListener('focus', onFocus);
    };
  }, [!['board', 'spectra', 'meme', 'launchpad', 'trackers'].includes(location.pathname.split('/')[1])]);

  useEffect(() => {
    const updateTrackedWalletsRef = () => {
      try {
        const stored = localStorage.getItem('tracked_wallets_data');
        if (stored) {
          const wallets = JSON.parse(stored);
          trackedWalletsRef.current = wallets;
        } else {
          trackedWalletsRef.current = [];
        }
      } catch (error) {
        trackedWalletsRef.current = [];
      }
    };

    updateTrackedWalletsRef();

    const handleWalletsUpdate = (e: CustomEvent) => {
      if (e.detail?.wallets) {
        trackedWalletsRef.current = e.detail.wallets;
      }
    };

    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === 'tracked_wallets_data') {
        updateTrackedWalletsRef();
      }
    };

    window.addEventListener('wallets-updated', handleWalletsUpdate as EventListener);
    window.addEventListener('storage', handleStorageChange);

    return () => {
      window.removeEventListener('wallets-updated', handleWalletsUpdate as EventListener);
      window.removeEventListener('storage', handleStorageChange);
    };
  }, []);
  
  useEffect(() => {
    let cancelled = false;

    (async () => {
      try {
        const res = await fetch('https://api.crystal.exchange/tokens', {
          method: 'GET',
          headers: { 'content-type': 'application/json' },
        });

        if (!res.ok) {
          throw new Error(`launchpad api returned ${res.status}`);
        }

        const json = await res.json();

        const buckets = [
          { list: json.recent_created ?? [], status: 'new' as Token['status'] },
          { list: json.recent_approaching ?? [], status: 'graduating' as Token['status'] },
          { list: json.recent_graduated ?? [], status: 'graduated' as Token['status'] },
        ];

        const tokens: Token[] = [];

        for (const bucket of buckets) {
          for (const m of bucket.list) {
            const marketCapNativeRaw = Number(m.marketcap_native_raw ?? 0);
            const price = marketCapNativeRaw / TOTAL_SUPPLY || defaultMetrics.price;

            let createdTimestamp = Number(m.created_ts ?? 0);
            if (createdTimestamp > 1e10) {
              createdTimestamp = Math.floor(createdTimestamp / 1000);
            }

            const volume = Number(m.native_volume / 1e18);
            const holdersRaw = Number(m.holders ?? 0);
            const devHoldingRaw = Number(m.developer_holding ?? 0);
            const top10HoldingRaw = Number(m.top10_holding ?? 0);
            const launchpad = m.source === 1 ? 'nadfun' : 'crystal';
            const socialsRaw = [m.social1, m.social2, m.social3, m.social4];
            const socials = socialsRaw.map((s) =>
              s ? (/^https?:\/\//.test(s) ? s : `https://${s}`) : s,
            );

            const twitter = socials.find(
              (s) =>
                s?.startsWith("https://x.com") ||
                s?.startsWith("https://twitter.com"),
            );
            if (twitter) socials.splice(socials.indexOf(twitter), 1);

            const telegram = socials.find((s) => s?.startsWith("https://t.me"));
            if (telegram) socials.splice(socials.indexOf(telegram), 1);

            const discord = socials.find(
              (s) =>
                s?.startsWith("https://discord.gg") ||
                s?.startsWith("https://discord.com"),
            );
            if (discord) socials.splice(socials.indexOf(discord), 1);
            const website = socials[0];
            const token: Token = {
              ...defaultMetrics,
              id: (m.token as string).toLowerCase(),
              dev: (m.creator as string) || '',
              name: (m.name as string) || '',
              symbol: (m.symbol as string) || '',
              image: (m.metadata_cid as string) || '',
              description: '',
              status: bucket.status,
              created: createdTimestamp,
              price,
              marketCap: price * TOTAL_SUPPLY,
              buyTransactions: Number(m.tx?.buy ?? 0),
              sellTransactions: Number(m.tx?.sell ?? 0),
              volume24h: volume,
              volumeDelta: 0,
              launchedTokens: Number(m.developer_tokens_created ?? 0),
              graduatedTokens: Number(m.developer_tokens_graduated ?? 0),
              holders: holdersRaw,
              devHolding: devHoldingRaw / 1e27,
              top10Holding: top10HoldingRaw / 1e25,
              bondingPercentage: m.graduationPercentageBps,
              source: launchpad,
              market: m.market,
              discordHandle: discord ?? "",
              telegramHandle: telegram ?? "",
              twitterHandle: twitter ?? "",
              website: website ?? "",
              sniperHolding: Number(m.snipers?.holdingShare / 1e16),
            };

            tokens.push(token);
          }
        }

        dispatch({ type: 'INIT', tokens });
      } catch (err) {
        console.error('initial launchpad api fetch failed', err);
      } finally {
        if (!cancelled) setIsTokenExplorerLoading(false);
        setstateloading(false)
        setaddressinfoloading(false)
      }
    })();

    const connectWebSocket = () => {
      if (cancelled) return;
      explorerWsRef.current = new WebSocket(WS_URL);

      explorerWsRef.current.onopen = () => {
        setWsReady(true);
        const subscriptionMessages = [
          // JSON.stringify({
          //   jsonrpc: '2.0',
          //   id: 'sub1',
          //   method: 'eth_subscribe',
          //   params: [
          //     'monadLogs',
          //     {
          //       address: settings.chainConfig[activechain].router,
          //       topics: [[CRYSTAL_EVENTS.Trade, CRYSTAL_EVENTS.MarketCreated, CRYSTAL_EVENTS.LaunchpadTrade, CRYSTAL_EVENTS.Graduation]],
          //     },
          //   ],
          // }),
          JSON.stringify({
            jsonrpc: '2.0',
            id: 'sub_nadfun',
            method: 'eth_subscribe',
            params: [
              'monadLogs',
              {
                address: nadFunBondingCurve,
                topics: [
                  [
                    NAD_FUN_EVENTS.CurveCreate,
                    NAD_FUN_EVENTS.CurveBuy,
                    NAD_FUN_EVENTS.CurveSell,
                    NAD_FUN_EVENTS.CurveSync,
                    NAD_FUN_EVENTS.CurveGraduate,
                  ]
                ],
              },
            ],
          }),
        ];

        explorerPingIntervalRef.current = setInterval(() => {
          if (explorerWsRef.current?.readyState === WebSocket.OPEN) {
            explorerWsRef.current.send(JSON.stringify({
              jsonrpc: '2.0',
              id: 'ping',
              method: 'eth_syncing'
            }));
          }
        }, 15000);

        subscriptionMessages.forEach((message) => {
          explorerWsRef.current?.send(message);
        });
      };

      explorerWsRef.current.onmessage = ({ data }) => {
        try {
          const msg = JSON.parse(data);
          if (msg.method !== 'eth_subscription' || !msg.params?.result) {
            if (msg?.id == "sub_uni_update") {
              uniSubRef.current = msg?.result;
            }
            else if (msg?.id == "sub_transfers") {
              transferSubRef.current = msg?.result;
            }
            return;
          }
          const log = msg.params?.result;
          if (!log?.topics?.length || msg?.params?.result?.commitState != "Proposed") return;

          setProcessedLogs(prev => {
            let tempset = new Set(prev);
            const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
            if (tempset.has(logIdentifier)) {
              return tempset;
            }
            if (tempset.size >= 10000) {
              const first = tempset.values().next().value;
              if (first !== undefined) {
                tempset.delete(first);
              }
            }
            tempset.add(logIdentifier);
            const resolve = txReceiptResolvers.current.get(log['transactionHash']);
            if (resolve) {
              resolve();
              txReceiptResolvers.current.delete(log['transactionHash']);
            }

            if (log.topics?.[0] === CRYSTAL_EVENTS.Trade) {
              const marketAddr = `0x${log.topics[1].slice(26)}`.toLowerCase();
              const callerAddr = `0x${log.topics[2].slice(26)}`.toLowerCase();

              const mcfg = markets[addresstoMarket[marketAddr]];
              if (!mcfg || !mcfg.baseAddress) return tempset;
              const tokenAddrFromMarket = (mcfg.baseAddress || '').toLowerCase();

              const hex = log.data.startsWith('0x') ? log.data.slice(2) : log.data;
              const word = (i: number) => BigInt('0x' + hex.slice(i * 64, i * 64 + 64));

              const isBuy = word(0) !== 0n;
              const amountInWei = word(1);
              const amountOutWei = word(2);

              const amountIn = Number(amountInWei) / (10 ** Number(isBuy ? mcfg.quoteDecimals : mcfg.baseDecimals));
              const amountOut = Number(amountOutWei) / (10 ** Number(isBuy ? mcfg.baseDecimals : mcfg.quoteDecimals));

              const priceFactor = Number(mcfg.priceFactor || 1);

              const startPrice = priceFactor ? (Number(word(3)) / priceFactor) : 0
              const endPrice = priceFactor ? (Number(word(4)) / priceFactor) : 0

              dispatch({
                type: 'UPDATE_MARKET',
                id: tokenAddrFromMarket,
                updates: {
                  price: endPrice,
                  marketCap: endPrice * TOTAL_SUPPLY,
                  buyTransactions: isBuy ? 1 : 0,
                  sellTransactions: isBuy ? 0 : 1,
                  volumeDelta:
                    isBuy == true ? Number(amountIn) / 1e18 : Number(amountOut) / 1e18,
                  otherVolumeDelta: isBuy == false ? Number(amountIn) / 1e18 : Number(amountOut) / 1e18,
                  trader: callerAddr,
                },
              });

              if (trackedWalletsRef.current.some((w: any) => w.address.toLowerCase() === callerAddr.toLowerCase())) {
                const mcfg = markets[addresstoMarket[marketAddr]];

                const tradeId = `${log.transactionHash}-${log.logIndex}`;

                if (processedTradeIds.current.has(tradeId)) {
                  console.log('[TrackedTrade] Skipping duplicate orderbook trade:', tradeId);
                  return tempset;
                }

                const symbol = mcfg?.baseAsset || 'TKN';
                const name = mcfg?.baseAsset || 'Token';
                const icon = mcfg?.icon || undefined;

                const normalized = normalizeTrade({
                  caller: callerAddr,
                  id: tradeId,
                  isBuy: isBuy,
                  price: endPrice,
                  symbol: symbol,
                  name: name,
                  tokenAddress: tokenAddrFromMarket,
                  tokenIcon: icon,
                  amountIn,
                  amountOut,
                  timestamp: Date.now(),
                }, trackedWalletsRef.current);

                processedTradeIds.current.add(tradeId);

                setTrackedWalletTrades(prev => {
                  if (prev.some(t => t.id === tradeId)) {
                    return prev;
                  }

                  const updated = [normalized, ...prev];
                  const kept = updated.slice(0, 50);
                  const keptIds = new Set(kept.map(t => t.id));

                  processedTradeIds.current = new Set(
                    Array.from(processedTradeIds.current).filter(id => keptIds.has(id))
                  );

                  return kept;
                });

                setTrackedWalletTrades(prev =>
                  prev.map(t =>
                    t.id === tradeId
                      ? { ...t, token: mcfg?.baseAsset, tokenName: mcfg?.baseAsset, tokenIcon: mcfg?.icon }
                      : t
                  )
                );
              }
              if (!memeRef.current.id || tokenAddrFromMarket !== memeRef.current.id.toLowerCase()) return tempset;
              setTokenData(p => ({
                ...p,
                price: endPrice,
                marketCap: endPrice * TOTAL_SUPPLY,
                change24h: p?.mini?.[0]?.open ? ((endPrice * 1e9 - p?.mini?.[0]?.open) / (p?.mini?.[0]?.open) * 100) : p?.change24h,
                buyTransactions: (p?.buyTransactions || 0) + (isBuy ? 1 : 0),
                sellTransactions: (p?.sellTransactions || 0) + (isBuy ? 0 : 1),
                volume24h: (p?.volume24h || 0) + (isBuy ? amountIn : amountOut),
              }));

              setMemeTrades(prev => [
                {
                  id: `${log.transactionHash}-${log.logIndex}`,
                  timestamp: Math.floor(Date.now() / 1000),
                  isBuy,
                  price: endPrice,
                  nativeAmount: isBuy ? amountIn : amountOut,
                  tokenAmount: isBuy ? amountOut : amountIn,
                  caller: callerAddr,
                },
                ...prev.slice(0, 99),
              ]);

              setChartData((prev: any) => {
                if (!prev || !Array.isArray(prev) || prev.length < 2) return prev;
                const [bars, key, flag] = prev;
                const sel = key?.split('MON').pop() || ''
                const RESOLUTION_SECS: Record<string, number> = {
                  '1S': 1, '5S': 5, '15S': 15, '1m': 60, '5m': 300, '15m': 900,
                  '1h': 3600, '4h': 14400, '1d': 86400,
                };
                const resSecs = RESOLUTION_SECS[sel] ?? 60;
                const now = Date.now();
                const bucket = Math.floor(now / (resSecs * 1000)) * resSecs * 1000;
                const volNative = isBuy ? amountIn : amountOut;
                const updated = [...bars];
                const last = updated[updated.length - 1];
                if (!last || last.time < bucket) {
                  const prevClose = last?.close ?? startPrice;
                  const open = prevClose;
                  const high = Math.max(open, Math.max(startPrice, endPrice));
                  const low = Math.min(open, Math.min(startPrice, endPrice));
                  const newBar = {
                    time: bucket,
                    open,
                    high,
                    low,
                    close: endPrice,
                    volume: volNative || 0,
                  };
                  updated.push(newBar);
                  const cb =
                    memeRealtimeCallbackRef.current?.[key];
                  if (cb) cb(newBar);
                } else {
                  const cur = { ...last };
                  cur.high = Math.max(cur.high, Math.max(startPrice, endPrice));
                  cur.low = Math.min(cur.low, Math.min(startPrice, endPrice));
                  cur.close = endPrice;
                  cur.volume = (cur.volume || 0) + (volNative || 0);
                  updated[updated.length - 1] = cur;
                  const cb =
                    memeRealtimeCallbackRef.current?.[key];
                  if (cb) cb(cur);
                }
                if (updated.length > 1200) updated.splice(0, updated.length - 1200);
                return [updated, key, flag];
              });

              setMemeHolders(prev => {
                const arr = prev.slice();
                let idx = arr.findIndex(r => r.address.toLowerCase() === callerAddr);
                if (idx == -1) {
                  const fresh: Holder = {
                    address: callerAddr,
                    balance: 0,
                    amountBought: 0,
                    amountSold: 0,
                    valueBought: 0,
                    valueSold: 0,
                    valueNet: 0,
                    tokenNet: 0,
                  };
                  arr.push(fresh);
                  idx = arr.length - 1;
                }
                const h = { ...arr[idx] };
                if (isBuy) {
                  h.amountBought = (h.amountBought || 0) + amountOut;
                  h.valueBought = (h.valueBought || 0) + amountIn;
                  h.balance = (h.balance || 0) + amountOut;
                } else {
                  h.amountSold = (h.amountSold || 0) + amountIn;
                  h.valueSold = (h.valueSold || 0) + amountOut;
                  h.balance = Math.max(0, (h.balance || 0) - amountIn);
                }
                arr[idx] = h;

                for (let i = 0; i < arr.length; i++) {
                  const hh = arr[i];
                  const realized = (hh.valueSold || 0) - (hh.valueBought || 0);
                  const bal = Math.max(0, hh.balance || 0);
                  arr[i] = { ...hh, valueNet: realized + bal * endPrice };
                }

                const topSum = arr
                  .map(hh => Math.max(0, hh.balance || 0))
                  .sort((a, b) => b - a)
                  .slice(0, 10)
                  .reduce((s, n) => s + n, 0);
                setMemeTop10HoldingPct((topSum / TOTAL_SUPPLY) * 100);
                return arr;
              });

              setMemeTopTraders(prev => {
                const copy = Array.isArray(prev) ? [...prev] : [];
                const key = callerAddr;
                let idx = copy.findIndex(r => r.address.toLowerCase() === key);

                if (idx === -1) {
                  const row: Holder = {
                    address: callerAddr,
                    balance: 0, tokenNet: 0, valueNet: 0,
                    amountBought: 0, amountSold: 0,
                    valueBought: 0, valueSold: 0,
                  };
                  copy.push(row);
                  idx = copy.length - 1;
                }

                const row = { ...copy[idx] };
                const curBal = Math.max(0, (row.balance ?? row.amountBought - row.amountSold) || 0);
                if (isBuy) {
                  row.amountBought = (row.amountBought || 0) + amountOut;
                  row.valueBought = (row.valueBought || 0) + amountIn;
                  row.balance = curBal + amountOut;
                } else {
                  row.amountSold = (row.amountSold || 0) + amountIn;
                  row.valueSold = (row.valueSold || 0) + amountOut;
                  row.balance = Math.max(0, curBal - amountIn);
                }
                row.tokenNet = (row.amountBought || 0) - (row.amountSold || 0);
                copy[idx] = row;

                for (let i = 0; i < copy.length; i++) {
                  const r = copy[i];
                  const bal = Math.max(0, (r.balance ?? r.amountBought - r.amountSold) || 0);
                  const realized = (r.valueSold || 0) - (r.valueBought || 0);
                  copy[i] = { ...r, valueNet: realized + bal * endPrice };
                }

                copy.sort((a, b) => b.valueNet - a.valueNet);
                if (copy.length > 300) {
                  const removed = copy.splice(300);
                }
                return copy;
              });

              setMemePositions(prev => {
                const copy = Array.isArray(prev) ? [...prev] : [];
                const allUserAddresses = [
                  (address || '').toLowerCase(),
                  ...(subWallets || []).map(w => (w.address || '').toLowerCase()),
                ];
                const isUserTrade = allUserAddresses.includes(callerAddr);
                if (!isUserTrade) return prev;
                let idx = copy.findIndex(r => r.tokenId.toLowerCase() === tokenAddrFromMarket);

                if (idx == -1 && isUserTrade) {
                  const newPos = {
                    tokenId: memeRef.current.id?.toLowerCase(),
                    symbol: memeRef.current?.symbol || '',
                    name: memeRef.current?.name || '',
                    imageUrl: memeRef.current?.image || '',
                    metadataCID: '',
                    boughtTokens: 0,
                    soldTokens: 0,
                    spentNative: 0,
                    receivedNative: 0,
                    remainingTokens: 0,
                    remainingPct: 0,
                    pnlNative: 0,
                    lastPrice: endPrice,
                  };
                  copy.push(newPos);
                  idx = copy.length - 1;
                }

                const pos = { ...copy[idx] };
                pos.lastPrice = endPrice;
                if (isUserTrade) {
                  if (isBuy) {
                    pos.boughtTokens += amountOut;
                    pos.spentNative += amountIn;
                    pos.remainingTokens = (pos.remainingTokens || 0) + amountOut;
                  } else {
                    pos.soldTokens += amountIn;
                    pos.receivedNative += amountOut;
                    pos.remainingTokens = Math.max(0, (pos.remainingTokens || 0) - amountIn);
                  }
                }
                pos.remainingPct = pos.boughtTokens > 0
                  ? (pos.remainingTokens / pos.boughtTokens) * 100
                  : 0;

                const balance = Math.max(0, pos.remainingTokens);
                const realized = (pos.receivedNative || 0) - (pos.spentNative || 0);
                const unrealized = balance * (pos.lastPrice || 0);
                pos.pnlNative = realized + unrealized;

                copy[idx] = pos;

                if (memeRef.current.id && tokenAddrFromMarket === memeRef.current.id.toLowerCase()) {
                  const markToMarket = balance * (pos.lastPrice || 0);
                  const totalPnL = (pos.receivedNative || 0) + markToMarket - (pos.spentNative || 0);
                  setMemeUserStats({
                    balance,
                    amountBought: pos.boughtTokens || 0,
                    amountSold: pos.soldTokens || 0,
                    valueBought: pos.spentNative || 0,
                    valueSold: pos.receivedNative || 0,
                    valueNet: totalPnL,
                  });
                }
                return copy;
              });

              if (memeDevTokenIdsRef.current.has(tokenAddrFromMarket)) {
                setMemeDevTokens(prev => {
                  const updated = prev.map(t => {
                    if ((t.id || '').toLowerCase() !== tokenAddrFromMarket) return t;
                    return { ...t, endPrice, marketCap: endPrice * TOTAL_SUPPLY, timestamp: Math.floor(Date.now() / 1000) };
                  });
                  memeDevTokenIdsRef.current = new Set(updated.map(t => (t.id || '').toLowerCase()));
                  return updated;
                });
              }

              return tempset;
            }
            else if (log.topics?.[0] === CRYSTAL_EVENTS.MarketCreated) {
              addMarket(log);
            }
            else if (log.topics?.[0] === CRYSTAL_EVENTS.LaunchpadTrade) {
              updateMarket(log);
              const tokenAddr = `0x${log.topics[1].slice(26)}`.toLowerCase();
              const callerAddr = `0x${log.topics[2].slice(26)}`.toLowerCase();

              const hex = log.data.startsWith('0x') ? log.data.slice(2) : log.data;
              const word = (i: number) => BigInt('0x' + hex.slice(i * 64, i * 64 + 64));

              const isBuy = word(0) !== 0n;
              const inputAmountWei = word(1);
              const outputAmountWei = word(2);
              const vNativeWei = word(3);
              const vTokenWei = word(4);

              const toNum = (x: bigint) => Number(x) / 1e18;
              const amountIn = toNum(inputAmountWei);
              const amountOut = toNum(outputAmountWei);
              const vNative = Number(vNativeWei);
              const vToken = Number(vTokenWei);

              const price = vToken === 0 ? 0 : vNative / vToken;

              if (trackedWalletsRef.current.some((w: any) => w.address.toLowerCase() === callerAddr.toLowerCase())) {
                const tradeId = `${log.transactionHash}-${log.logIndex}`;

                if (processedTradeIds.current.has(tradeId)) {
                  return tempset;
                }
                let tokenInfo: any = null;
                Object.values(tokensByStatusRef.current).forEach((tokens: any[]) => {
                  const found = tokens.find(t => t.id?.toLowerCase() === tokenAddr);
                  if (found) tokenInfo = found;
                });

                const symbol = tokenInfo?.symbol || 'TKN';
                const name = tokenInfo?.name || 'Token';
                const icon = tokenInfo?.image || undefined;

                const normalized = normalizeTrade({
                  caller: callerAddr,
                  id: tradeId,
                  isBuy: isBuy,
                  price: price,
                  symbol: symbol,
                  name: name,
                  tokenAddress: tokenAddr,
                  tokenIcon: icon,
                  amountIn: amountIn,
                  amountOut: amountOut,
                  timestamp: Date.now(),
                }, trackedWalletsRef.current);

                processedTradeIds.current.add(tradeId);

                setTrackedWalletTrades(prev => {
                  if (prev.some(t => t.id === tradeId)) {
                    return prev;
                  }

                  const updated = [normalized, ...prev];
                  const kept = updated.slice(0, 50);
                  const keptIds = new Set(kept.map(t => t.id));
                  processedTradeIds.current = new Set(
                    Array.from(processedTradeIds.current).filter(id => keptIds.has(id))
                  );

                  return kept;
                });

                setTrackedWalletTrades(prev =>
                  prev.map(t =>
                    t.id === tradeId
                      ? { ...t, token: symbol, tokenName: name, tokenIcon: icon }
                      : t
                  )
                );
              }


              if (memeRef.current.id && tokenAddr === memeRef.current.id.toLowerCase()) {
                setTokenData(p => ({
                  ...p,
                  price,
                  marketCap: price * TOTAL_SUPPLY,
                  change24h: p?.mini?.[0]?.open ? ((price * 1e9 - p?.mini?.[0]?.open) / (p?.mini?.[0]?.open) * 100) : p?.change24h,
                  buyTransactions: (p?.buyTransactions || 0) + (isBuy ? 1 : 0),
                  sellTransactions: (p?.sellTransactions || 0) + (isBuy ? 0 : 1),
                  volume24h: (p?.volume24h || 0) + (isBuy ? amountIn : amountOut),
                }));

                setMemeTrades(prev => [
                  {
                    id: `${log.transactionHash}-${log.logIndex}`,
                    timestamp: Math.floor(Date.now() / 1000),
                    isBuy,
                    price: price,
                    nativeAmount: isBuy ? amountIn : amountOut,
                    tokenAmount: isBuy ? amountOut : amountIn,
                    caller: callerAddr,
                  },
                  ...prev.slice(0, 99),
                ]);

                setChartData((prev: any) => {
                  if (!prev || !Array.isArray(prev) || prev.length < 2) return prev;
                  const [bars, key, flag] = prev;
                  const sel = key?.split('MON').pop() || ''
                  const RESOLUTION_SECS: Record<string, number> = {
                    '1S': 1, '5S': 5, '15S': 15, '1m': 60, '5m': 300, '15m': 900,
                    '1h': 3600, '4h': 14400, '1d': 86400,
                  };
                  const resSecs = RESOLUTION_SECS[sel] ?? 60;
                  const now = Date.now();
                  const bucket = Math.floor(now / (resSecs * 1000)) * resSecs * 1000;
                  const volNative = isBuy ? amountIn : amountOut;

                  const updated = [...bars];
                  const last = updated[updated.length - 1];

                  if (!last || last.time < bucket) {
                    const prevClose = last?.close ?? price;
                    const open = prevClose;
                    const high = Math.max(open, price);
                    const low = Math.min(open, price);
                    const newBar = {
                      time: bucket,
                      open,
                      high,
                      low,
                      close: price,
                      volume: volNative || 0,
                    };
                    updated.push(newBar);
                    const cb =
                      memeRealtimeCallbackRef.current?.[key];
                    if (cb) cb(newBar);
                  } else {
                    const cur = { ...last };
                    cur.high = Math.max(cur.high, price);
                    cur.low = Math.min(cur.low, price);
                    cur.close = price;
                    cur.volume = (cur.volume || 0) + (volNative || 0);
                    updated[updated.length - 1] = cur;
                    const cb =
                      memeRealtimeCallbackRef.current?.[key];
                    if (cb) cb(cur);
                  }
                  if (updated.length > 1200) updated.splice(0, updated.length - 1200);
                  return [updated, key, flag];
                });

                setMemeHolders(prev => {
                  const arr = prev.slice();
                  let idx = arr.findIndex(r => r.address.toLowerCase() === callerAddr);
                  if (idx == -1) {
                    const fresh: Holder = {
                      address: callerAddr,
                      balance: 0,
                      amountBought: 0,
                      amountSold: 0,
                      valueBought: 0,
                      valueSold: 0,
                      valueNet: 0,
                      tokenNet: 0,
                    };
                    arr.push(fresh);
                    idx = arr.length - 1;
                  }
                  const h = { ...arr[idx] };
                  if (isBuy) {
                    h.amountBought = (h.amountBought || 0) + amountOut;
                    h.valueBought = (h.valueBought || 0) + amountIn;
                    h.balance = (h.balance || 0) + amountOut;
                  } else {
                    h.amountSold = (h.amountSold || 0) + amountIn;
                    h.valueSold = (h.valueSold || 0) + amountOut;
                    h.balance = Math.max(0, (h.balance || 0) - amountIn);
                  }
                  arr[idx] = h;

                  for (let i = 0; i < arr.length; i++) {
                    const h = arr[i];
                    const realized = (h.valueSold || 0) - (h.valueBought || 0);
                    const bal = Math.max(0, h.balance || 0);
                    arr[i] = { ...h, valueNet: realized + bal * price };
                  }
                  const topSum = arr.map(h => Math.max(0, h.balance || 0)).sort((a, b) => b - a).slice(0, 10).reduce((s, n) => s + n, 0);
                  setMemeTop10HoldingPct((topSum / TOTAL_SUPPLY) * 100);
                  return arr;
                });

                setMemeTopTraders(prev => {
                  const copy = Array.isArray(prev) ? [...prev] : [];
                  const key = callerAddr;
                  let idx = copy.findIndex(r => r.address.toLowerCase() === key);

                  if (idx === -1) {
                    const row: Holder = {
                      address: callerAddr,
                      balance: 0, tokenNet: 0, valueNet: 0,
                      amountBought: 0, amountSold: 0,
                      valueBought: 0, valueSold: 0,
                    };
                    copy.push(row);
                    idx = copy.length - 1;
                  }

                  const row = { ...copy[idx] };
                  const curBal = Math.max(0, (row.balance ?? row.amountBought - row.amountSold) || 0);
                  if (isBuy) {
                    row.amountBought = (row.amountBought || 0) + amountOut;
                    row.valueBought = (row.valueBought || 0) + amountIn;
                    row.balance = curBal + amountOut;
                  } else {
                    row.amountSold = (row.amountSold || 0) + amountIn;
                    row.valueSold = (row.valueSold || 0) + amountOut;
                    row.balance = Math.max(0, curBal - amountIn);
                  }
                  row.tokenNet = (row.amountBought || 0) - (row.amountSold || 0);
                  copy[idx] = row;

                  for (let i = 0; i < copy.length; i++) {
                    const r = copy[i];
                    const bal = Math.max(0, (r.balance ?? r.amountBought - r.amountSold) || 0);
                    const realized = (r.valueSold || 0) - (r.valueBought || 0);
                    copy[i] = { ...r, valueNet: realized + bal * price };
                  }

                  copy.sort((a, b) => b.valueNet - a.valueNet);
                  if (copy.length > 300) {
                    const removed = copy.splice(300);
                  }
                  return copy;
                });

                setMemePositions(prev => {
                  const copy = Array.isArray(prev) ? [...prev] : [];
                  const allUserAddresses = [
                    (address || '').toLowerCase(),
                    ...(subWallets || []).map(w => (w.address || '').toLowerCase()),
                  ];
                  const isUserTrade = allUserAddresses.includes(callerAddr);
                  if (!isUserTrade) return prev;
                  let idx = copy.findIndex(r => r.tokenId.toLowerCase() === tokenAddr);

                  if (idx == -1 && isUserTrade) {
                    const newPos = {
                      tokenId: memeRef.current.id?.toLowerCase(),
                      symbol: memeRef.current?.symbol || '',
                      name: memeRef.current?.name || '',
                      imageUrl: memeRef.current?.image || '',
                      metadataCID: '',
                      boughtTokens: 0,
                      soldTokens: 0,
                      spentNative: 0,
                      receivedNative: 0,
                      remainingTokens: 0,
                      remainingPct: 0,
                      pnlNative: 0,
                      lastPrice: price,
                    };
                    copy.push(newPos);
                    idx = copy.length - 1;
                  }

                  const pos = { ...copy[idx] };
                  pos.lastPrice = price;
                  if (isUserTrade) {
                    if (isBuy) {
                      pos.boughtTokens += amountOut;
                      pos.spentNative += amountIn;
                      pos.remainingTokens += amountOut;
                    } else {
                      pos.soldTokens += amountIn;
                      pos.receivedNative += amountOut;
                      pos.remainingTokens = Math.max(0, pos.remainingTokens - amountIn);
                    }
                  }
                  pos.remainingPct = pos.boughtTokens > 0 ? (pos.remainingTokens / pos.boughtTokens) * 100 : 0;

                  const balance = Math.max(0, pos.remainingTokens);
                  const realized = (pos.receivedNative || 0) - (pos.spentNative || 0);
                  const unrealized = balance * (pos.lastPrice || 0);
                  pos.pnlNative = realized + unrealized;

                  copy[idx] = pos;

                  if (memeRef.current.id && tokenAddr === memeRef.current.id.toLowerCase()) {
                    const markToMarket = balance * (pos.lastPrice || 0);
                    const totalPnL = (pos.receivedNative || 0) + markToMarket - (pos.spentNative || 0);
                    setMemeUserStats({
                      balance,
                      amountBought: pos.boughtTokens || 0,
                      amountSold: pos.soldTokens || 0,
                      valueBought: pos.spentNative || 0,
                      valueSold: pos.receivedNative || 0,
                      valueNet: totalPnL,
                    });
                  }
                  return copy;
                });

                if (memeDevTokenIdsRef.current.has(tokenAddr)) {
                  setMemeDevTokens(prev => {
                    const updated = prev.map(t => {
                      if ((t.id || '').toLowerCase() !== tokenAddr) return t;
                      return { ...t, price, marketCap: price * TOTAL_SUPPLY, timestamp: Math.floor(Date.now() / 1000) };
                    });
                    memeDevTokenIdsRef.current = new Set(updated.map(t => (t.id || '').toLowerCase()));
                    return updated;
                  });
                }
              }
              return tempset;
            }
            else if (log.topics?.[0] == CRYSTAL_EVENTS.Graduation) {
              const tokenAddr = `0x${log.topics[1].slice(26)}`.toLowerCase();
              dispatch({
                type: 'GRADUATE_MARKET',
                id: tokenAddr,
              });
              if (!memeRef.current.id || tokenAddr !== memeRef.current.id.toLowerCase()) return tempset;
              setTokenData(p => ({
                ...p,
                status: 'graduated'
              }));
            }
            else if (log.topics?.[0] == CRYSTAL_EVENTS.Transfer) {
              while (transferPendingLogsRef.current.size > 3000) {
                const oldestKey = transferPendingLogsRef.current.keys().next().value;
                if (!oldestKey) break;
                transferPendingLogsRef.current.delete(oldestKey);
              }
              let entry = transferPendingLogsRef.current.get(log.transactionHash);
              if (!entry) {
                entry = { swap: undefined, transfers: [] };
                transferPendingLogsRef.current.set(log.transactionHash, entry);
              }
              entry.transfers.push(log);
            }
            else if (log.topics?.[0] == NAD_FUN_EVENTS.CurveCreate) {
              const hex = log.data.startsWith('0x') ? log.data.slice(2) : log.data;
              const word = (i: number) => BigInt('0x' + hex.slice(i * 64, i * 64 + 64));

              let metadataOffset = Number(word(0)) * 2;
              let metadataLength = Number(BigInt('0x' + hex.slice(metadataOffset, metadataOffset + 64)));
              let metadataStart = metadataOffset + 64;
              let metadataHex = hex.slice(metadataStart, metadataStart + metadataLength * 2);

              let bytes = metadataHex.match(/.{1,2}/g) || [];
              const name = bytes.map((byte: string) => String.fromCharCode(parseInt(byte, 16))).join('');

              metadataOffset = Number(word(1)) * 2;
              metadataLength = Number(BigInt('0x' + hex.slice(metadataOffset, metadataOffset + 64)));
              metadataStart = metadataOffset + 64;
              metadataHex = hex.slice(metadataStart, metadataStart + metadataLength * 2);

              bytes = metadataHex.match(/.{1,2}/g) || [];
              const symbol = bytes.map((byte: string) => String.fromCharCode(parseInt(byte, 16))).join('');

              metadataOffset = Number(word(2)) * 2;
              metadataLength = Number(BigInt('0x' + hex.slice(metadataOffset, metadataOffset + 64)));
              metadataStart = metadataOffset + 64;
              metadataHex = hex.slice(metadataStart, metadataStart + metadataLength * 2);

              let metadataURI = '';
              try {
                metadataURI = decodeURIComponent(metadataHex.match(/.{1,2}/g)?.map((byte: string) => '%' + byte).join('') || '');
              } catch {
                bytes = metadataHex.match(/.{1,2}/g) || [];
                metadataURI = bytes.map((byte: string) => String.fromCharCode(parseInt(byte, 16))).join('');
              }

              const creatorAddress = `0x${log.topics[1].slice(26)}`.toLowerCase();
              const tokenAddress = `0x${log.topics[2].slice(26)}`.toLowerCase();
              const poolAddress = `0x${log.topics[3].slice(26)}`.toLowerCase();

              const newToken: Token = {
                ...defaultMetrics,
                id: tokenAddress,
                dev: creatorAddress,
                name: name || 'Token',
                symbol: symbol || 'TKN',
                image: '',
                description: '',
                twitterHandle: '',
                telegramHandle: '',
                discordHandle: '',
                website: '',
                status: 'new',
                created: Math.floor(Date.now() / 1000),
                price: 0.000083878,
                marketCap: 0.000083878 * TOTAL_SUPPLY,
                volumeDelta: 0,
                graduatedTokens: 0,
                launchedTokens: 0,
                bondingPercentage: 0,
                source: 'nadfun',
                market: poolAddress,
              };

              fetch(metadataURI)
                .then(r => r.json())
                .then(metadata => {
                  dispatch({
                    type: 'ADD_METADATA',
                    id: tokenAddress,
                    updates: {
                      image: metadata.image_uri || '',
                      description: metadata.description || '',
                      twitterHandle: metadata.twitter || '',
                      telegramHandle: metadata.telegram || '',
                      website: metadata.website || '',
                    },
                  });
                })
                .catch(() => { });

              if (pausedColumnRef.current === 'new') {
                pausedTokenQueueRef.current['new'].push(tokenAddress);
              }

              if (memeRef.current.dev && creatorAddress == memeRef.current.dev.toLowerCase() && memeDevTokenIdsRef.current.has(tokenAddress)) {
                const newDev = {
                  id: tokenAddress, symbol, name, imageUrl: '',
                  price: 0.000083878, marketCap: 0.000083878 * TOTAL_SUPPLY, timestamp: Math.floor(Date.now() / 1000), migrated: false,
                };

                setMemeDevTokens(prev => {
                  if (prev.some(t => String(t.id).toLowerCase() === tokenAddress)) return prev;
                  const updated = [newDev, ...prev];
                  memeDevTokenIdsRef.current = new Set(updated.map(t => String(t.id || '').toLowerCase()));
                  return updated;
                });
              }

              dispatch({ type: 'ADD_MARKET', token: newToken });
            }
            else if (log.topics?.[0] == NAD_FUN_EVENTS.CurveBuy || log.topics?.[0] == NAD_FUN_EVENTS.CurveSell) {
              const isBuy = log.topics?.[0] == NAD_FUN_EVENTS.CurveBuy;
              const callerAddr = `0x${log.topics[1].slice(26)}`.toLowerCase();
              const tokenAddr = `0x${log.topics[2].slice(26)}`.toLowerCase();
              let transferEvents;
              if (memeRef.current.id && tokenAddr === memeRef.current.id.toLowerCase()) {
                if (isBuy) {
                  while (transferPendingLogsRef.current.size > 3000) {
                    const oldestKey = transferPendingLogsRef.current.keys().next().value;
                    if (!oldestKey) break;
                    transferPendingLogsRef.current.delete(oldestKey);
                  }
                  let entry = transferPendingLogsRef.current.get(log.transactionHash);
                  if (!entry) {
                    entry = { swap: undefined, transfers: [] };
                    transferPendingLogsRef.current.set(log.transactionHash, entry);
                  }
                  entry.swap = log;
                }
                else {
                  transferEvents = transferPendingLogsRef.current.get(log.transactionHash);
                  if (!transferEvents) return tempset;
                  transferPendingLogsRef.current.delete(log.transactionHash);
                }
              }
              const syncEvent = wsPendingLogsRef.current.get(log.transactionHash);
              if (!syncEvent) return tempset;
              wsPendingLogsRef.current.delete(log.transactionHash);

              const synchex = syncEvent.data.replace(/^0x/, '');
              const syncwords: string[] = [];
              for (let i = 0; i < synchex.length; i += 64) syncwords.push(synchex.slice(i, i + 64));

              const reserveQuote = BigInt('0x' + syncwords[2]);
              const reserveBase = BigInt('0x' + syncwords[3]);
              const price =
                reserveBase == 0n
                  ? 0
                  : Number(reserveQuote) / Number(reserveBase);

              const hex = log.data.replace(/^0x/, '');
              const words: string[] = [];
              for (let i = 0; i < hex.length; i += 64) words.push(hex.slice(i, i + 64));

              const toNum = (x: bigint) => Number(x) / 1e18;
              const amountIn = toNum(BigInt('0x' + words[0]));
              const amountOut = toNum(BigInt('0x' + words[1]));

              dispatch({
                type: 'UPDATE_MARKET',
                id: tokenAddr,
                updates: {
                  price: price,
                  marketCap: price * TOTAL_SUPPLY,
                  buyTransactions: isBuy ? 1 : 0,
                  sellTransactions: isBuy ? 0 : 1,
                  volumeDelta: (isBuy ? amountIn : amountOut),
                  otherVolumeDelta: isBuy == false ? amountIn : amountOut,
                  trader: callerAddr,
                },
              });

              if (trackedWalletsRef.current.some((w: any) => w.address.toLowerCase() === callerAddr.toLowerCase())) {
                const tradeId = `${log.transactionHash}-${log.logIndex}`;

                if (processedTradeIds.current.has(tradeId)) {
                  return tempset;
                }
                let tokenInfo: any = null;

                Object.values(tokensByStatusRef.current).forEach((tokens: any[]) => {
                  const found = tokens.find(t => t.id?.toLowerCase() == tokenAddr);
                  if (found) tokenInfo = found;
                });

                const symbol = tokenInfo?.symbol || 'TKN';
                const name = tokenInfo?.name || 'Token';
                const icon = tokenInfo?.image || undefined;

                const normalized = normalizeTrade({
                  caller: callerAddr,
                  id: tradeId,
                  isBuy: isBuy,
                  price: price,
                  symbol: symbol,
                  name: name,
                  tokenAddress: tokenAddr,
                  tokenIcon: icon,
                  amountIn: amountIn,
                  amountOut: amountOut,
                  timestamp: Date.now(),
                }, trackedWalletsRef.current);

                processedTradeIds.current.add(tradeId);

                setTrackedWalletTrades(prev => {
                  if (prev.some(t => t.id === tradeId)) {
                    return prev;
                  }

                  const updated = [normalized, ...prev];
                  const kept = updated.slice(0, 50);
                  const keptIds = new Set(kept.map(t => t.id));
                  processedTradeIds.current = new Set(
                    Array.from(processedTradeIds.current).filter(id => keptIds.has(id))
                  );

                  return kept;
                });

                setTrackedWalletTrades(prev =>
                  prev.map(t =>
                    t.id === tradeId
                      ? { ...t, token: symbol, tokenName: name, tokenIcon: icon }
                      : t
                  )
                );
              }

              if (memeRef.current.id && tokenAddr === memeRef.current.id.toLowerCase()) {
                setTokenData(p => ({
                  ...p,
                  price,
                  marketCap: price * TOTAL_SUPPLY,
                  change24h: p?.mini?.[0]?.open ? ((price * 1e9 - p?.mini?.[0]?.open) / (p?.mini?.[0]?.open) * 100) : p?.change24h,
                  buyTransactions: (p?.buyTransactions || 0) + (isBuy ? 1 : 0),
                  sellTransactions: (p?.sellTransactions || 0) + (isBuy ? 0 : 1),
                  volume24h: (p?.volume24h || 0) + (isBuy ? amountIn : amountOut),
                }));

                setMemeTrades(prev => [
                  {
                    id: `${log.transactionHash}-${log.logIndex}`,
                    timestamp: Math.floor(Date.now() / 1000),
                    isBuy,
                    price: price,
                    nativeAmount: isBuy ? amountIn : amountOut,
                    tokenAmount: isBuy ? amountOut : amountIn,
                    caller: callerAddr,
                  },
                  ...prev.slice(0, 99),
                ]);

                setChartData((prev: any) => {
                  if (!prev || !Array.isArray(prev) || prev.length < 2) return prev;
                  const [bars, key, flag] = prev;
                  const sel = key?.split('MON').pop() || ''
                  const RESOLUTION_SECS: Record<string, number> = {
                    '1S': 1, '5S': 5, '15S': 15, '1m': 60, '5m': 300, '15m': 900,
                    '1h': 3600, '4h': 14400, '1d': 86400,
                  };
                  const resSecs = RESOLUTION_SECS[sel] ?? 60;
                  const now = Date.now();
                  const bucket = Math.floor(now / (resSecs * 1000)) * resSecs * 1000;
                  const volNative = isBuy ? amountIn : amountOut;

                  const updated = [...bars];
                  const last = updated[updated.length - 1];
                  if (!last || last.time < bucket) {
                    const prevClose = last?.close ?? price;
                    const open = prevClose;
                    const high = Math.max(open, price);
                    const low = Math.min(open, price);
                    const newBar = {
                      time: bucket,
                      open,
                      high,
                      low,
                      close: price,
                      volume: volNative || 0,
                    };
                    updated.push(newBar);
                    const cb =
                      memeRealtimeCallbackRef.current?.[key];
                    if (cb) cb(newBar);
                  } else {
                    const cur = { ...last };
                    cur.high = Math.max(cur.high, price);
                    cur.low = Math.min(cur.low, price);
                    cur.close = price;
                    cur.volume = (cur.volume || 0) + (volNative || 0);
                    updated[updated.length - 1] = cur;
                    const cb =
                      memeRealtimeCallbackRef.current?.[key];
                    if (cb) cb(cur);
                  }
                  if (updated.length > 1200) updated.splice(0, updated.length - 1200);
                  return [updated, key, flag];
                });

                setMemeHolders(prev => {
                  const arr = prev.slice();
                  let idx = arr.findIndex(r => r.address.toLowerCase() === callerAddr);
                  if (idx == -1) {
                    const fresh: Holder = {
                      address: callerAddr,
                      balance: 0,
                      amountBought: 0,
                      amountSold: 0,
                      valueBought: 0,
                      valueSold: 0,
                      valueNet: 0,
                      tokenNet: 0,
                    };
                    arr.push(fresh);
                    idx = arr.length - 1;
                  }
                  const h = { ...arr[idx] };
                  if (isBuy) {
                    h.amountBought = (h.amountBought || 0) + amountOut;
                    h.valueBought = (h.valueBought || 0) + amountIn;
                    h.balance = (h.balance || 0) + amountOut;
                  } else {
                    h.amountSold = (h.amountSold || 0) + amountIn;
                    h.valueSold = (h.valueSold || 0) + amountOut;
                    h.balance = Math.max(0, (h.balance || 0) - amountIn);
                  }
                  arr[idx] = h;

                  for (let i = 0; i < arr.length; i++) {
                    const h = arr[i];
                    const realized = (h.valueSold || 0) - (h.valueBought || 0);
                    const bal = Math.max(0, h.balance || 0);
                    arr[i] = { ...h, valueNet: realized + bal * price };
                  }
                  const topSum = arr.map(h => Math.max(0, h.balance || 0)).sort((a, b) => b - a).slice(0, 10).reduce((s, n) => s + n, 0);
                  setMemeTop10HoldingPct((topSum / TOTAL_SUPPLY) * 100);
                  return arr;
                });

                setMemeTopTraders(prev => {
                  const copy = Array.isArray(prev) ? [...prev] : [];
                  const key = callerAddr;
                  let idx = copy.findIndex(r => r.address.toLowerCase() === key);

                  if (idx === -1) {
                    const row: Holder = {
                      address: callerAddr,
                      balance: 0, tokenNet: 0, valueNet: 0,
                      amountBought: 0, amountSold: 0,
                      valueBought: 0, valueSold: 0,
                    };
                    copy.push(row);
                    idx = copy.length - 1;
                  }

                  const row = { ...copy[idx] };
                  const curBal = Math.max(0, (row.balance ?? row.amountBought - row.amountSold) || 0);
                  if (isBuy) {
                    row.amountBought = (row.amountBought || 0) + amountOut;
                    row.valueBought = (row.valueBought || 0) + amountIn;
                    row.balance = curBal + amountOut;
                  } else {
                    row.amountSold = (row.amountSold || 0) + amountIn;
                    row.valueSold = (row.valueSold || 0) + amountOut;
                    row.balance = Math.max(0, curBal - amountIn);
                  }
                  row.tokenNet = (row.amountBought || 0) - (row.amountSold || 0);
                  copy[idx] = row;

                  for (let i = 0; i < copy.length; i++) {
                    const r = copy[i];
                    const bal = Math.max(0, (r.balance ?? r.amountBought - r.amountSold) || 0);
                    const realized = (r.valueSold || 0) - (r.valueBought || 0);
                    copy[i] = { ...r, valueNet: realized + bal * price };
                  }

                  copy.sort((a, b) => b.valueNet - a.valueNet);
                  if (copy.length > 300) {
                    const removed = copy.splice(300);
                  }
                  return copy;
                });

                setMemePositions(prev => {
                  const copy = Array.isArray(prev) ? [...prev] : [];
                  const allUserAddresses = [
                    (address || '').toLowerCase(),
                    ...(subWallets || []).map(w => (w.address || '').toLowerCase()),
                  ];
                  const isUserTrade = allUserAddresses.includes(callerAddr);
                  if (!isUserTrade) return prev;
                  let idx = copy.findIndex(r => r.tokenId.toLowerCase() === tokenAddr);

                  if (idx == -1 && isUserTrade) {
                    const newPos = {
                      tokenId: memeRef.current.id?.toLowerCase(),
                      symbol: memeRef.current?.symbol || '',
                      name: memeRef.current?.name || '',
                      imageUrl: memeRef.current?.image || '',
                      metadataCID: '',
                      boughtTokens: 0,
                      soldTokens: 0,
                      spentNative: 0,
                      receivedNative: 0,
                      remainingTokens: 0,
                      remainingPct: 0,
                      pnlNative: 0,
                      lastPrice: price,
                    };
                    copy.push(newPos);
                    idx = copy.length - 1;
                  }

                  const pos = { ...copy[idx] };
                  pos.lastPrice = price;
                  if (isUserTrade) {
                    if (isBuy) {
                      pos.boughtTokens += amountOut;
                      pos.spentNative += amountIn;
                      pos.remainingTokens += amountOut;
                    } else {
                      pos.soldTokens += amountIn;
                      pos.receivedNative += amountOut;
                      pos.remainingTokens = Math.max(0, pos.remainingTokens - amountIn);
                    }
                  }
                  pos.remainingPct = pos.boughtTokens > 0 ? (pos.remainingTokens / pos.boughtTokens) * 100 : 0;

                  const balance = Math.max(0, pos.remainingTokens);
                  const realized = (pos.receivedNative || 0) - (pos.spentNative || 0);
                  const unrealized = balance * (pos.lastPrice || 0);
                  pos.pnlNative = realized + unrealized;

                  copy[idx] = pos;

                  if (memeRef.current.id && tokenAddr === memeRef.current.id.toLowerCase()) {
                    const markToMarket = balance * (pos.lastPrice || 0);
                    const totalPnL = (pos.receivedNative || 0) + markToMarket - (pos.spentNative || 0);
                    setMemeUserStats({
                      balance,
                      amountBought: pos.boughtTokens || 0,
                      amountSold: pos.soldTokens || 0,
                      valueBought: pos.spentNative || 0,
                      valueSold: pos.receivedNative || 0,
                      valueNet: totalPnL,
                    });
                  }
                  return copy;
                });

                if (memeDevTokenIdsRef.current.has(tokenAddr)) {
                  setMemeDevTokens(prev => {
                    const updated = prev.map(t => {
                      if ((t.id || '').toLowerCase() !== tokenAddr) return t;
                      return { ...t, price, marketCap: price * TOTAL_SUPPLY, timestamp: Math.floor(Date.now() / 1000) };
                    });
                    memeDevTokenIdsRef.current = new Set(updated.map(t => (t.id || '').toLowerCase()));
                    return updated;
                  });
                }
              }
            }
            else if (log.topics?.[0] == NAD_FUN_EVENTS.CurveSync) {
              while (wsPendingLogsRef.current.size > 3000) {
                const oldestKey = wsPendingLogsRef.current.keys().next().value;
                if (!oldestKey) break;
                wsPendingLogsRef.current.delete(oldestKey);
              }
              wsPendingLogsRef.current.set(log.transactionHash, log)
            }
            else if (log.topics?.[0] == NAD_FUN_EVENTS.CurveGraduate) {
              const tokenAddr = `0x${log.topics[1].slice(26)}`.toLowerCase();
              const market = `0x${log.topics[2].slice(26)}`.toLowerCase();
              dispatch({
                type: 'GRADUATE_MARKET',
                id: tokenAddr,
                market: market
              });
              if (!memeRef.current.id || tokenAddr !== memeRef.current.id.toLowerCase()) return tempset;
              setTokenData(p => ({
                ...p,
                status: 'graduated',
                market: market
              }));
            }
            else if (log.topics?.[0] == UNIV3_EVENTS.Swap) {
              const callerAddr = `0x${log.topics[2].slice(26)}`.toLowerCase();
              const pool = log.address.toLowerCase();

              const hex = log.data.replace(/^0x/, '');
              const words = [];
              for (let i = 0; i < hex.length; i += 64) words.push(hex.slice(i, i + 64));

              const toInt256 = (hex: string) => {
                const b = BigInt('0x' + hex);
                return (b & (1n << 255n)) !== 0n ? b - (1n << 256n) : b;
              };

              const toUint = (hex: string) => BigInt('0x' + hex);

              function decodeSqrtPriceX96(sqrtPriceX96: bigint): number {
                const numerator = sqrtPriceX96 * sqrtPriceX96;
                const denominator = 1n << 192n;

                const scale = 1_000_000n;

                const scaled = (numerator * scale) / denominator;
                return Number(scaled) / 1_000_000;
              }

              const amount0 = toInt256(words[0]);
              const amount1 = toInt256(words[1]);
              const sqrtPriceX96 = toUint(words[2]);

              let price = decodeSqrtPriceX96(sqrtPriceX96);
              let tokenInfo: any = null;
              if (memeRef.current?.market && pool === memeRef.current.market.toLowerCase()) {
                tokenInfo = memeRef.current;
              }
              else {
                Object.values(tokensByStatusRef.current).forEach((tokens: any[]) => {
                  const found = tokens.find(t => t.market?.toLowerCase() == pool);
                  if (found) tokenInfo = found;
                });
              }
              if (!tokenInfo) return tempset;
              const tokenAddr = tokenInfo.id
              const wethIsToken0 = weth.toLowerCase() < tokenAddr.toLowerCase();

              let nativeDelta: bigint;
              let tokenDelta: bigint;

              if (wethIsToken0) {
                nativeDelta = amount0;
                tokenDelta = amount1;
                price = 1 / price
              } else {
                nativeDelta = amount1;
                tokenDelta = amount0;
                price = price
              }

              const isBuy = nativeDelta > 0n;

              const nativeAbs = nativeDelta >= 0n ? nativeDelta : -nativeDelta;
              const tokenAbs = tokenDelta >= 0n ? tokenDelta : -tokenDelta;

              let amountIn: number;
              let amountOut: number;

              const toNum = (x: bigint) => Number(x) / 1e18;

              if (isBuy) {
                amountIn = toNum(nativeAbs);
                amountOut = toNum(tokenAbs);
              } else {
                amountIn = toNum(tokenAbs);
                amountOut = toNum(nativeAbs);
              }

              dispatch({
                type: 'UPDATE_MARKET',
                id: tokenAddr,
                updates: {
                  price: price,
                  marketCap: price * TOTAL_SUPPLY,
                  buyTransactions: isBuy ? 1 : 0,
                  sellTransactions: isBuy ? 0 : 1,
                  volumeDelta: (isBuy ? amountIn : amountOut),
                  otherVolumeDelta: isBuy == false ? amountIn : amountOut,
                  trader: callerAddr,
                },
              });

              if (trackedWalletsRef.current.some((w: any) => w.address.toLowerCase() === callerAddr.toLowerCase())) {
                const tradeId = `${log.transactionHash}-${log.logIndex}`;


                if (processedTradeIds.current.has(tradeId)) {
                  return tempset;
                }

                const symbol = tokenInfo?.symbol || 'TKN';
                const name = tokenInfo?.name || 'Token';
                const icon = tokenInfo?.image || undefined;

                const normalized = normalizeTrade({
                  caller: callerAddr,
                  id: tradeId,
                  isBuy: isBuy,
                  price: price,
                  symbol: symbol,
                  name: name,
                  tokenAddress: tokenAddr,
                  tokenIcon: icon,
                  amountIn: amountIn,
                  amountOut: amountOut,
                  timestamp: Date.now(),
                }, trackedWalletsRef.current);

                processedTradeIds.current.add(tradeId);

                setTrackedWalletTrades(prev => {
                  if (prev.some(t => t.id === tradeId)) {
                    return prev;
                  }

                  const updated = [normalized, ...prev];
                  const kept = updated.slice(0, 50);
                  const keptIds = new Set(kept.map(t => t.id));
                  processedTradeIds.current = new Set(
                    Array.from(processedTradeIds.current).filter(id => keptIds.has(id))
                  );

                  return kept;
                });

                setTrackedWalletTrades(prev =>
                  prev.map(t =>
                    t.id === tradeId
                      ? { ...t, token: symbol, tokenName: name, tokenIcon: icon }
                      : t
                  )
                );
              }

              if (memeRef.current.id && tokenAddr === memeRef.current.id.toLowerCase()) {
                setTokenData(p => ({
                  ...p,
                  price,
                  marketCap: price * TOTAL_SUPPLY,
                  change24h: p?.mini?.[0]?.open ? ((price * 1e9 - p?.mini?.[0]?.open) / (p?.mini?.[0]?.open) * 100) : p?.change24h,
                  buyTransactions: (p?.buyTransactions || 0) + (isBuy ? 1 : 0),
                  sellTransactions: (p?.sellTransactions || 0) + (isBuy ? 0 : 1),
                  volume24h: (p?.volume24h || 0) + (isBuy ? amountIn : amountOut),
                }));

                setMemeTrades(prev => [
                  {
                    id: `${log.transactionHash}-${log.logIndex}`,
                    timestamp: Math.floor(Date.now() / 1000),
                    isBuy,
                    price: price,
                    nativeAmount: isBuy ? amountIn : amountOut,
                    tokenAmount: isBuy ? amountOut : amountIn,
                    caller: callerAddr,
                  },
                  ...prev.slice(0, 99),
                ]);

                setChartData((prev: any) => {
                  if (!prev || !Array.isArray(prev) || prev.length < 2) return prev;
                  const [bars, key, flag] = prev;
                  const sel = key?.split('MON').pop() || ''
                  const RESOLUTION_SECS: Record<string, number> = {
                    '1S': 1, '5S': 5, '15S': 15, '1m': 60, '5m': 300, '15m': 900,
                    '1h': 3600, '4h': 14400, '1d': 86400,
                  };
                  const resSecs = RESOLUTION_SECS[sel] ?? 60;
                  const now = Date.now();
                  const bucket = Math.floor(now / (resSecs * 1000)) * resSecs * 1000;
                  const volNative = isBuy ? amountIn : amountOut;

                  const updated = [...bars];
                  const last = updated[updated.length - 1];
                  if (!last || last.time < bucket) {
                    const prevClose = last?.close ?? price;
                    const open = prevClose;
                    const high = Math.max(open, price);
                    const low = Math.min(open, price);
                    const newBar = {
                      time: bucket,
                      open,
                      high,
                      low,
                      close: price,
                      volume: volNative || 0,
                    };
                    updated.push(newBar);
                    const cb =
                      memeRealtimeCallbackRef.current?.[key];
                    if (cb) cb(newBar);
                  } else {
                    const cur = { ...last };
                    cur.high = Math.max(cur.high, price);
                    cur.low = Math.min(cur.low, price);
                    cur.close = price;
                    cur.volume = (cur.volume || 0) + (volNative || 0);
                    updated[updated.length - 1] = cur;
                    const cb =
                      memeRealtimeCallbackRef.current?.[key];
                    if (cb) cb(cur);
                  }
                  if (updated.length > 1200) updated.splice(0, updated.length - 1200);
                  return [updated, key, flag];
                });

                setMemeHolders(prev => {
                  const arr = prev.slice();
                  let idx = arr.findIndex(r => r.address.toLowerCase() === callerAddr);
                  if (idx == -1) {
                    const fresh: Holder = {
                      address: callerAddr,
                      balance: 0,
                      amountBought: 0,
                      amountSold: 0,
                      valueBought: 0,
                      valueSold: 0,
                      valueNet: 0,
                      tokenNet: 0,
                    };
                    arr.push(fresh);
                    idx = arr.length - 1;
                  }
                  const h = { ...arr[idx] };
                  if (isBuy) {
                    h.amountBought = (h.amountBought || 0) + amountOut;
                    h.valueBought = (h.valueBought || 0) + amountIn;
                    h.balance = (h.balance || 0) + amountOut;
                  } else {
                    h.amountSold = (h.amountSold || 0) + amountIn;
                    h.valueSold = (h.valueSold || 0) + amountOut;
                    h.balance = Math.max(0, (h.balance || 0) - amountIn);
                  }
                  arr[idx] = h;

                  for (let i = 0; i < arr.length; i++) {
                    const h = arr[i];
                    const realized = (h.valueSold || 0) - (h.valueBought || 0);
                    const bal = Math.max(0, h.balance || 0);
                    arr[i] = { ...h, valueNet: realized + bal * price };
                  }
                  const topSum = arr.map(h => Math.max(0, h.balance || 0)).sort((a, b) => b - a).slice(0, 10).reduce((s, n) => s + n, 0);
                  setMemeTop10HoldingPct((topSum / TOTAL_SUPPLY) * 100);
                  return arr;
                });

                setMemeTopTraders(prev => {
                  const copy = Array.isArray(prev) ? [...prev] : [];
                  const key = callerAddr;
                  let idx = copy.findIndex(r => r.address.toLowerCase() === key);

                  if (idx === -1) {
                    const row: Holder = {
                      address: callerAddr,
                      balance: 0, tokenNet: 0, valueNet: 0,
                      amountBought: 0, amountSold: 0,
                      valueBought: 0, valueSold: 0,
                    };
                    copy.push(row);
                    idx = copy.length - 1;
                  }

                  const row = { ...copy[idx] };
                  const curBal = Math.max(0, (row.balance ?? row.amountBought - row.amountSold) || 0);
                  if (isBuy) {
                    row.amountBought = (row.amountBought || 0) + amountOut;
                    row.valueBought = (row.valueBought || 0) + amountIn;
                    row.balance = curBal + amountOut;
                  } else {
                    row.amountSold = (row.amountSold || 0) + amountIn;
                    row.valueSold = (row.valueSold || 0) + amountOut;
                    row.balance = Math.max(0, curBal - amountIn);
                  }
                  row.tokenNet = (row.amountBought || 0) - (row.amountSold || 0);
                  copy[idx] = row;

                  for (let i = 0; i < copy.length; i++) {
                    const r = copy[i];
                    const bal = Math.max(0, (r.balance ?? r.amountBought - r.amountSold) || 0);
                    const realized = (r.valueSold || 0) - (r.valueBought || 0);
                    copy[i] = { ...r, valueNet: realized + bal * price };
                  }

                  copy.sort((a, b) => b.valueNet - a.valueNet);
                  if (copy.length > 300) {
                    const removed = copy.splice(300);
                  }
                  return copy;
                });

                setMemePositions(prev => {
                  const copy = Array.isArray(prev) ? [...prev] : [];
                  const allUserAddresses = [
                    (address || '').toLowerCase(),
                    ...(subWallets || []).map(w => (w.address || '').toLowerCase()),
                  ];
                  const isUserTrade = allUserAddresses.includes(callerAddr);
                  if (!isUserTrade) return prev;
                  let idx = copy.findIndex(r => r.tokenId.toLowerCase() === tokenAddr);

                  if (idx == -1 && isUserTrade) {
                    const newPos = {
                      tokenId: memeRef.current.id?.toLowerCase(),
                      symbol: memeRef.current?.symbol || '',
                      name: memeRef.current?.name || '',
                      imageUrl: memeRef.current?.image || '',
                      metadataCID: '',
                      boughtTokens: 0,
                      soldTokens: 0,
                      spentNative: 0,
                      receivedNative: 0,
                      remainingTokens: 0,
                      remainingPct: 0,
                      pnlNative: 0,
                      lastPrice: price,
                    };
                    copy.push(newPos);
                    idx = copy.length - 1;
                  }

                  const pos = { ...copy[idx] };
                  pos.lastPrice = price;
                  if (isUserTrade) {
                    if (isBuy) {
                      pos.boughtTokens += amountOut;
                      pos.spentNative += amountIn;
                      pos.remainingTokens += amountOut;
                    } else {
                      pos.soldTokens += amountIn;
                      pos.receivedNative += amountOut;
                      pos.remainingTokens = Math.max(0, pos.remainingTokens - amountIn);
                    }
                  }
                  pos.remainingPct = pos.boughtTokens > 0 ? (pos.remainingTokens / pos.boughtTokens) * 100 : 0;

                  const balance = Math.max(0, pos.remainingTokens);
                  const realized = (pos.receivedNative || 0) - (pos.spentNative || 0);
                  const unrealized = balance * (pos.lastPrice || 0);
                  pos.pnlNative = realized + unrealized;

                  copy[idx] = pos;

                  if (memeRef.current.id && tokenAddr === memeRef.current.id.toLowerCase()) {
                    const markToMarket = balance * (pos.lastPrice || 0);
                    const totalPnL = (pos.receivedNative || 0) + markToMarket - (pos.spentNative || 0);
                    setMemeUserStats({
                      balance,
                      amountBought: pos.boughtTokens || 0,
                      amountSold: pos.soldTokens || 0,
                      valueBought: pos.spentNative || 0,
                      valueSold: pos.receivedNative || 0,
                      valueNet: totalPnL,
                    });
                  }
                  return copy;
                });

                if (memeDevTokenIdsRef.current.has(tokenAddr)) {
                  setMemeDevTokens(prev => {
                    const updated = prev.map(t => {
                      if ((t.id || '').toLowerCase() !== tokenAddr) return t;
                      return { ...t, price, marketCap: price * TOTAL_SUPPLY, timestamp: Math.floor(Date.now() / 1000) };
                    });
                    memeDevTokenIdsRef.current = new Set(updated.map(t => (t.id || '').toLowerCase()));
                    return updated;
                  });
                }
              }
            }
            return tempset;
          })
        } catch (parseError) {
          console.warn('Failed to parse WebSocket message:', parseError);
        }
      };

      explorerWsRef.current.onclose = () => {
        setWsReady(false)
        if (explorerPingIntervalRef.current) {
          clearInterval(explorerPingIntervalRef.current);
          explorerPingIntervalRef.current = null;
        }
        explorerReconnectIntervalRef.current = setTimeout(() => {
          connectWebSocket();
        }, 500);
      };

      explorerWsRef.current.onerror = (error) => {
        console.error(error)
      };
    };

    connectWebSocket();

    return () => {
      cancelled = true;
      if (explorerPingIntervalRef.current) {
        clearInterval(explorerPingIntervalRef.current);
        explorerPingIntervalRef.current = null;
      }
      if (explorerReconnectIntervalRef.current) {
        clearTimeout(explorerReconnectIntervalRef.current);
        explorerReconnectIntervalRef.current = null;
      }
      if (explorerWsRef.current) {
        explorerWsRef.current.close();
        explorerWsRef.current = null;
      }
    };
  }, [!['board', 'spectra', 'meme', 'launchpad', 'trackers'].includes(location.pathname.split('/')[1])]);

  // memeinterface
  const token: Token = useMemo(() => {
    const baseDefaults: Token = {
      id: tokenAddress || "",
      name: "Token",
      symbol: "TKN",
      dev: "",
      image: "",
      price: 0,
      marketCap: 0,
      change24h: 0,
      volume24h: 0,
      mini: [],
      holders: 0,
      proTraders: 0,
      sniperHolding: 0,
      devHolding: 0,
      bundleHolding: 0,
      insiderHolding: 0,
      top10Holding: 0,
      buyTransactions: 0,
      sellTransactions: 0,
      globalFeesPaid: 0,
      website: "",
      twitterHandle: "",
      progress: 0,
      status: "new",
      description: "",
      created: Math.floor(Date.now() / 1000),
      bondingAmount: 0,
      volumeDelta: 0,
      telegramHandle: "",
      discordHandle: "",
      graduatedTokens: 0,
      launchedTokens: 0,
      bondingPercentage: 0,
      source: "nadfun"
    };

    const snapshot: Partial<Token> = (tokenData ?? {}) as Partial<Token>;
    const merged = {
      ...baseDefaults,
      ...snapshot,
    } as Token;

    merged.id = (tokenAddress || "").toLowerCase();
    if (!merged.created) {
      merged.created = Math.floor(Date.now() / 1000);
    }
    memeRef.current = merged
    return merged;
  }, [tokenAddress, tokenData]);

  useEffect(() => {
    if (!explorerWsRef.current) return;
    if (explorerWsRef.current.readyState !== WebSocket.OPEN) return;
    const graduated = Object.values(tokensByStatus.graduated || []);
    const pools = graduated
      .map((t: any) => t.market?.toLowerCase())
      .filter(Boolean);
    pools.push(token?.market);

    const sub = JSON.stringify({
      jsonrpc: "2.0",
      id: "sub_uni_update",
      method: "eth_subscribe",
      params: [
        "monadLogs",
        { address: pools, topics: [[UNIV3_EVENTS.Swap]] }
      ]
    });
    explorerWsRef.current.send(sub);

    if (uniSubRef.current) {
      const unsub = JSON.stringify({
        jsonrpc: "2.0",
        id: "unsub_uni",
        method: "eth_unsubscribe",
        params: [uniSubRef.current]
      });
      explorerWsRef.current.send(unsub);
    }
  }, [token?.market, tokensByStatus?.graduated?.[0]?.market, wsReady]);

  useEffect(() => {
    if (!explorerWsRef.current) return;
    if (explorerWsRef.current.readyState !== WebSocket.OPEN) return;

    if (token.id) {
      const sub = JSON.stringify({
        jsonrpc: "2.0",
        id: "sub_transfer",
        method: "eth_subscribe",
        params: [
          "monadLogs",
          { address: token.id, topics: [[CRYSTAL_EVENTS.Transfer]] }
        ]
      });
      explorerWsRef.current.send(sub);
    }
    if (transferSubRef.current) {
      const unsub = JSON.stringify({
        jsonrpc: "2.0",
        id: "unsub_transfer",
        method: "eth_unsubscribe",
        params: [transferSubRef.current]
      });
      explorerWsRef.current.send(unsub);
    }
  }, [token.id, wsReady]);

  // metadata n klines
  useEffect(() => {
    if (!token.id) return;
    let isCancelled = false;

    const id = (token.id || "").toLowerCase();
    let tempTokenData: any = {};
    let price = 0;

    setIsLoadingTrades(true);
    setMemeTrades([]);

    const fetchMemeTokenData = async () => {
      try {
        const chartRes =
          memeSelectedInterval === "1s"
            ? 1
            : memeSelectedInterval === "5s"
              ? 5
              : memeSelectedInterval === "15s"
                ? 15
                : memeSelectedInterval === "1m"
                  ? 60
                  : memeSelectedInterval === "5m"
                    ? 300
                    : memeSelectedInterval === "15m"
                      ? 900
                      : memeSelectedInterval === "1h"
                        ? 3600
                        : memeSelectedInterval === "4h"
                          ? 14400
                          : 86400;

        const trackedParam =
          trackedAddresses.length > 0
            ? `?tracked=${[...new Set(trackedAddresses)]
              .map((a) => a.toLowerCase())
              .join(",")}`
            : "";

        const res = await fetch(
          `https://api.crystal.exchange/token/${id}/${chartRes}${trackedParam}`,
          {
            method: "GET",
            headers: { "content-type": "application/json" },
          },
        );

        if (!res.ok) {
          throw new Error(`token api returned ${res.status}`);
        }

        const m = await res.json();
        if (isCancelled || !m) return;
        const tradesSource =
          trackedAddresses.length > 0 &&
            (Array.isArray(m.trackedTrades) || Array.isArray(m.trackedtrades))
            ? (Array.isArray(m.trackedTrades) ? m.trackedTrades : m.trackedtrades)
            : (Array.isArray(m.trades) ? m.trades : []);

        if (tradesSource.length) {
          const mapped = tradesSource.map((t: any) => {
            const isBuy = t.trade.isBuy;
            const priceWad = Number(
              t.trade.priceNativePerTokenWad ?? 0,
            );
            const amountIn = Number(t.trade.amountIn ?? 0);
            const amountOut = Number(t.trade.amountOut ?? 0);

            return {
              id: t.trade.id,
              timestamp: Number(t.trade.block ?? 0),
              isBuy,
              price: priceWad,
              tokenAmount: (isBuy ? amountOut : amountIn) / 1e18,
              nativeAmount: (isBuy ? amountIn : amountOut) / 1e18,
              caller: t.trade.account?.id ?? t.user ?? "",
            };
          });
          setMemeTrades(mapped);
        } else {
          setMemeTrades([]);
        }

        if (m.series?.klines && Array.isArray(m.series.klines)) {
          const bars = m.series.klines
            .slice()
            .map((c: any) => ({
              time: Number(c.time) * 1000,
              open: Number(c.open) / 1e9,
              high: Number(c.high) / 1e9,
              low: Number(c.low) / 1e9,
              close: Number(c.close) / 1e9,
              volume: Number(c.quoteVolume) / 1e18,
            }));

          const resForChart =
            memeSelectedInterval === "1d"
              ? "1D"
              : memeSelectedInterval === "4h"
                ? "240"
                : memeSelectedInterval === "1h"
                  ? "60"
                  : memeSelectedInterval.endsWith("s")
                    ? memeSelectedInterval.slice(0, -1).toUpperCase() + "S"
                    : memeSelectedInterval.slice(0, -1);

          setChartData([bars, m.symbol + "MON" + resForChart, true]);
        }

        price = Number(m.lastPriceNativePerTokenWad || 0) / 1e9;
        const socialsRaw = [m.social1, m.social2, m.social3, m.social4];
        const socials = socialsRaw.map((s) =>
          s ? (/^https?:\/\//.test(s) ? s : `https://${s}`) : s,
        );

        const twitter = socials.find(
          (s) =>
            s?.startsWith("https://x.com") ||
            s?.startsWith("https://twitter.com"),
        );
        if (twitter) socials.splice(socials.indexOf(twitter), 1);

        const telegram = socials.find((s) => s?.startsWith("https://t.me"));
        if (telegram) socials.splice(socials.indexOf(telegram), 1);

        const discord = socials.find(
          (s) =>
            s?.startsWith("https://discord.gg") ||
            s?.startsWith("https://discord.com"),
        );
        if (discord) socials.splice(socials.indexOf(discord), 1);

        const website = socials[0];
        const imageUrl = m.metadataCID || "";

        let change24h = 0;
        if (typeof m.change24h === "number") {
          change24h = m.change24h;
        } else if (m.mini?.klines?.length) {
          const open = Number(m.mini.klines[0].open || 0);
          if (open > 0) {
            change24h = ((price * 1e9 - open) / open) * 100;
          }
        }

        tempTokenData = {
          ...tokenData,
          ...m,
          id: m.id.toLowerCase(),
          dev: m.creator?.id?.toLowerCase() ?? "",
          name: m.name,
          symbol: m.symbol,
          image: imageUrl,
          twitterHandle: twitter ?? "",
          website: website ?? "",
          created: m.timestamp,
          status: m.migrated
            ? "graduated"
            : price * TOTAL_SUPPLY > 616254
              ? "graduating"
              : "new",
          price,
          marketCap: price * TOTAL_SUPPLY,
          buyTransactions: Number(m.buyTxs ?? 0),
          sellTransactions: Number(m.sellTxs ?? 0),
          mini: m.mini?.klines ?? "",
          change24h,
          volume24h: Number(m.volumeNative ?? 0) / 1e18,
          volumeDelta: 0,
          discordHandle: discord ?? "",
          telegramHandle: telegram ?? "",
          launchedTokens: m.creator?.tokensLaunched ?? "",
          graduatedTokens: m.creator?.tokensGraduated ?? "",
          holders: (m.totalHolders ?? 0) - 1,
          devHolding: Number(m.devHoldingAmount ?? 0) / 1e27,
          trades: m.trades,
          bondingPercentage: m.graduationPercentageBps,
          source: "nadfun",
        };

        setTokenData(tempTokenData);
        if (Array.isArray(m.holders)) {
          const mappedHolders: Holder[] = m.holders.slice(0, 50)
            .filter(
              (p: any) =>
                p.account?.id?.toLowerCase() !==
                settings.chainConfig[activechain].router.toLowerCase(),
            )
            .map((p: any) => {
              const amountBought = Number(p.tokenBought ?? 0) / 1e18;
              const amountSold = Number(p.tokenSold ?? 0) / 1e18;
              const valueBought = Number(p.nativeSpent ?? 0) / 1e18;
              const valueSold = Number(p.nativeReceived ?? 0) / 1e18;
              const balance = Number(p.tokens ?? 0) / 1e18;
              const realized = valueSold - valueBought;
              const unrealized = balance * price;
              const totalPnl = realized + unrealized;

              return {
                address: p.account.id,
                balance,
                amountBought,
                amountSold,
                valueBought,
                valueSold,
                tokenNet: balance,
                valueNet: totalPnl,
              };
            });

          const top10Pct =
            (mappedHolders
              .map((h) => Math.max(0, h.balance))
              .sort((a, b) => b - a)
              .slice(0, 10)
              .reduce((s, n) => s + n, 0) /
              1e9) *
            100;

          setMemeTop10HoldingPct(top10Pct);
          setMemeHolders(mappedHolders);
        } else {
          setMemeHolders([]);
        }


        if (Array.isArray(m.topTraders)) {
          const rows: any[] = m.topTraders;
          const out: Holder[] = [];

          for (const p of rows) {
            if (
              p.account?.id?.toLowerCase() !==
              settings.chainConfig[activechain].router.toLowerCase()
            ) {
              const amountBought = Number(p.tokenBought ?? 0) / 1e18;
              const amountSold = Number(p.tokenSold ?? 0) / 1e18;
              const valueBought = Number(p.nativeSpent ?? 0) / 1e18;
              const valueSold = Number(p.nativeReceived ?? 0) / 1e18;
              const balance = Number(p.tokens ?? 0) / 1e18;
              const realized = valueSold - valueBought;
              const unrealized = balance * price;
              const pnl = realized + unrealized;

              out.push({
                address: p.account.id,
                balance,
                tokenNet: balance,
                valueNet: pnl,
                amountBought,
                amountSold,
                valueBought,
                valueSold,
              });
            }
          }

          out.sort((a, b) => b.valueNet - a.valueNet);
          const trimmed = out.slice(0, 100);
          setMemeTopTraders(trimmed);
        } else {
          setMemeTopTraders([]);
        }

        if (Array.isArray(m.devTokens)) {
          const devtokenout = m.devTokens.map((t: any) => {
            const imageUrl = t.metadataCID || "";
            const devPrice = Number(t.lastPriceNativePerTokenWad || 0) / 1e9;
            return {
              id: t.id,
              symbol: t.symbol,
              name: t.name,
              imageUrl,
              price: devPrice,
              marketCap: devPrice * TOTAL_SUPPLY,
              timestamp: Number(t.timestamp ?? 0),
              status: t.migrated,
              holders: t.holders,
            };
          });

          setMemeDevTokens(devtokenout);
          memeDevTokenIdsRef.current = new Set(
            devtokenout.map((t: any) => String(t.id || "").toLowerCase()),
          );
        } else {
          setMemeDevTokens([]);
          memeDevTokenIdsRef.current = new Set();
        }

        if (Array.isArray(m.similarTokens)) {
          const similar = m.similarTokens.map((t: any) => {
            const imageUrl = t.metadataCID || "";
            const simPrice =
              Number(t.lastPriceNativePerTokenWad || 0) / 1e9;
            const lastUpdatedAt = Number(t.lastUpdatedAt ?? 0);
            const volumeNativeRaw = Number(t.volumeNative ?? 0);
            const volume24h =
              (Date.now() / 1000 - lastUpdatedAt > 86400
                ? 0
                : volumeNativeRaw) / 1e18;

            return {
              id: t.id,
              name: t.name,
              symbol: t.symbol,
              imageUrl,
              price: simPrice,
              marketCap: simPrice * TOTAL_SUPPLY,
              volume24h,
              timestamp: Number(t.timestamp ?? 0),
              lastUpdatedAt,
            };
          });

          setMemeSimilarTokens(similar);
        } else {
          setMemeSimilarTokens([]);
        }
      } catch (e) {
        console.error("Error fetching token data:", e);
        const resForChart =
          memeSelectedInterval === "1d"
            ? "1D"
            : memeSelectedInterval === "4h"
              ? "240"
              : memeSelectedInterval === "1h"
                ? "60"
                : memeSelectedInterval.endsWith("s")
                  ? memeSelectedInterval.slice(0, -1).toUpperCase() + "S"
                  : memeSelectedInterval.slice(0, -1);
        setChartData([[], token.symbol + "MON" + resForChart, true]);
        setTokenData({ ...token, created: Math.floor(Date.now() / 1000), mini: [{ open: 0.000083878 * 1e9 }] });
        setMemeTrades([]);
        setMemeHolders([]);
        setMemeTopTraders([]);
        setMemeDevTokens([]);
        setMemeSimilarTokens([]);
      } finally {
        if (!isCancelled) {
          setIsLoadingTrades(false);
        }
      }
    };

    fetchMemeTokenData();
    return () => {
      isCancelled = true;
    };
  }, [token.id, memeSelectedInterval, trackedAddresses]);

  // positions aggregated across all wallets
  useEffect(() => {
    const allAddresses = [...new Set(
      [scaAddress, ...subWallets.map(w => w.address)]
        .filter(Boolean)
        .map(a => a.toLowerCase())
    )];

    if (allAddresses.length === 0) return;

    let cancelled = false;

    (async () => {
      const totals = {
        balance: 0,
        amountBought: 0,
        amountSold: 0,
        valueBought: 0,
        valueSold: 0,
        lastPriceNative: 0,
      };

      const aggregatedMap = new Map<string, any>();

      try {
        const responses = await Promise.all(
          allAddresses.map((addr) =>
            fetch(`https://api.crystal.exchange/user/${addr}`, {
              method: 'GET',
              headers: { 'content-type': 'application/json' },
            }),
          ),
        );

        const payloads = await Promise.all(
          responses.map((res) => (res.ok ? res.json() : null)),
        );

        for (const payload of payloads) {
          if (!payload) continue;
          const rows: any[] = payload.positions ?? [];

          for (const p of rows) {
            const tokenId = String(p.token || '').toLowerCase();
            if (!tokenId) continue;

            const boughtTokens = Number(p.token_bought ?? 0) / 1e18;
            const soldTokens = Number(p.token_sold ?? 0) / 1e18;
            const spentNative = Number(p.native_spent ?? 0) / 1e18;
            const receivedNative = Number(p.native_received ?? 0) / 1e18;
            const balance = Number(p.balance_token ?? 0) / 1e18;
            const balanceNative = Number(p.balance_native ?? 0) / 1e18;

            const lastPrice =
              balance > 0 ? balanceNative / balance : 0;

            if (!aggregatedMap.has(tokenId)) {
              const imageUrl = p.metadata_cid || '';

              aggregatedMap.set(tokenId, {
                tokenId: p.token,
                symbol: p.symbol,
                name: p.name,
                metadataCID: p.metadata_cid,
                imageUrl,
                boughtTokens: 0,
                soldTokens: 0,
                spentNative: 0,
                receivedNative: 0,
                remainingTokens: 0,
                lastPrice: 0,
              });
            }

            const existing = aggregatedMap.get(tokenId);
            existing.boughtTokens += boughtTokens;
            existing.soldTokens += soldTokens;
            existing.spentNative += spentNative;
            existing.receivedNative += receivedNative;
            existing.remainingTokens += balance;
            if (lastPrice) existing.lastPrice = lastPrice;

            if (tokenId === (token.id || '').toLowerCase()) {
              totals.amountBought += boughtTokens;
              totals.amountSold += soldTokens;
              totals.valueBought += spentNative;
              totals.valueSold += receivedNative;
              totals.balance += balance;
              if (lastPrice) totals.lastPriceNative = lastPrice;
            }
          }
        }

        if (cancelled) return;

        const all = Array.from(aggregatedMap.values()).map((pos) => {
          const realized = pos.receivedNative - pos.spentNative;
          const unrealized = pos.remainingTokens * pos.lastPrice;
          const pnlNative = realized + unrealized;
          const remainingPct =
            pos.boughtTokens > 0
              ? (pos.remainingTokens / pos.boughtTokens) * 100
              : 100;

          return {
            ...pos,
            remainingPct,
            pnlNative,
          };
        });

        const markToMarket = totals.balance * (totals.lastPriceNative || 0);
        const totalPnL = totals.valueSold + markToMarket - totals.valueBought;

        const sorted = all.sort((a, b) => b.remainingTokens - a.remainingTokens);
        setMemePositions(sorted);
        setMemeUserStats({
          balance: totals.balance,
          amountBought: totals.amountBought,
          amountSold: totals.amountSold,
          valueBought: totals.valueBought,
          valueSold: totals.valueSold,
          valueNet: totalPnL,
        });
      } catch (e) {
        console.error('aggregated user positions failed', e);
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [address, subWallets, token.id]);

  // live dev holding
  useEffect(() => {
    const dev = (token.dev || "").toLowerCase();
    if (!dev) {
      setTokenData(p => ({ ...p, devHolding: 0 }));
      return;
    }

    const row = memeHolders.find(h => (h.address || "").toLowerCase() === dev);
    const pct = row ? (Math.max(0, row.balance || 0) / 1e9) * 100 : 0;

    setTokenData(p => ({ ...p, devHolding: pct }));
  }, [
    memeHolders,
    token.dev,
  ]);

  useEffect(() => {
    if (!trackedWalletTrades || trackedWalletTrades.length === 0 || trackedWallets.length === 0) {
      return;
    }

    const formatAmount = (amount: number, decimals: number = 2) => {
      if (amount >= 1e9) return `${(amount / 1e9).toFixed(decimals)}B`;
      if (amount >= 1e6) return `${(amount / 1e6).toFixed(decimals)}M`;
      if (amount >= 1e3) return `${(amount / 1e3).toFixed(decimals)}K`;
      return amount.toFixed(decimals);
    };

    const formatMarketCap = (marketCap: number) => {
      const usd = monUsdPrice ? marketCap * monUsdPrice : marketCap;
      return '$' + formatAmount(usd, 1);
    };

    trackedWalletTrades.forEach((trade: any) => {
      if (shownTradeIds.current.has(trade.id)) {
        return;
      }


      const trackedWallet = trackedWallets.find(
        w => w.address.toLowerCase() === trade.walletAddress?.toLowerCase()
      );

      if (!trackedWallet) {
        return;
      }

      shownTradeIds.current.add(trade.id);

      let actionText = '';
      if (trade.type === 'buy') {
        actionText = trade.isFirstBuy ? 'bought' : 'bought more';
      } else if (trade.type === 'sell') {
        actionText = trade.soldAll ? 'sold all' : 'sold some';
      } else {
        actionText = trade.type;
      }

      const title = `${actionText} ${trade.token || trade.tokenSymbol || 'token'}`;
      const subtitle = `${formatAmount(trade.amount, 2)} at ${formatMarketCap(trade.marketCap)} MC`;


      const notificationId = `tracked-trade-${trade.id}`;

      showLoadingPopup(notificationId, {
        title,
        subtitle,
        tokenImage: trade.tokenIcon,
        walletAddress: trackedWallet.address,
        timestamp: trade.timestamp || Date.now(),
        isClickable: true,
        actionType: trade.type,
        onClick: () => {
          if (trade.tokenAddress) {
            navigate(`/meme/${trade.tokenAddress}`);
          }
        }
      });

      setTimeout(() => {
        updatePopup(notificationId, {
          title,
          subtitle,
          variant: 'success',
          confirmed: true,
          isLoading: false,
          tokenImage: trade.tokenIcon,
          walletAddress: trackedWallet.address,
          timestamp: trade.timestamp || Date.now(),
          isClickable: true,
          actionType: trade.type,
          onClick: () => {
            if (trade.tokenAddress) {
              navigate(`/meme/${trade.tokenAddress}`);
            }
          }
        });
      }, 50);
    });

    if (shownTradeIds.current.size > 1000) {
      const idsArray = Array.from(shownTradeIds.current);
      shownTradeIds.current = new Set(idsArray.slice(-1000));
    }
  }, [trackedWalletTrades, trackedWallets, monUsdPrice]);

  // data loop, reuse to have every single rpc call method in this loop
  const { data: terminalQueryData, isFetching: isTerminalDataFetching, dataUpdatedAt: terminalDataUpdatedAt, refetch: terminalRefetch } = useQuery({
    queryKey: [
      'crystal_rpc_terminal_reads',
      address,
      token.id,
      subWallets.length
    ],
    queryFn: async () => {
      let gasEstimateCall: any = null;
      let gasEstimate: bigint = 0n;
      const tokenAddresses = [
        ...Object.values(tokendict).map(t => t.address),
        ...(token.id ? [token.id] : [])
      ];

      if (address && (['board', 'spectra', 'meme'].includes(location.pathname.split('/')[1]))) {
        try {
          const deadline = BigInt(Math.floor(Date.now() / 1000) + 900);

          let tx: any = null;

          if (tx) {
            gasEstimateCall = {
              jsonrpc: '2.0',
              id: 1,
              method: 'eth_estimateGas',
              params: [{
                from: address as `0x${string}`,
                to: tx.target,
                data: tx.data,
                value: tx.value ? `0x${tx.value.toString(16)}` : '0x'
              }]
            };
          }
        } catch (e) {
          gasEstimateCall = null;
        }
      }

      const mainGroup: any = [
        {
          disabled: !scaAddress,
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'batchBalanceOf',
          args: [
            scaAddress as `0x${string}`,
            tokenAddresses
          ]
        },
        ...subWallets.map(w => ({
          disabled: !w.address,
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'batchBalanceOf',
          args: [
            w.address as `0x${string}`,
            tokenAddresses
          ]
        })),
        ...([
          token.source === "nadfun"
            ? {
              disabled: false,
              to: balancegetter,
              abi: CrystalDataHelperAbi,
              functionName: "getReserves",
              args: [settings.chainConfig[activechain].nadFunBondingCurve, token?.market || token.id, weth, token.id, settings.chainConfig[activechain].zeroXAllowanceHolder, [scaAddress].concat(subWallets.map(w => w.address))]
            }
            : {
              disabled: false,
              to: balancegetter,
              abi: CrystalDataHelperAbi,
              functionName: "getVirtualReserves",
              args: [router, token.id, weth, BigInt(1000000), BigInt(1), BigInt(100)]
            }
        ])
      ];

      const groups: any = {
        mainGroup
      };

      const callData: any = []
      const callMapping: any = []

      const groupResults: any = {};
      Object.keys(groups).forEach(groupKey => {
        groupResults[groupKey] = [];
      });

      Object.entries(groups).forEach(([groupKey, group]: [string, any]) => {
        group.forEach((call: any, callIndex: number) => {
          if (!call.disabled) {
            try {
              callData.push({
                target: call.to || call.address,
                callData: encodeFunctionData({
                  abi: call.abi,
                  functionName: call.functionName,
                  args: call.args
                })
              });

              callMapping.push({
                groupKey,
                callIndex
              });
            } catch (e: any) {
              while (groupResults[groupKey].length < callIndex) {
                groupResults[groupKey].push(null);
              }
              groupResults[groupKey][callIndex] = { error: e.message, result: undefined, status: "failure" };
            }
          }
          else {
            while (groupResults[groupKey].length < callIndex) {
              groupResults[groupKey].push(null);
            }
            groupResults[groupKey][callIndex] = { error: "param missing", result: undefined, status: "failure" };
          }
        });
      });

      const multicallData: any = encodeFunctionData({
        abi: [{
          inputs: [
            { name: 'requireSuccess', type: 'bool' },
            {
              components: [
                { name: 'target', type: 'address' },
                { name: 'callData', type: 'bytes' }
              ], name: 'calls', type: 'tuple[]'
            }
          ],
          name: 'tryBlockAndAggregate',
          outputs: [
            { name: 'blockNumber', type: 'uint256' },
            { name: 'blockHash', type: 'bytes32' },
            {
              components: [
                { name: 'success', type: 'bool' },
                { name: 'returnData', type: 'bytes' }
              ], name: 'returnData', type: 'tuple[]'
            }
          ],
          stateMutability: 'view',
          type: 'function'
        }],
        functionName: 'tryBlockAndAggregate',
        args: [false, callData]
      })

      let shouldFetchNonce = false;
      if (Date.now() - lastNonceGroupFetch.current >= 9500) {
        lastNonceGroupFetch.current = Date.now();
        shouldFetchNonce = true;
      }

      const response: any = await fetch(HTTP_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify([{
          jsonrpc: '2.0',
          id: 1,
          method: 'eth_call',
          params: [{ to: settings.chainConfig[activechain].multicall3, data: multicallData }, 'latest']
        }, ...(gasEstimateCall ? [gasEstimateCall] : []), ...(shouldFetchNonce ? subWallets.map(w => ({
          jsonrpc: '2.0',
          id: 1,
          method: 'eth_getTransactionCount',
          params: [w.address, 'pending']
        })) : [])])
      })

      const json: any = await response.json()

      const returnData: any = decodeFunctionResult({
        abi: [{
          inputs: [
            { name: 'requireSuccess', type: 'bool' },
            {
              components: [
                { name: 'target', type: 'address' },
                { name: 'callData', type: 'bytes' }
              ], name: 'calls', type: 'tuple[]'
            }
          ],
          name: 'tryBlockAndAggregate',
          outputs: [
            { name: 'blockNumber', type: 'uint256' },
            { name: 'blockHash', type: 'bytes32' },
            {
              components: [
                { name: 'success', type: 'bool' },
                { name: 'returnData', type: 'bytes' }
              ], name: 'returnData', type: 'tuple[]'
            }
          ],
          stateMutability: 'view',
          type: 'function'
        }],
        functionName: 'tryBlockAndAggregate',
        data: json[0].result
      })

      blockNumber.current = returnData?.[0]
      returnData?.[2]?.forEach((data: any, responseIndex: number) => {
        const { groupKey, callIndex } = callMapping[responseIndex] || {};
        if (groupKey === undefined) return;
        const originalCall = groups[groupKey][callIndex];
        while (groupResults[groupKey].length <= callIndex) {
          groupResults[groupKey].push(null);
        }
        if (data?.success == true) {
          try {
            const decodedResult = decodeFunctionResult({
              abi: originalCall.abi,
              functionName: originalCall.functionName,
              data: data?.returnData
            });
            groupResults[groupKey][callIndex] = { result: decodedResult, status: "success" };
          } catch (e: any) {
            groupResults[groupKey][callIndex] = { error: e.message, result: undefined, status: "failure" };
          }
        }
        else {
          groupResults[groupKey][callIndex] = { error: 'call reverted', result: undefined, status: "failure" };
        }
      });

      if (gasEstimateCall && json?.[1]?.result) {
        gasEstimate = BigInt(json[1].result)
      }

      if (shouldFetchNonce) {
        subWallets.forEach((w, i) => {
          const old = nonces.current?.get(w.address) || { pendingtxs: [] }
          if (old.pendingtxs.length == 0) old.nonce = parseInt(json[i + (gasEstimateCall ? 2 : 1)].result, 16)
          nonces.current.set(w.address, old)
        })
      }

      [{ address: scaAddress }].concat(subWallets as any).forEach((wallet, walletIndex) => {
        const balanceMap: { [key: string]: bigint } = {};
        let totalValue = 0;
        tokenAddresses.forEach((tokenAddress, index) => {
          if (groupResults?.mainGroup?.[walletIndex]?.result?.[index]) {
            balanceMap[tokenAddress] = groupResults?.mainGroup?.[walletIndex]?.result?.[index] || 0n;

            try {
              const marketInfo = findMarketForToken(tokenAddress);
              if (marketInfo && marketInfo.trades) {
                const usdValue = calculateUSDValue(
                  groupResults?.mainGroup?.[walletIndex]?.result?.[index],
                  marketInfo.trades,
                  tokenAddress,
                  marketInfo.marketData
                );
                totalValue += usdValue;
              }
            } catch (error) {
              console.warn('Error calculating USD value for', tokenAddress, error);
            }
          }
          else {
            balanceMap[tokenAddress] = 0n;
          }
        });

        setWalletTokenBalances((prev: any) => ({
          ...prev,
          [wallet.address]: balanceMap
        }));
      })

      if (groupResults?.mainGroup?.at(-1)?.result) {
        const reservesData = groupResults?.mainGroup?.at(-1)?.result;
        setTokenData((prev: any) => ({
          ...prev, migrated: token.source === "nadfun" ? reservesData[2] : prev.migrated, reserveQuote: token.source === "nadfun" ? reservesData[0] : reservesData[0], reserveBase: token.source === "nadfun" ? reservesData[1] : reservesData[1], allowances: Object.fromEntries(
            [scaAddress, ...subWallets.map(w => w.address)].map((wallet, i) => [
              wallet.toLowerCase(),
              {
                allowance: reservesData[3][i] ?? 0n,
                nonce: reservesData[4][i] ?? 0n
              }
            ])
          )
        }));
      }
      return { readContractData: groupResults, gasEstimate: gasEstimate }
    },
    enabled: !!activeMarket && !!tokendict && !!markets,
    refetchInterval: ['board', 'spectra', 'meme'].includes(location.pathname.split('/')[1]) ? 800 : 5000,
    gcTime: 0,
  });

  const initialExplorerFilters = {
    ageMin: '', ageMax: '',
    holdersMin: '', holdersMax: '',
    proTradersMin: '', proTradersMax: '',
    top10HoldingMin: '', top10HoldingMax: '',
    devHoldingMin: '', devHoldingMax: '',
    sniperHoldingMin: '', sniperHoldingMax: '',
    insiderHoldingMin: '', insiderHoldingMax: '',
    marketCapMin: '', marketCapMax: '',
    volume24hMin: '', volume24hMax: '',
    globalFeesMin: '', globalFeesMax: '',
    buyTransactionsMin: '', buyTransactionsMax: '',
    sellTransactionsMin: '', sellTransactionsMax: '',
    priceMin: '', priceMax: '',
    searchKeywords: '',
    excludeKeywords: '',
    hasWebsite: false,
    hasTwitter: false,
    hasTelegram: false
  };

  const [explorerFiltersActiveTab, setExplorerFiltersActiveTab] = useState<'new' | 'graduating' | 'graduated'>(() => {
    const saved = localStorage.getItem('crystal_explorer_active_tab');
    return (saved as 'new' | 'graduating' | 'graduated') || 'new';
  });

  const [explorerFiltersActiveSection, setExplorerFiltersActiveSection] = useState<'audit' | 'metrics' | 'socials'>(() => {
    const saved = localStorage.getItem('crystal_explorer_active_section');
    return (saved as 'audit' | 'metrics' | 'socials') || 'audit';
  });

  const [explorerFilters, setExplorerFilters] = useState(() => {
    const saved = localStorage.getItem('crystal_explorer_filters');
    if (saved) {
      const parsed = JSON.parse(saved);
      // Handle migration from old single filter to per-tab filters
      if (!parsed.new && !parsed.graduating && !parsed.graduated) {
        return {
          new: parsed,
          graduating: initialExplorerFilters,
          graduated: initialExplorerFilters
        };
      }
      return parsed;
    }
    return {
      new: initialExplorerFilters,
      graduating: initialExplorerFilters,
      graduated: initialExplorerFilters
    };
  });

  const [appliedExplorerFilters, setAppliedExplorerFilters] = useState(() => {
    const saved = localStorage.getItem('crystal_applied_explorer_filters');
    if (saved) {
      const parsed = JSON.parse(saved);
      // Handle migration from old single filter to per-tab filters
      if (!parsed.new && !parsed.graduating && !parsed.graduated) {
        return {
          new: null,
          graduating: null,
          graduated: null
        };
      }
      return parsed;
    }
    return {
      new: null,
      graduating: null,
      graduated: null
    };
  });

  const handleOpenFiltersForColumn = useCallback((columnType: 'new' | 'graduating' | 'graduated') => {
    setExplorerFiltersActiveTab(columnType);
    localStorage.setItem('crystal_explorer_active_tab', columnType);
    setpopup(24);
  }, []);

  const handleExplorerFilterInputChange = useCallback((field: string, value: string | boolean) => {
    setExplorerFilters((prev: any) => {
      const updated = {
        ...prev,
        [explorerFiltersActiveTab]: {
          ...prev[explorerFiltersActiveTab],
          [field]: value
        }
      }
      localStorage.setItem('crystal_explorer_filters', JSON.stringify(updated));
      return updated;
    });
  }, [explorerFiltersActiveTab]);

  const handleExplorerFiltersReset = useCallback(() => {
    setExplorerFilters({
      new: initialExplorerFilters,
      graduating: initialExplorerFilters,
      graduated: initialExplorerFilters
    });
    localStorage.setItem('crystal_explorer_filters', JSON.stringify({
      new: initialExplorerFilters,
      graduating: initialExplorerFilters,
      graduated: initialExplorerFilters
    }));
    setAppliedExplorerFilters({
      new: null,
      graduating: null,
      graduated: null
    });
    localStorage.removeItem('crystal_applied_explorer_filters');
    setExplorerFiltersActiveTab('new');
    localStorage.setItem('crystal_explorer_active_tab', 'new');
    setExplorerFiltersActiveSection('audit');
    localStorage.setItem('crystal_explorer_active_section', 'audit');
    localStorage.removeItem('crystal_explorer_filters');
    localStorage.removeItem('crystal_applied_explorer_filters');
    localStorage.setItem('crystal_explorer_active_tab', 'new');
    localStorage.setItem('crystal_explorer_active_section', 'audit');
  }, []);

  const handleExplorerFiltersImport = useCallback(() => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const importedFilters = JSON.parse(e.target?.result as string);
            setExplorerFilters((prev: any) => {
              const updated = {
                ...prev,
                [explorerFiltersActiveTab]: importedFilters
              };
              localStorage.setItem('crystal_explorer_filters', JSON.stringify(updated));
              return updated;
            });
          } catch (error) {
            alert('Invalid JSON file');
          }
        };
        reader.readAsText(file);
      }
    };
    input.click();
  }, [explorerFiltersActiveTab]);

  const handleExplorerFiltersExport = useCallback(() => {
    const dataStr = JSON.stringify(explorerFilters[explorerFiltersActiveTab], null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `explorer-filters-${explorerFiltersActiveTab}.json`;
    link.click();
    URL.revokeObjectURL(url);
  }, [explorerFilters, explorerFiltersActiveTab]);

  const handleExplorerFiltersApply = useCallback(() => {
    const newAppliedFilters = { ...appliedExplorerFilters };
    (['new', 'graduating', 'graduated'] as const).forEach(tab => {
      const tabFilters = explorerFilters[tab];
      const hasActiveFilters = Object.values(tabFilters).some(value =>
        value !== '' && value !== false && value !== null && value !== undefined
      );

      newAppliedFilters[tab] = hasActiveFilters ? tabFilters : null;
    });
    const hasAnyFilters = Object.values(newAppliedFilters).some(tabFilters => tabFilters !== null);
    if (hasAnyFilters) {
      localStorage.setItem('crystal_applied_explorer_filters', JSON.stringify(newAppliedFilters));
    } else {
      localStorage.removeItem('crystal_applied_explorer_filters');
    }
    setAppliedExplorerFilters(newAppliedFilters);
    setpopup(0);
  }, [explorerFilters, appliedExplorerFilters]);

  const handleExplorerTabSwitch = useCallback((newTab: 'new' | 'graduating' | 'graduated') => {
    setExplorerFiltersActiveTab(newTab);
    localStorage.setItem('crystal_explorer_active_tab', newTab);
  }, []);

  const handleTokenClick = (token: any) => {
    if (setTokenData) {
      setTokenData(token);
    }
    navigate(`/meme/${token.id}`);
    setpopup(0);
  };

  const handleQuickBuy = useCallback(async (token: any, amt: string) => {
    const val = BigInt(amt || '0') * 10n ** 18n;
    if (val === 0n) return;

    const routerAddress = settings.chainConfig[activechain]?.launchpadRouter?.toLowerCase();
    if (!routerAddress) {
      console.error('Router address not found');
      return;
    }

    const txId = `quickbuy-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    try {
      if (showLoadingPopup) {
        showLoadingPopup(txId, {
          title: 'Sending transaction...',
          subtitle: `${amt} MON worth of ${token.symbol}`,
          amount: amt,
          amountUnit: 'MON',
          tokenImage: token.image
        });
      }

      const uo = {
        target: routerAddress,
        data: encodeFunctionData({
          abi: CrystalRouterAbi,
          functionName: 'buy',
          args: [true, token.id as `0x${string}`, val, 0n]
        }),
        value: val,
      };

      if (updatePopup) {
        updatePopup(txId, {
          title: 'Confirming transaction...',
          subtitle: `${amt} MON worth of ${token.symbol}`,
          variant: 'info',
          tokenImage: token.image
        });
      }

      await sendUserOperationAsync({ uo });

      if (terminalRefetch) {
        terminalRefetch();
      }

      if (updatePopup) {
        updatePopup(txId, {
          title: 'Quick Buy Complete',
          subtitle: `Successfully bought ${token.symbol} with ${amt} MON`,
          variant: 'success',
          confirmed: true,
          isLoading: false,
          tokenImage: token.image
        });
      }
    } catch (e: any) {
      console.error('Quick buy failed', e);
      const msg = String(e?.message ?? '');
      if (updatePopup) {
        updatePopup(txId, {
          title: msg.toLowerCase().includes('insufficient') ? 'Insufficient Balance' : 'Quick Buy Failed',
          subtitle: msg || 'Please try again.',
          variant: 'error',
          confirmed: true,
          isLoading: false,
          tokenImage: token.image
        });
      }
    }
  }, [sendUserOperationAsync, activechain, terminalRefetch]);

  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (!isVertDragging) return;

      e.preventDefault();
      e.stopPropagation();

      const mouseDeltaY = e.clientY - initialMousePosRef.current;
      const newHeight = Math.max(
        234,
        Math.min(450, initialHeightRef.current - mouseDeltaY),
      );

      setOrderCenterHeight(newHeight);
    };

    const handleMouseUp = (e: MouseEvent) => {
      if (!isVertDragging) return;

      e.preventDefault();
      e.stopPropagation();

      setIsVertDragging(false);
      document.body.style.cursor = '';
      document.body.style.userSelect = '';

      const overlay = document.getElementById('global-drag-overlay');
      if (overlay) {
        document.body.removeChild(overlay);
      }
    };

    if (isVertDragging) {
      const overlay = document.createElement('div');
      overlay.id = 'global-drag-overlay';
      overlay.style.position = 'fixed';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.zIndex = '9999';
      overlay.style.cursor = 'row-resize';
      document.body.appendChild(overlay);

      window.addEventListener('mousemove', handleMouseMove, { capture: true });
      window.addEventListener('mouseup', handleMouseUp, { capture: true });
    }

    return () => {
      window.removeEventListener('mousemove', handleMouseMove, {
        capture: true,
      });
      window.removeEventListener('mouseup', handleMouseUp, { capture: true });

      const overlay = document.getElementById('global-drag-overlay');
      if (overlay) {
        document.body.removeChild(overlay);
      }
    };
  }, [isVertDragging]);

  // auto resizer
  useEffect(() => {
    const handleResize = () => {
      if (window.innerHeight > 1080) {
        setOrderCenterHeight(367.58);
      } else if (window.innerHeight > 960) {
        setOrderCenterHeight(324.38);
      } else if (window.innerHeight > 840) {
        setOrderCenterHeight(282.18);
      } else if (window.innerHeight > 720) {
        setOrderCenterHeight(239.98);
      } else {
        setOrderCenterHeight(198.78);
      }
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  // dynamic title
  useEffect(() => {
    let title = 'Crystal | Decentralized Cryptocurrency Exchange';

    switch (true) {
      case location.pathname === '/portfolio':
        title = 'Portfolio | Crystal';
        break;
      case location.pathname === '/leaderboard':
        title = 'Leaderboard | Crystal';
        break;
      case location.pathname === '/launchpad':
        title = 'Launchpad | Crystal';
        break;
      case location.pathname === '/spectra':
        title = 'Spectra | Crystal';
        break;
      case location.pathname === '/trackers':
        title = 'Trackers | Crystal';
        break;
      case location.pathname === '/perps':
        title = 'Perpetuals | Crystal';
        break;
      case location.pathname.startsWith('/perps/'):
        if (perpsMarketsData && perpsActiveMarketKey) {
          const perpsMarket = perpsMarketsData[perpsActiveMarketKey];
          if (perpsMarket && perpsMarket.lastPrice) {
            const formattedPrice = formatSubscript(perpsMarket.lastPrice);
            title = `${formattedPrice} - ${perpsMarket.baseAsset} | Crystal`;
          } else {
            title = 'Perpetuals | Crystal';
          }
        } else {
          title = 'Perpetuals | Crystal';
        }
        break;
      case location.pathname.startsWith('/meme'):
        if (tokenData && tokenData.symbol && tokenData.price !== undefined) {
          title = `${formatUSDDisplay(tokenData.price * TOTAL_SUPPLY * monUsdPrice, true)?.slice(1)} - ${tokenData.symbol} | Crystal`;
        }
        break;
      case location.pathname.startsWith('/earn/vaults'):
        if (location.pathname === '/earn/vaults') {
          title = 'Vaults | Crystal';
        } else {
          const pathParts = location.pathname.split('/');
          if (pathParts.length >= 4) {
            const vaultAddress = pathParts[3];
            title = `Vault ${vaultAddress.slice(0, 8)}... | Crystal`;
          }
        }
        break;
      case location.pathname.startsWith('/earn'):
        if (location.pathname === '/earn' || location.pathname === '/earn/liquidity-pools') {
          title = 'Earn | Crystal';
        } else if (location.pathname.startsWith('/earn/liquidity-pools/')) {
          const pathParts = location.pathname.split('/');
          if (pathParts.length >= 4) {
            const poolIdentifier = pathParts[3];
            const [firstToken, secondToken] = poolIdentifier.split('-');
            title = `${firstToken.toUpperCase()}-${secondToken.toUpperCase()} Pool | Crystal`;
          }
        }
        break;
      case ['/swap', '/market', '/limit', '/send', '/scale'].includes(location.pathname):
        if (trades.length > 0) {
          const formattedPrice = formatSubscript(trades[0][1]);
          if (activeMarket.quoteAsset) {
            title = `${formattedPrice} - ${activeMarket.baseAsset + '/' + activeMarket.quoteAsset} | Crystal`;
          } else {
            title = `${location.pathname.slice(1).charAt(0).toUpperCase() + location.pathname.slice(2)} | Crystal`;
          }
        }
        break;
    }

    document.title = title;
  }, [trades, location.pathname, activeMarket, perpsMarketsData, perpsActiveMarketKey]);

  // process ob on orders or amountsquote change
  /* useEffect(() => {
    if (prevOrderData && Array.isArray(prevOrderData) && prevOrderData.length >= 4) {
      try {
        const buyOrdersRaw: bigint[] = [];
        const sellOrdersRaw: bigint[] = [];

        for (let i = 2; i < prevOrderData[4].length; i += 64) {
          const chunk = prevOrderData[4].slice(i, i + 64);
          buyOrdersRaw.push(BigInt(`0x${chunk}`));
        }

        for (let i = 2; i < prevOrderData[5].length; i += 64) {
          const chunk = prevOrderData[5].slice(i, i + 64);
          sellOrdersRaw.push(BigInt(`0x${chunk}`));
        }

        const {
          buyOrders: processedBuyOrders,
          sellOrders: processedSellOrders,
        } = processOrders(buyOrdersRaw, sellOrdersRaw);

        const { roundedOrders: roundedBuy, } =
          processOrdersForDisplay(
            processedBuyOrders,
            amountsQuote,
            processedBuyOrders?.[0]?.price && processedSellOrders?.[0]?.price ? (processedBuyOrders?.[0]?.price + processedSellOrders?.[0]?.price) / 2 : processedBuyOrders?.[0]?.price,
            orders,
            true,
          );
        const {
          roundedOrders: roundedSell,
        } = processOrdersForDisplay(
          processedSellOrders,
          amountsQuote,
          processedBuyOrders?.[0]?.price && processedSellOrders?.[0]?.price ? (processedBuyOrders?.[0]?.price + processedSellOrders?.[0]?.price) / 2 : processedSellOrders?.[0]?.price,
          orders,
          false,
        );

        if (prevAmountsQuote.current == amountsQuote) {
          const prevBuyMap = new Map(roundedBuyOrders?.orders?.map((o, i) => [`${o.price}_${o.size}`, i]));
          const prevSellMap = new Map(roundedSellOrders?.orders?.map((o, i) => [`${o.price}_${o.size}`, i]));

          for (let i = 0; i < roundedBuy.length; i++) {
            const prevIndex = prevBuyMap.get(`${roundedBuy[i].price}_${roundedBuy[i].size}`);
            if (prevIndex === undefined || (i === 0 && prevIndex !== 0)) {
              roundedBuy[i].shouldFlash = true;
            }
          }

          for (let i = 0; i < roundedSell.length; i++) {
            const prevIndex = prevSellMap.get(`${roundedSell[i].price}_${roundedSell[i].size}`);
            if (prevIndex === undefined || (i === 0 && prevIndex !== 0)) {
              roundedSell[i].shouldFlash = true;
            }
          }
        }

        const interval = localStorage.getItem(`${activeMarket.baseAsset}_ob_interval`)
          ? Number(
            localStorage.getItem(
              `${activeMarket.baseAsset}_ob_interval`,
            ),
          )
          : 1 / (activeMarket?.marketType != 0 && (Number(prevOrderData[0]) * Number(activeMarket.scaleFactor) / Number(prevOrderData[1]) / Number(activeMarket.priceFactor)) ? 10 ** Math.max(0, 5 - Math.floor(Math.log10((Number(prevOrderData[0]) * Number(activeMarket.scaleFactor) / Number(prevOrderData[1]) / Number(activeMarket.priceFactor)))) - 1) : Number(activeMarket.priceFactor))
        const { bids, asks } = v2ToOrderbook(prevOrderData[1], prevOrderData[0], Number(activeMarket.baseDecimals), Number(activeMarket.quoteDecimals), amountsQuote);

        setRoundedBuyOrders({ orders: roundedBuy.concat(bids as any), key: activeMarketKey, amountsQuote });
        setRoundedSellOrders({ orders: roundedSell.concat(asks as any), key: activeMarketKey, amountsQuote });
        prevAmountsQuote.current = amountsQuote
      } catch (error) {
        console.error(error);
      }
    }
  }, [amountsQuote, orders.length > 0]); */

  // process data
  /* useLayoutEffect(() => {
    const data = rpcQueryData?.readContractData?.mainGroup;
    const refData = rpcQueryData?.readContractData?.refGroup;
    const oneCTDepositData = rpcQueryData?.readContractData?.oneCTDepositGroup;
    if (!isLoading && data) {
      if (!txPending.current && !debounceTimerRef.current) {
        if (data?.[1]?.result != null) {
          setallowance(data[1].result);
        }
        let tempbalances = tokenBalances
        if (data?.[2]?.result || !address) {
          tempbalances = [...Object.values(tokendict), ...Object.values(markets)].reduce((acc, token, i) => {
            const balance = data[2].result?.[i] || BigInt(0);
            acc[token.address] = balance;
            return acc;
          }, {});
          if (stateloading || sliderPercent == 0) {
            const percentage = !tempbalances[tokenIn]
              ? 0
              : Math.min(
                100,
                Math.floor(
                  Number((amountIn * BigInt(100)) / tempbalances[tokenIn]),
                ),
              );
            setSliderPercent(percentage);
            const slider = document.querySelector('.balance-amount-slider');
            const popup = document.querySelector('.slider-percentage-popup');
            if (slider && popup) {
              const rect = slider.getBoundingClientRect();
              (popup as HTMLElement).style.left =
                `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
            }
          }
          setBalanceAddress(address);
          setTokenBalances(tempbalances);
        }
        if (tokenIn === eth && tokendict[tokenOut]?.lst && isStake) {
          setStateIsLoading(false);
          setstateloading(false);
          const stakeResult = data?.[5]?.result as bigint | undefined;
          if (stakeResult !== undefined && (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market')) {
            if (switched === false) {
              setamountOutSwap(stakeResult);
              setoutputString(
                stakeResult === 0n
                  ? ''
                  : customRound(
                    Number(stakeResult) /
                    10 ** Number(tokendict[tokenOut].decimals),
                    3,
                  ).toString(),
              );
            } else {
              setamountIn(stakeResult);
              setInputString(
                stakeResult === 0n
                  ? ''
                  : customRound(
                    Number(stakeResult) /
                    10 ** Number(tokendict[tokenIn].decimals),
                    3,
                  ).toString(),
              );
              const percentage = !tempbalances[tokenIn]
                ? 0
                : Math.min(
                  100,
                  Math.floor(
                    Number((stakeResult * BigInt(100)) / tempbalances[tokenIn]),
                  ),
                );
              setSliderPercent(percentage);
              const slider = document.querySelector('.balance-amount-slider');
              const popup = document.querySelector('.slider-percentage-popup');
              if (slider && popup) {
                const rect = slider.getBoundingClientRect();
                (popup as HTMLElement).style.left =
                  `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
              }
            }
          }
        } else if (data?.[0]?.result || (data?.[0]?.error == 'call reverted') || (data?.[0]?.error == 'param missing')) {
          setStateIsLoading(false);
          setstateloading(false);
          if (switched == false && !isWrap && (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market')) {
            const outputValue = BigInt(data[0].result?.at(-1) || BigInt(0));
            setamountOutSwap(outputValue);
            setoutputString(
              outputValue === BigInt(0)
                ? ''
                : parseFloat(
                  customRound(
                    Number(outputValue) /
                    10 ** Number(tokendict[tokenOut].decimals),
                    3,
                  ),
                ).toString(),
            );
          } else if (!isWrap && (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market')) {
            let inputValue;
            if (BigInt(data[0].result?.at(-1) || BigInt(0)) != amountOutSwap) {
              inputValue = BigInt(0);
            } else {
              inputValue = BigInt(data[0].result?.[0] || BigInt(0));
            }
            setamountIn(inputValue);
            setInputString(
              inputValue == BigInt(0)
                ? ''
                : parseFloat(
                  customRound(
                    Number(inputValue) /
                    10 ** Number(tokendict[tokenIn].decimals),
                    3,
                  ),
                ).toString(),
            );
            const percentage = !tempbalances[tokenIn]
              ? 0
              : Math.min(
                100,
                Math.floor(
                  Number((inputValue * BigInt(100)) / tempbalances[tokenIn]),
                ),
              );
            setSliderPercent(percentage);
            const slider = document.querySelector('.balance-amount-slider');
            const popup = document.querySelector('.slider-percentage-popup');
            if (slider && popup) {
              const rect = slider.getBoundingClientRect();
              (popup as HTMLElement).style.left =
                `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
            }
          }
        }
      }
      let tempmids = mids;
      if (data?.[4]?.result) {
        tempmids = Object.keys(markets).filter((key) => {
          return !(
            key.startsWith(wethticker) || key.endsWith(wethticker)
          );
        }).reduce(
          (acc, market, i) => {
            const prices = [
              (data as any)[4].result?.[2][i],
              (data as any)[4].result?.[3][i],
              (data as any)[4].result?.[4][i],
              (data as any)[4].result?.[0][i],
              (data as any)[4].result?.[1][i],
            ];
            acc[market] = prices;
            return acc;
          },
          {} as Record<string, any>,
        );
        setmids(tempmids);
      }
      if (data?.[3]?.result) {
        const orderdata = data[3].result;
        setReserveQuote(orderdata[0])
        setReserveBase(orderdata[1])
        let ammPrice = orderdata[1] == 0n ? 0 : ((BigInt(orderdata[0]) * activeMarket.scaleFactor * 9975n * 100000n + (BigInt(orderdata[1]) * 10000n * activeMarket.makerRebate - 1n)) / (BigInt(orderdata[1]) * 10000n * activeMarket.makerRebate));
        let temphighestBid = orderdata[2] < ammPrice ? ammPrice : orderdata[2]
        sethighestBid(temphighestBid || BigInt(0));
        temphighestBid = Number(temphighestBid);
        ammPrice = orderdata[1] == 0n ? Infinity : ((BigInt(orderdata[0]) * activeMarket.scaleFactor * 10000n * activeMarket.makerRebate) / (BigInt(orderdata[1]) * 9975n * 100000n));
        let templowestAsk = orderdata[3] > ammPrice ? ammPrice : orderdata[3]
        setlowestAsk(templowestAsk || BigInt(0));
        templowestAsk = Number(templowestAsk);
        setPrevOrderData(orderdata as any);
        if (orderdata && Array.isArray(orderdata) && orderdata.length >= 4 && !(orderdata[0] == prevOrderData[0] && orderdata[1] == prevOrderData[1] && orderdata[2] == prevOrderData[2] &&
          orderdata[3] == prevOrderData[3] &&
          orderdata[4]?.toLowerCase() == prevOrderData[4]?.toLowerCase() &&
          orderdata[5]?.toLowerCase() == prevOrderData[5]?.toLowerCase())) {
          try {
            const buyOrdersRaw: bigint[] = [];
            const sellOrdersRaw: bigint[] = [];

            for (let i = 2; i < orderdata[4].length; i += 64) {
              const chunk = orderdata[4].slice(i, i + 64);
              buyOrdersRaw.push(BigInt(`0x${chunk}`));
            }

            for (let i = 2; i < orderdata[5].length; i += 64) {
              const chunk = orderdata[5].slice(i, i + 64);
              sellOrdersRaw.push(BigInt(`0x${chunk}`));
            }

            const {
              buyOrders: processedBuyOrders,
              sellOrders: processedSellOrders,
            } = processOrders(buyOrdersRaw, sellOrdersRaw);

            const { roundedOrders: roundedBuy, defaultOrders: liquidityBuy } =
              processOrdersForDisplay(
                processedBuyOrders,
                amountsQuote,
                processedBuyOrders?.[0]?.price && processedSellOrders?.[0]?.price ? (processedBuyOrders?.[0]?.price + processedSellOrders?.[0]?.price) / 2 : processedBuyOrders?.[0]?.price,
                orders,
                true,
              );
            const {
              roundedOrders: roundedSell,
              defaultOrders: liquiditySell,
            } = processOrdersForDisplay(
              processedSellOrders,
              amountsQuote,
              processedBuyOrders?.[0]?.price && processedSellOrders?.[0]?.price ? (processedBuyOrders?.[0]?.price + processedSellOrders?.[0]?.price) / 2 : processedSellOrders?.[0]?.price,
              orders,
              false,
            );

            if (temphighestBid == 0 && templowestAsk != Number(activeMarket.maxPrice)) {
              temphighestBid = templowestAsk
            }
            else if (templowestAsk == Number(activeMarket.maxPrice) && temphighestBid != 0) {
              templowestAsk = temphighestBid
            }
            temphighestBid /= Number(activeMarket.priceFactor)
            templowestAsk /= Number(activeMarket.priceFactor)

            const spread = {
              spread:
                temphighestBid !== undefined && templowestAsk !== undefined
                  ? templowestAsk - temphighestBid
                  : NaN,
              averagePrice:
                temphighestBid !== undefined && templowestAsk !== undefined
                  ? ((temphighestBid + templowestAsk) / 2) : NaN,
            };

            const prevBuyMap = new Map(roundedBuyOrders?.orders?.map((o, i) => [`${o.price}_${o.size}`, i]));
            const prevSellMap = new Map(roundedSellOrders?.orders?.map((o, i) => [`${o.price}_${o.size}`, i]));

            for (let i = 0; i < roundedBuy.length; i++) {
              const prevIndex = prevBuyMap.get(`${roundedBuy[i].price}_${roundedBuy[i].size}`);
              if (prevIndex === undefined || (i === 0 && prevIndex !== 0)) {
                roundedBuy[i].shouldFlash = true;
              }
            }

            for (let i = 0; i < roundedSell.length; i++) {
              const prevIndex = prevSellMap.get(`${roundedSell[i].price}_${roundedSell[i].size}`);
              if (prevIndex === undefined || (i === 0 && prevIndex !== 0)) {
                roundedSell[i].shouldFlash = true;
              }
            }

            const interval = localStorage.getItem(`${activeMarket.baseAsset}_ob_interval`)
              ? Number(
                localStorage.getItem(
                  `${activeMarket.baseAsset}_ob_interval`,
                ),
              )
              : 1 / (activeMarket?.marketType != 0 && spread?.averagePrice ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(spread?.averagePrice ?? 1)) - 1) : Number(activeMarket.priceFactor))

            const { bids, asks } = v2ToOrderbook(orderdata[1], orderdata[0], Number(activeMarket.baseDecimals), Number(activeMarket.quoteDecimals), amountsQuote);

            setSpreadData({ spread: `${((spread?.spread / spread?.averagePrice) * 100).toFixed(2)}%`, averagePrice: formatSubscript(formatSig(spread?.averagePrice.toFixed(Math.floor(Math.log10(Number(activeMarket.priceFactor)))), activeMarket?.marketType != 0)) });
            setRoundedBuyOrders({ orders: roundedBuy.concat(bids as any), key: activeMarketKey, amountsQuote });
            setRoundedSellOrders({ orders: roundedSell.concat(asks as any), key: activeMarketKey, amountsQuote });
            setLiquidityBuyOrders({ orders: liquidityBuy, market: activeMarket.address });
            setLiquiditySellOrders({ orders: liquiditySell, market: activeMarket.address });
            setBaseInterval(1 / (activeMarket?.marketType != 0 && spread?.averagePrice ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(spread?.averagePrice ?? 1)) - 1) : Number(activeMarket.priceFactor)));
            setOBInterval(interval);
          } catch (error) {
            console.error(error);
          }
        }
      }
      if (refData && Object.keys(tempmids).length > 0) {
        setUsedRefAddress(
          refData[0]?.result?.[0] as any || '0x0000000000000000000000000000000000000000',
        );
        setUsedRefLink(refData[0]?.result?.[1]);
        setRefLink(refData[0]?.result?.[2]);
        setClaimableFees(() => {
          let newFees = {};
          let totalFees = 0;
          Array.from(
            Object.values(tokendict).reduce((acc, market: any) => {
              if (!acc.has(market.address)) acc.set(market.address, market);
              return acc;
            }, new Map<string, any>()).values()
          ).forEach((token: any, index) => {
            if (
              tempmids !== null &&
              token !== null
            ) {
              const quoteIndex = index;
              const quotePrice = token.ticker == 'USDC' ? 1 : Number(tempmids[(token.ticker == wethticker ? ethticker : token.ticker) + 'USDC']?.[0])
                / Number(markets[(token.ticker == wethticker ? ethticker : token.ticker) + 'USDC']?.priceFactor)
              if (Number(refData[quoteIndex + 1]?.result) > 0) {
                if (!(newFees as any)[token.address]) {
                  (newFees as any)[token.address] =
                    Number(refData[quoteIndex + 1].result) /
                    10 ** Number(token.decimals);
                  totalFees +=
                    Number(refData[quoteIndex + 1].result) * quotePrice /
                    10 ** Number(token.decimals);
                } else {
                  (newFees as any)[token.address] +=
                    Number(refData[quoteIndex + 1].result) /
                    10 ** Number(token.decimals);
                  totalFees +=
                    Number(refData[quoteIndex + 1].result) * quotePrice /
                    10 ** Number(token.decimals);
                }
              }
            }
          });
          setTotalClaimableFees(totalFees || 0);
          return newFees;
        });
      }
      if (oneCTDepositData?.[0]?.result || !scaAddress) {
        let tempbalances = mainWalletBalances;
        tempbalances = Object.values(tokendict).reduce((acc, token, i) => {
          const balance = oneCTDepositData?.[0]?.result?.[i] || BigInt(0);
          acc[token.address] = balance;
          return acc;
        }, {});
        setMainWalletBalances(tempbalances);
      }
    } else {
    }
  }, [rpcQueryData?.readContractData, activechain, isLoading, dataUpdatedAt, location.pathname.slice(1)]); */

  // update display values when loading is finished
  /* useLayoutEffect(() => {
    if (!isLoading && !stateIsLoading && Object.keys(mids).length > 0) {
      setDisplayValuesLoading(false);
      if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
        let estPrice = multihop
          ? (Number(amountIn) * 100000) /
          Number(activeMarket.fee) /
          10 ** Number(tokendict[tokenIn].decimals) /
          (Number(amountOutSwap) /
            10 ** Number(tokendict[tokenOut].decimals)) ||
          (() => {
            let price = 1;
            let mid;
            for (let i = 0; i < activeMarket.path.length - 1; i++) {
              let market = getMarket(
                activeMarket.path[i],
                activeMarket.path[i + 1],
              );
              if (activeMarket.path[i] == market.quoteAddress) {
                mid = Number(mids[(market.baseAsset + market.quoteAsset).replace(
                  new RegExp(
                    `^${wethticker}|${wethticker}$`,
                    'g'
                  ),
                  ethticker
                )][2]);
                price *= mid / Number(market.priceFactor);
              } else {
                mid = Number(mids[(market.baseAsset + market.quoteAsset).replace(
                  new RegExp(
                    `^${wethticker}|${wethticker}$`,
                    'g'
                  ),
                  ethticker
                )][1]);
                price /= mid / Number(market.priceFactor);
              }
            }
            return price;
          })()
          : amountIn != BigInt(0) && amountOutSwap != BigInt(0)
            ? Number(
              tokenIn == activeMarket.quoteAddress
                ? amountIn
                : (Number(amountOutSwap) * 100000) / Number(activeMarket.fee),
            ) /
            10 ** Number(tokendict[activeMarket.quoteAddress].decimals) /
            (Number(
              tokenIn == activeMarket.quoteAddress
                ? (Number(amountOutSwap) * 100000) / Number(activeMarket.fee)
                : amountIn,
            ) /
              10 ** Number(tokendict[activeMarket.baseAddress].decimals))
            : (tokenIn == activeMarket.quoteAddress
              ? Number(lowestAsk)
              : Number(highestBid)) / Number(activeMarket.priceFactor);
        setAveragePrice(
          multihop
            ? `${customRound(estPrice, 2)}`
            : `${formatSubscript(formatSig(estPrice.toFixed(Math.floor(Math.log10(Number(activeMarket.priceFactor)))), activeMarket?.marketType != 0))}`,
        );
        setPriceImpact(() => {
          let temppriceimpact;
          if (multihop) {
            let price = 1;
            let mid;
            for (let i = 0; i < activeMarket.path.length - 1; i++) {
              let market = getMarket(
                activeMarket.path[i],
                activeMarket.path[i + 1],
              );
              mid = Number(mids[(market.baseAsset + market.quoteAsset).replace(
                new RegExp(
                  `^${wethticker}|${wethticker}$`,
                  'g'
                ),
                ethticker
              )][0]);
              if (activeMarket.path[i] == market.quoteAddress) {
                price *= mid / Number(market.priceFactor);
              } else {
                price /= mid / Number(market.priceFactor);
              }
            }
            temppriceimpact = `${customRound(
              0.001 > Math.abs(((estPrice - price) / price) * 100)
                ? 0
                : Math.abs(((estPrice - price) / price) * 100),
              3,
            )}%`;
          } else {
            temppriceimpact = `${customRound(
              0.001 >
                Math.abs(
                  ((estPrice -
                    (tokenIn == activeMarket.quoteAddress
                      ? Number(lowestAsk) / Number(activeMarket.priceFactor)
                      : Number(highestBid) / Number(activeMarket.priceFactor))) /
                    (tokenIn == activeMarket.quoteAddress
                      ? Number(lowestAsk) / Number(activeMarket.priceFactor)
                      : Number(highestBid) / Number(activeMarket.priceFactor))) *
                  100,
                )
                ? 0
                : Math.abs(
                  ((estPrice -
                    (tokenIn == activeMarket.quoteAddress
                      ? Number(lowestAsk) / Number(activeMarket.priceFactor)
                      : Number(highestBid) /
                      Number(activeMarket.priceFactor))) /
                    (tokenIn == activeMarket.quoteAddress
                      ? Number(lowestAsk) / Number(activeMarket.priceFactor)
                      : Number(highestBid) /
                      Number(activeMarket.priceFactor))) *
                  100,
                ),
              3,
            )}%`;
          }
          setSwapButtonDisabled(
            (amountIn === BigInt(0) ||
              amountIn > tokenBalances[tokenIn] ||
              ((orderType == 1 || multihop) &&
                !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) &&
                rpcQueryData?.readContractData?.mainGroup?.[0].result?.at(0) == undefined)) &&
            connected &&
            userchain == activechain,
          );
          setSwapButton(
            connected && userchain == activechain
              ? (switched &&
                amountOutSwap != BigInt(0) &&
                amountIn == BigInt(0)) ||
                ((orderType == 1 || multihop) &&
                  !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) &&
                  rpcQueryData?.readContractData?.mainGroup?.[0].result?.at(0) == undefined)
                ? 0
                : amountIn === BigInt(0)
                  ? 1
                  : amountIn <= tokenBalances[tokenIn]
                    ? allowance < amountIn && tokenIn != eth && !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake)
                      ? 6
                      : 2
                    : 3
              : connected
                ? 4
                : 5,
          );
          setwarning(
            !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) &&
              ((amountIn == BigInt(0) && amountOutSwap != BigInt(0)) ||
                ((orderType == 1 || multihop) &&
                  rpcQueryData?.readContractData?.mainGroup?.[0].result?.at(0) == undefined))
              ? multihop
                ? 3
                : 2
              : parseFloat(temppriceimpact.slice(0, -1)) > 5 &&
                !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) &&
                (orderType != 0 || (slippage < BigInt(9500))) &&
                !isLoading &&
                !stateIsLoading
                ? 1
                : 0,
          );
          return temppriceimpact == 'NaN%' ? '0%' : temppriceimpact;
        });
        setTradeFee(
          `${(Number(amountIn) * (100000 - Number(activeMarket.fee))) /
            100000 /
            10 ** Number(tokendict[tokenIn].decimals) >
            0.0001
            ? customRound(
              (Number(amountIn) * (100000 - Number(activeMarket.fee))) /
              100000 /
              10 ** Number(tokendict[tokenIn].decimals),
              2,
            )
            : (Number(amountIn) * (100000 - Number(activeMarket.fee))) /
              100000 /
              10 ** Number(tokendict[tokenIn].decimals) ==
              0
              ? '0'
              : '<0.0001'
          } ${tokendict[tokenIn].ticker}`,
        );
      }
      setLimitButtonDisabled(
        (amountIn === BigInt(0) ||
          limitPrice == BigInt(0) ||
          (tokenIn == activeMarket.quoteAddress
            ? amountIn < activeMarket.minSize
            : (amountIn * limitPrice) / activeMarket.scaleFactor <
            activeMarket.minSize) ||
          amountIn > tokenBalances[tokenIn] ||
          (addliquidityonly &&
            ((limitPrice >= lowestAsk &&
              tokenIn == activeMarket.quoteAddress) ||
              (limitPrice <= highestBid &&
                tokenIn == activeMarket.baseAddress)))) &&
        connected &&
        userchain == activechain,
      );
      setLimitButton(
        connected && userchain == activechain
          ? amountIn === BigInt(0)
            ? 0
            : limitPrice == BigInt(0)
              ? 1
              : amountIn <= tokenBalances[tokenIn]
                ? addliquidityonly &&
                  ((limitPrice >= lowestAsk &&
                    tokenIn == activeMarket.quoteAddress) ||
                    (limitPrice <= highestBid &&
                      tokenIn == activeMarket.baseAddress))
                  ? tokenIn == activeMarket.quoteAddress
                    ? 2
                    : 3
                  : (
                    tokenIn == activeMarket.quoteAddress
                      ? amountIn < activeMarket.minSize
                      : (amountIn * limitPrice) /
                      activeMarket.scaleFactor <
                      activeMarket.minSize
                  )
                    ? 4
                    : allowance < amountIn && tokenIn != eth
                      ? 9
                      : 5
                : 6
          : connected
            ? 7
            : 8,
      );
      setSendButtonDisabled(
        (amountIn === BigInt(0) ||
          amountIn > tokenBalances[tokenIn] ||
          !/^(0x[0-9a-fA-F]{40})$/.test(recipient)) &&
        connected &&
        userchain == activechain,
      );
      setSendButton(
        connected && userchain == activechain
          ? amountIn === BigInt(0)
            ? 0
            : !/^(0x[0-9a-fA-F]{40})$/.test(recipient)
              ? 1
              : amountIn <= tokenBalances[tokenIn]
                ? 2
                : 3
          : connected
            ? 4
            : 5,
      );
      setSendPopupButtonDisabled(
        (sendAmountIn === BigInt(0) ||
          sendAmountIn > tokenBalances[sendTokenIn] ||
          !/^(0x[0-9a-fA-F]{40})$/.test(recipient)) &&
        connected &&
        userchain == activechain,
      );
      setSendPopupButton(
        connected && userchain == activechain
          ? sendAmountIn === BigInt(0)
            ? 0
            : !/^(0x[0-9a-fA-F]{40})$/.test(recipient)
              ? 1
              : sendAmountIn <= tokenBalances[sendTokenIn]
                ? 2
                : 3
          : connected
            ? 4
            : 5,
      );
      setScaleButtonDisabled(
        (amountIn === BigInt(0) ||
          scaleStart == BigInt(0) || scaleEnd == BigInt(0) || scaleOrders == BigInt(0) || scaleOrders == BigInt(1) || scaleSkew == 0 ||
          calculateScaleOutput(
            amountIn,
            Number(scaleStart),
            Number(scaleEnd),
            Number(scaleOrders || 2),
            Number(scaleSkew)
          ).some((order) => order[2] < activeMarket.minSize) ||
          amountIn > tokenBalances[tokenIn] ||
          (
            ((scaleStart >= lowestAsk &&
              tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
              (scaleStart <= highestBid &&
                tokenIn == activeMarket.baseAddress && (addliquidityonly)) || (scaleEnd >= lowestAsk &&
                  tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
              (scaleEnd <= highestBid &&
                tokenIn == activeMarket.baseAddress && (addliquidityonly))))) &&
        connected &&
        userchain == activechain,
      );
      setScaleButton(
        connected && userchain == activechain
          ? amountIn === BigInt(0)
            ? 0
            : scaleStart == BigInt(0)
              ? 1 : scaleEnd == BigInt(0) ? 2
                : amountIn <= tokenBalances[tokenIn]
                  ? ((scaleStart >= lowestAsk &&
                    tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
                    (scaleStart <= highestBid &&
                      tokenIn == activeMarket.baseAddress && (addliquidityonly)))
                    ? tokenIn == activeMarket.quoteAddress
                      ? 3
                      : 4 : ((scaleEnd >= lowestAsk &&
                        tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
                        (scaleEnd <= highestBid &&
                          tokenIn == activeMarket.baseAddress && (addliquidityonly)))
                      ? tokenIn == activeMarket.quoteAddress
                        ? 5
                        : 6
                      : (
                        calculateScaleOutput(
                          amountIn,
                          Number(scaleStart),
                          Number(scaleEnd),
                          Number(scaleOrders || 2),
                          Number(scaleSkew)
                        ).some((order) => order[2] < activeMarket.minSize)
                      ) ? 7 : scaleOrders <= BigInt(1) ? 8 : scaleSkew == 0 ? 9
                        : allowance < amountIn && tokenIn != eth
                          ? 13
                          : 14
                  : 10
          : connected
            ? 11
            : 12,
      );
    } else if (stateIsLoading && !isWrap) {
      setDisplayValuesLoading(true);
    }
  }, [
    isLoading,
    stateIsLoading,
    amountIn,
    amountOutSwap,
    tokenIn,
    tokenOut,
    activechain,
    isWrap,
    addliquidityonly,
    limitPrice,
    highestBid,
    lowestAsk,
    activeMarket.quoteAddress,
    activeMarket.baseAddress,
    orderType,
    slippage,
    connected,
    userchain,
    tokenBalances[tokenIn],
    multihop,
    recipient,
    mids,
    scaleStart,
    scaleEnd,
    scaleOrders,
    scaleSkew,
  ]); */

  // temp vars
  const refetch = () => { };
  const isLoading = false;
  const rpcQueryData = { gasEstimate: 0n };
  const tempsendPopupButton = connected && userchain == activechain
    ? sendAmountIn === BigInt(0)
      ? 0
      : !/^(0x[0-9a-fA-F]{40})$/.test(recipient)
        ? 1
        : sendAmountIn <= walletTokenBalances[address]?.[sendTokenIn]
          ? 2
          : 3
    : connected
      ? 4
      : 5

  // // trades processing
  // useEffect(() => {
  //   const temp: Trade[] | undefined = tradesByMarket[activeMarketKey];

  //   let processed: [boolean, string, string, string, string][] = [];

  //   if (temp) {
  //     processed = temp.slice(0, 100).map((trade: Trade) => {
  //       const isBuy = trade[2] === 1;
  //       const tradeValue = (trade[2] === 1 ? trade[1] : trade[0]) / 10 ** Number(activeMarket.baseDecimals);
  //       const price = trade[3] / Number(activeMarket.priceFactor) || 0;
  //       const time = formatTime(trade[6]);
  //       const hash = trade[5];
  //       return [
  //         isBuy,
  //         formatSubscript(formatSig(
  //           price.toFixed(Math.floor(Math.log10(Number(activeMarket.priceFactor)))), activeMarket.marketType != 0
  //         )),
  //         formatSubscript(customRound(tradeValue, 3)),
  //         time,
  //         hash,
  //       ];
  //     });
  //   }

  //   setTrades(processed);
  // }, [tradesByMarket?.[activeMarketKey]?.[0]])

  // // fetch initial address info and event stream
  // useEffect(() => {
  //   let liveStreamCancelled = false;
  //   let isAddressInfoFetching = false;
  //   let startBlockNumber = '';
  //   let endBlockNumber = '';

  //   const fetchData = async () => {
  //     try {
  //       const req = await fetch(HTTP_URL, {
  //         method: 'POST',
  //         headers: {
  //           'Content-Type': 'application/json',
  //         },
  //         body: JSON.stringify([{
  //           jsonrpc: '2.0',
  //           id: 0,
  //           method: 'eth_blockNumber',
  //         }, {
  //           jsonrpc: '2.0',
  //           id: 0,
  //           method: 'eth_getLogs',
  //           params: [
  //             {
  //               fromBlock: startBlockNumber,
  //               toBlock: endBlockNumber,
  //               address: router,
  //               topics: [
  //                 '0x9adcf0ad0cda63c4d50f26a48925cf6405df27d422a39c456b5f03f661c82982',
  //               ],
  //             },
  //           ],
  //         }, ...(address?.slice(2) ? [{
  //           jsonrpc: '2.0',
  //           id: 0,
  //           method: 'eth_getLogs',
  //           params: [
  //             {
  //               fromBlock: startBlockNumber,
  //               toBlock: endBlockNumber,
  //               address: router,
  //               topics: [
  //                 '0x7ebb55d14fb18179d0ee498ab0f21c070fad7368e44487d51cdac53d6f74812c',
  //                 null,
  //                 '0x000000000000000000000000' + address?.slice(2),
  //               ],
  //             },
  //           ],
  //         }] : [])]),
  //       });
  //       const result = await req.json();
  //       if (liveStreamCancelled) return;
  //       startBlockNumber = '0x' + (parseInt(result[0].result, 16) - 30).toString(16);
  //       endBlockNumber = '0x' + (parseInt(result[0].result, 16) + 10).toString(16);
  //       const tradelogs = result[1].result;
  //       const orderlogs = result?.[2]?.result;
  //       const filllogs = result?.[3]?.result;
  //       let ordersChanged = false;
  //       let canceledOrdersChanged = false;
  //       let tradesByMarketChanged = false;
  //       let tradeHistoryChanged = false;
  //       let temporders: any;
  //       let tempcanceledorders: any;
  //       let temptradesByMarket: any;
  //       let temptradehistory: any;
  //       setorders((orders) => {
  //         temporders = [...orders];
  //         return orders;
  //       })
  //       setcanceledorders((canceledorders) => {
  //         tempcanceledorders = [...canceledorders];
  //         return canceledorders;
  //       })
  //       settradesByMarket((tradesByMarket: any) => {
  //         temptradesByMarket = { ...tradesByMarket };
  //         return tradesByMarket;
  //       })
  //       settradehistory((tradehistory: any) => {
  //         temptradehistory = [...tradehistory];
  //         return tradehistory;
  //       })
  //       setProcessedLogs(prev => {
  //         let tempset = new Set(prev);
  //         let temptrades: any = {};
  //         if (Array.isArray(tradelogs)) {
  //           for (const log of tradelogs) {
  //             const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
  //             const marketKey = addresstoMarket['0x' + log['topics'][1].slice(26)];
  //             if (!tempset.has(logIdentifier) && marketKey && !temptradesByMarket[marketKey]?.some((trade: any) =>
  //               trade[0] == parseInt(log['data'].slice(66, 130), 16) &&
  //               trade[1] == parseInt(log['data'].slice(130, 194), 16) &&
  //               trade[5] == log['transactionHash'])) {
  //               if (tempset.size >= 10000) {
  //                 const first = tempset.values().next().value;
  //                 if (first !== undefined) {
  //                   tempset.delete(first);
  //                 }
  //               }
  //               tempset.add(logIdentifier);
  //               const resolve = txReceiptResolvers.current.get(log['transactionHash']);
  //               if (resolve) {
  //                 resolve();
  //                 txReceiptResolvers.current.delete(log['transactionHash']);
  //               }
  //               let _timestamp = parseInt(log['blockTimestamp'], 16);
  //               let _orderdata = log['data'].slice(258);
  //               for (let i = 0; i < _orderdata.length; i += 64) {
  //                 let chunk = _orderdata.slice(i, i + 64);
  //                 let price = parseInt(chunk.slice(1, 20), 16);
  //                 let id = parseInt(chunk.slice(20, 32), 16);
  //                 let size = parseInt(chunk.slice(32, 64), 16);
  //                 let orderIndex = temporders.findIndex(
  //                   (sublist: any) =>
  //                     sublist[0] ==
  //                     price &&
  //                     sublist[1] ==
  //                     id &&
  //                     sublist[4] == marketKey,
  //                 );
  //                 let canceledOrderIndex = tempcanceledorders.findIndex(
  //                   (sublist: any) =>
  //                     sublist[0] ==
  //                     price &&
  //                     sublist[1] ==
  //                     id &&
  //                     sublist[4] == marketKey,
  //                 );
  //                 if (orderIndex != -1 && canceledOrderIndex != -1) {
  //                   ordersChanged = true;
  //                   canceledOrdersChanged = true;
  //                   temporders[orderIndex] = [...temporders[orderIndex]]
  //                   tempcanceledorders[canceledOrderIndex] = [...tempcanceledorders[canceledOrderIndex]]
  //                   let order = [...temporders[orderIndex]];
  //                   let buy = order[3];
  //                   let quoteasset =
  //                     markets[marketKey]
  //                       .quoteAddress;
  //                   let baseasset =
  //                     markets[marketKey]
  //                       .baseAddress;
  //                   let amountquote = (
  //                     ((order[2] - order[7] - size / order[0]) *
  //                       order[0]) /
  //                     (Number(
  //                       markets[marketKey]
  //                         .scaleFactor,
  //                     ) *
  //                       10 **
  //                       Number(
  //                         markets[marketKey]
  //                           .quoteDecimals,
  //                       ))
  //                   ).toFixed(2);
  //                   let amountbase = customRound(
  //                     (order[2] - order[7] - size / order[0]) /
  //                     10 **
  //                     Number(
  //                       markets[marketKey]
  //                         .baseDecimals,
  //                     ),
  //                     3,
  //                   );
  //                   newTxPopup(
  //                     log['transactionHash'],
  //                     'fill',
  //                     buy ? quoteasset : baseasset,
  //                     buy ? baseasset : quoteasset,
  //                     buy ? amountquote : amountbase,
  //                     buy ? amountbase : amountquote,
  //                     `${order[0] / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
  //                     '',
  //                   );
  //                   if (size == 0) {
  //                     tradeHistoryChanged = true;
  //                     temptradehistory.push([
  //                       order[3] == 1
  //                         ? (order[2] * order[0]) /
  //                         Number(markets[order[4]].scaleFactor)
  //                         : order[2],
  //                       order[3] == 1
  //                         ? order[2]
  //                         : (order[2] * order[0]) /
  //                         Number(markets[order[4]].scaleFactor),
  //                       order[3],
  //                       order[0],
  //                       order[4],
  //                       order[5],
  //                       _timestamp,
  //                       0,
  //                     ]);
  //                     if (temporders[orderIndex]?.[10] && typeof temporders[orderIndex][10].remove === 'function') {
  //                       try {
  //                         temporders[orderIndex][10].remove();
  //                       }
  //                       catch { }
  //                       temporders[orderIndex].splice(10, 1)
  //                     }
  //                     temporders.splice(orderIndex, 1);
  //                     tempcanceledorders[canceledOrderIndex][9] =
  //                       1;
  //                     tempcanceledorders[canceledOrderIndex][7] = order[2]
  //                     tempcanceledorders[canceledOrderIndex][8] = order[8];
  //                   } else {
  //                     if (temporders[orderIndex]?.[10] && typeof temporders[orderIndex][10].setQuantity === 'function') {
  //                       try {
  //                         temporders[orderIndex][10].setQuantity(formatDisplay(customRound((size / order[0]) / 10 ** Number(markets[order[4]].baseDecimals), 3)))
  //                       }
  //                       catch { }
  //                     }
  //                     temporders[orderIndex][7] =
  //                       order[2] - size / order[0];
  //                     tempcanceledorders[canceledOrderIndex][7] =
  //                       order[2] - size / order[0];
  //                   }
  //                 }
  //               }
  //               tradesByMarketChanged = true;
  //               if (!Array.isArray(temptradesByMarket[marketKey])) {
  //                 temptradesByMarket[marketKey] = [];
  //               }
  //               let amountIn = parseInt(log['data'].slice(66, 130), 16);
  //               let amountOut = parseInt(log['data'].slice(130, 194), 16);
  //               let buy = parseInt(log['data'].slice(65, 66), 16);
  //               let price = parseInt(log['data'].slice(258, 322), 16);
  //               temptradesByMarket[marketKey].unshift([
  //                 amountIn,
  //                 amountOut,
  //                 buy,
  //                 price,
  //                 marketKey,
  //                 log['transactionHash'],
  //                 _timestamp,
  //               ]);
  //               if (!Array.isArray(temptrades[marketKey])) {
  //                 temptrades[marketKey] = [];
  //               }
  //               temptrades[marketKey].unshift([
  //                 amountIn,
  //                 amountOut,
  //                 buy,
  //                 price,
  //                 marketKey,
  //                 log['transactionHash'],
  //                 _timestamp,
  //                 parseInt(log['data'].slice(194, 258), 16),
  //               ])
  //               if (
  //                 log['topics'][2].slice(26) ==
  //                 address?.slice(2).toLowerCase()
  //               ) {
  //                 tradeHistoryChanged = true;
  //                 temptradehistory.push([
  //                   amountIn,
  //                   amountOut,
  //                   buy,
  //                   price,
  //                   marketKey,
  //                   log['transactionHash'],
  //                   _timestamp,
  //                   1,
  //                 ])
  //                 let quoteasset =
  //                   markets[marketKey].quoteAddress;
  //                 let baseasset =
  //                   markets[marketKey].baseAddress;
  //                 let popupAmountIn = customRound(
  //                   amountIn /
  //                   10 **
  //                   Number(
  //                     buy
  //                       ? markets[marketKey]
  //                         .quoteDecimals
  //                       : markets[marketKey]
  //                         .baseDecimals,
  //                   ),
  //                   3,
  //                 );
  //                 let popupAmountOut = customRound(
  //                   amountOut /
  //                   10 **
  //                   Number(
  //                     buy
  //                       ? markets[marketKey]
  //                         .baseDecimals
  //                       : markets[marketKey]
  //                         .quoteDecimals,
  //                   ),
  //                   3,
  //                 );
  //                 newTxPopup(
  //                   log['transactionHash'],
  //                   'swap',
  //                   buy ? quoteasset : baseasset,
  //                   buy ? baseasset : quoteasset,
  //                   popupAmountIn,
  //                   popupAmountOut,
  //                   '',
  //                   '',
  //                 );
  //               }
  //             }
  //           }
  //           if (tradesByMarketChanged) {
  //             setChartData(([existingBars, existingIntervalLabel, existingShowOutliers]) => {
  //               const marketKey = existingIntervalLabel?.match(/^\D*/)?.[0];
  //               const updatedBars = [...existingBars];
  //               let rawVolume;
  //               if (marketKey && Array.isArray(temptrades?.[marketKey])) {
  //                 const barSizeSec =
  //                   existingIntervalLabel?.match(/\d.*/)?.[0] === '1' ? 60 :
  //                     existingIntervalLabel?.match(/\d.*/)?.[0] === '5' ? 5 * 60 :
  //                       existingIntervalLabel?.match(/\d.*/)?.[0] === '15' ? 15 * 60 :
  //                         existingIntervalLabel?.match(/\d.*/)?.[0] === '30' ? 30 * 60 :
  //                           existingIntervalLabel?.match(/\d.*/)?.[0] === '60' ? 60 * 60 :
  //                             existingIntervalLabel?.match(/\d.*/)?.[0] === '240' ? 4 * 60 * 60 :
  //                               existingIntervalLabel?.match(/\d.*/)?.[0] === '1D' ? 24 * 60 * 60 :
  //                                 5 * 60;
  //                 const priceFactor = Number(markets[marketKey].priceFactor);
  //                 for (const lastTrade of temptrades[marketKey]) {
  //                   const lastBarIndex = updatedBars.length - 1;
  //                   const lastBar = updatedBars[lastBarIndex];

  //                   let openPrice = parseFloat((lastTrade[7] / priceFactor).toFixed(Math.floor(Math.log10(priceFactor))));
  //                   let closePrice = parseFloat((lastTrade[3] / priceFactor).toFixed(Math.floor(Math.log10(priceFactor))));
  //                   rawVolume =
  //                     (lastTrade[2] == 0 ? lastTrade[0] : lastTrade[1]) /
  //                     10 ** Number(markets[marketKey].baseDecimals);

  //                   const tradeTimeSec = lastTrade[6];
  //                   const flooredTradeTimeSec = Math.floor(tradeTimeSec / barSizeSec) * barSizeSec;
  //                   const lastBarTimeSec = Math.floor(new Date(lastBar?.time).getTime() / 1000);
  //                   if (flooredTradeTimeSec === lastBarTimeSec) {
  //                     updatedBars[lastBarIndex] = {
  //                       ...lastBar,
  //                       high: Math.max(lastBar.high, Math.max(openPrice, closePrice)),
  //                       low: Math.min(lastBar.low, Math.min(openPrice, closePrice)),
  //                       close: closePrice,
  //                       volume: lastBar.volume + rawVolume,
  //                     };
  //                     if (realtimeCallbackRef.current[existingIntervalLabel]) {
  //                       realtimeCallbackRef.current[existingIntervalLabel]({
  //                         ...lastBar,
  //                         high: Math.max(lastBar.high, Math.max(openPrice, closePrice)),
  //                         low: Math.min(lastBar.low, Math.min(openPrice, closePrice)),
  //                         close: closePrice,
  //                         volume: lastBar.volume + rawVolume,
  //                       });
  //                     }
  //                   } else {
  //                     updatedBars.push({
  //                       time: flooredTradeTimeSec * 1000,
  //                       open: lastBar?.close ?? openPrice,
  //                       high: Math.max(lastBar?.close ?? openPrice, closePrice),
  //                       low: Math.min(lastBar?.close ?? openPrice, closePrice),
  //                       close: closePrice,
  //                       volume: rawVolume,
  //                     });
  //                     if (realtimeCallbackRef.current[existingIntervalLabel]) {
  //                       realtimeCallbackRef.current[existingIntervalLabel]({
  //                         time: flooredTradeTimeSec * 1000,
  //                         open: lastBar?.close ?? openPrice,
  //                         high: Math.max(lastBar?.close ?? openPrice, closePrice),
  //                         low: Math.min(lastBar?.close ?? openPrice, closePrice),
  //                         close: closePrice,
  //                         volume: rawVolume,
  //                       });
  //                     }
  //                   }
  //                 }
  //               }
  //               setMarketsData((marketsData) =>
  //                 marketsData.map((market) => {
  //                   if (!market) return;
  //                   const marketKey = market?.marketKey.replace(
  //                     new RegExp(`^${wethticker}|${wethticker}$`, 'g'),
  //                     ethticker
  //                   );
  //                   const newTrades = temptrades?.[marketKey]
  //                   if (!Array.isArray(newTrades) || newTrades.length < 1) return market;
  //                   const firstKlineOpen: number =
  //                     market?.mini && Array.isArray(market?.mini) && market?.mini.length > 0
  //                       ? Number(market?.mini[0].value * Number(market.priceFactor))
  //                       : 0;
  //                   const currentPriceRaw = Number(newTrades[newTrades.length - 1][3]);
  //                   const percentageChange = firstKlineOpen === 0 ? 0 : ((currentPriceRaw - firstKlineOpen) / firstKlineOpen) * 100;
  //                   const quotePrice = market.quoteAsset == 'USDC' ? 1 : temptradesByMarket[(market.quoteAsset == settings.chainConfig[activechain].wethticker ? settings.chainConfig[activechain].ethticker : market.quoteAsset) + 'USDC']?.[0]?.[3]
  //                     / Number(markets[(market.quoteAsset == settings.chainConfig[activechain].wethticker ? settings.chainConfig[activechain].ethticker : market.quoteAsset) + 'USDC']?.priceFactor)
  //                   let high = market.high24h ? Number(market.high24h.replace(/,/g, '')) : null;
  //                   let low = market.low24h ? Number(market.low24h.replace(/,/g, '')) : null;
  //                   const volume = newTrades.reduce((sum: number, trade: any) => {
  //                     if (high && trade[3] / Number(market.priceFactor) > high) {
  //                       high = trade[3] / Number(market.priceFactor)
  //                     }
  //                     if (low && trade[3] / Number(market.priceFactor) < low) {
  //                       low = trade[3] / Number(market.priceFactor)
  //                     }
  //                     const amount = Number(trade[2] === 1 ? trade[0] : trade[1]);
  //                     return sum + amount;
  //                   }, 0) / 10 ** Number(market?.quoteDecimals) * quotePrice;

  //                   return {
  //                     ...market,
  //                     volume: formatCommas(
  //                       (parseFloat(market.volume.replace(/,/g, '')) + volume).toFixed(2)
  //                     ),
  //                     currentPrice: formatSig(
  //                       (currentPriceRaw / Number(market.priceFactor)).toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
  //                     ),
  //                     priceChange: `${percentageChange >= 0 ? '+' : ''}${percentageChange.toFixed(2)}`,
  //                     priceChangeAmount: formatSig(((currentPriceRaw - firstKlineOpen) / Number(market.priceFactor)).toFixed(formatSig(
  //                       (currentPriceRaw / Number(market.priceFactor)).toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
  //                     ).split('.')[1]?.length || 0)),
  //                     ...(high != null && {
  //                       high24h: formatSig(
  //                         high.toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
  //                       )
  //                     }),
  //                     ...(low != null && {
  //                       low24h: formatSig(
  //                         low.toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
  //                       )
  //                     })
  //                   };
  //                 })
  //               );
  //               return [updatedBars, existingIntervalLabel, existingShowOutliers];
  //             });
  //           }
  //         }
  //         if (Array.isArray(orderlogs)) {
  //           for (const log of orderlogs) {
  //             const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
  //             const marketKey = addresstoMarket['0x' + log['topics'][1].slice(26)];
  //             if (!tempset.has(logIdentifier) && marketKey && log['topics'][2].slice(26) ==
  //               address?.slice(2).toLowerCase()) {
  //               if (tempset.size >= 10000) {
  //                 const first = tempset.values().next().value;
  //                 if (first !== undefined) {
  //                   tempset.delete(first);
  //                 }
  //               }
  //               tempset.add(logIdentifier);
  //               const resolve = txReceiptResolvers.current.get(log['transactionHash']);
  //               if (resolve) {
  //                 resolve();
  //                 txReceiptResolvers.current.delete(log['transactionHash']);
  //               }
  //               let _timestamp = parseInt(log['blockTimestamp'], 16);
  //               let _orderdata = log['data'].slice(130);
  //               for (let i = 0; i < _orderdata.length; i += 64) {
  //                 let chunk = _orderdata.slice(i, i + 64);
  //                 let _isplace = parseInt(chunk.slice(0, 1), 16) >= 2;
  //                 if (_isplace) {
  //                   let buy = 3 - parseInt(chunk.slice(0, 1), 16);
  //                   let price = parseInt(chunk.slice(2, 22), 16);
  //                   let id = parseInt(chunk.slice(22, 36), 16);
  //                   let size = parseInt(chunk.slice(36, 64), 16);
  //                   let alreadyExist = tempcanceledorders.some(
  //                     (o: any) => o[0] == price && o[1] == id && o[4] == marketKey
  //                   );
  //                   buy ? size *= Number(markets[marketKey].scaleFactor) : size *= price
  //                   if (!alreadyExist) {
  //                     ordersChanged = true;
  //                     canceledOrdersChanged = true;
  //                     let order = [
  //                       price,
  //                       id,
  //                       size /
  //                       price,
  //                       buy,
  //                       marketKey,
  //                       log['transactionHash'],
  //                       _timestamp,
  //                       0,
  //                       size,
  //                       2,
  //                     ];
  //                     temporders.push(order)
  //                     tempcanceledorders.push([
  //                       price,
  //                       id,
  //                       size /
  //                       price,
  //                       buy,
  //                       marketKey,
  //                       log['transactionHash'],
  //                       _timestamp,
  //                       0,
  //                       size,
  //                       2,
  //                     ])
  //                     let quoteasset =
  //                       markets[marketKey].quoteAddress;
  //                     let baseasset =
  //                       markets[marketKey].baseAddress;
  //                     let amountquote = (
  //                       size /
  //                       (Number(
  //                         markets[marketKey].scaleFactor,
  //                       ) *
  //                         10 **
  //                         Number(
  //                           markets[marketKey]
  //                             .quoteDecimals,
  //                         ))
  //                     ).toFixed(2);
  //                     let amountbase = customRound(
  //                       size /
  //                       price /
  //                       10 **
  //                       Number(
  //                         markets[marketKey]
  //                           .baseDecimals,
  //                       ),
  //                       3,
  //                     );
  //                     newTxPopup(
  //                       log['transactionHash'],
  //                       'limit',
  //                       buy ? quoteasset : baseasset,
  //                       buy ? baseasset : quoteasset,
  //                       buy ? amountquote : amountbase,
  //                       buy ? amountbase : amountquote,
  //                       `${price / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
  //                       '',
  //                     );
  //                   }
  //                 } else {
  //                   let buy = parseInt(chunk.slice(0, 1), 16) == 0;
  //                   let price = parseInt(chunk.slice(2, 22), 16);
  //                   let id = parseInt(chunk.slice(22, 36), 16);
  //                   let size = parseInt(chunk.slice(36, 64), 16);
  //                   let index = temporders.findIndex(
  //                     (o: any) =>
  //                       o[0] == price &&
  //                       o[1] == id &&
  //                       o[4] == marketKey,
  //                   );
  //                   if (index != -1) {
  //                     ordersChanged = true;
  //                     canceledOrdersChanged = true;
  //                     let canceledOrderIndex: number;
  //                     canceledOrderIndex = tempcanceledorders.findIndex(
  //                       (canceledOrder: any) =>
  //                         canceledOrder[0] ==
  //                         price &&
  //                         canceledOrder[1] ==
  //                         id &&
  //                         canceledOrder[4] ==
  //                         marketKey,
  //                     );
  //                     if (canceledOrderIndex !== -1 && tempcanceledorders[canceledOrderIndex][9] != 0) {
  //                       tempcanceledorders[canceledOrderIndex] = [...tempcanceledorders[canceledOrderIndex]]
  //                       tempcanceledorders[canceledOrderIndex][9] = 0;
  //                       tempcanceledorders[canceledOrderIndex][8] =
  //                         tempcanceledorders[canceledOrderIndex][8] -
  //                         size;
  //                       tempcanceledorders[canceledOrderIndex][6] =
  //                         _timestamp;
  //                     }
  //                     if (temporders[index]?.[10] && typeof temporders[index][10].remove === 'function') {
  //                       temporders[index] = [...temporders[index]]
  //                       try {
  //                         temporders[index][10].remove();
  //                       }
  //                       catch { }
  //                       temporders[index].splice(10, 1)
  //                     }
  //                     temporders.splice(index, 1);
  //                     let quoteasset =
  //                       markets[marketKey].quoteAddress;
  //                     let baseasset =
  //                       markets[marketKey].baseAddress;
  //                     let amountquote = (
  //                       (buy ? size : size * price / Number(
  //                         markets[marketKey].scaleFactor
  //                       )) /
  //                       (10 **
  //                         Number(
  //                           markets[marketKey]
  //                             .quoteDecimals,
  //                         ))
  //                     ).toFixed(2);
  //                     let amountbase = customRound(
  //                       (buy ? size * Number(
  //                         markets[marketKey].scaleFactor
  //                       ) / price : size) /
  //                       10 **
  //                       Number(
  //                         markets[marketKey]
  //                           .baseDecimals,
  //                       ),
  //                       3,
  //                     );
  //                     newTxPopup(
  //                       log['transactionHash'],
  //                       'cancel',
  //                       buy ? quoteasset : baseasset,
  //                       buy ? baseasset : quoteasset,
  //                       buy ? amountquote : amountbase,
  //                       buy ? amountbase : amountquote,
  //                       `${price / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
  //                       '',
  //                     );
  //                   }
  //                 }
  //               }
  //             }
  //           }
  //         }
  //         if (Array.isArray(filllogs)) {
  //           for (const log of filllogs) {
  //             const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
  //             const marketKey = addresstoMarket['0x' + log['topics'][1].slice(26)];
  //             if (!tempset.has(logIdentifier) && marketKey && log['topics'][2].slice(26) ==
  //               address?.slice(2).toLowerCase()) {
  //               if (tempset.size >= 10000) {
  //                 const first = tempset.values().next().value;
  //                 if (first !== undefined) {
  //                   tempset.delete(first);
  //                 }
  //               }
  //               tempset.add(logIdentifier);
  //               let _timestamp = Math.floor(Date.now() / 1000);
  //               let _orderdata = log['data'].slice(2);
  //               let buy = 1 - parseInt(_orderdata.slice(0, 1), 16);
  //               let price = parseInt(_orderdata.slice(1, 22), 16);
  //               let id = parseInt(_orderdata.slice(22, 36), 16);
  //               let size = parseInt(_orderdata.slice(36, 64), 16);
  //               buy ? size *= price : size *= Number(markets[marketKey].scaleFactor)
  //               let orderIndex = temporders.findIndex(
  //                 (sublist: any) =>
  //                   sublist[0] ==
  //                   price &&
  //                   sublist[1] ==
  //                   id &&
  //                   sublist[4] == marketKey,
  //               );
  //               let canceledOrderIndex = tempcanceledorders.findIndex(
  //                 (sublist: any) =>
  //                   sublist[0] ==
  //                   price &&
  //                   sublist[1] ==
  //                   id &&
  //                   sublist[4] == marketKey,
  //               );
  //               if (orderIndex != -1 && canceledOrderIndex != -1) {
  //                 ordersChanged = true;
  //                 temporders[orderIndex] = [...temporders[orderIndex]]
  //                 let order = [...temporders[orderIndex]];
  //                 let buy = order[3];
  //                 let quoteasset =
  //                   markets[marketKey]
  //                     .quoteAddress;
  //                 let baseasset =
  //                   markets[marketKey]
  //                     .baseAddress;
  //                 let amountquote = (
  //                   ((order[2] - order[7] - size / order[0]) *
  //                     order[0]) /
  //                   (Number(
  //                     markets[marketKey]
  //                       .scaleFactor,
  //                   ) *
  //                     10 **
  //                     Number(
  //                       markets[marketKey]
  //                         .quoteDecimals,
  //                     ))
  //                 ).toFixed(2);
  //                 let amountbase = customRound(
  //                   (order[2] - order[7] - size / order[0]) /
  //                   10 **
  //                   Number(
  //                     markets[marketKey]
  //                       .baseDecimals,
  //                   ),
  //                   3,
  //                 );
  //                 newTxPopup(
  //                   log['transactionHash'],
  //                   'fill',
  //                   buy ? quoteasset : baseasset,
  //                   buy ? baseasset : quoteasset,
  //                   buy ? amountquote : amountbase,
  //                   buy ? amountbase : amountquote,
  //                   `${order[0] / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
  //                   '',
  //                 );
  //                 if (size == 0) {
  //                   tradeHistoryChanged = true;
  //                   temptradehistory.push([
  //                     order[3] == 1
  //                       ? (order[2] * order[0]) /
  //                       Number(markets[order[4]].scaleFactor)
  //                       : order[2],
  //                     order[3] == 1
  //                       ? order[2]
  //                       : (order[2] * order[0]) /
  //                       Number(markets[order[4]].scaleFactor),
  //                     order[3],
  //                     order[0],
  //                     order[4],
  //                     order[5],
  //                     _timestamp,
  //                     0,
  //                   ]);
  //                   if (temporders[orderIndex]?.[10] && typeof temporders[orderIndex][10].remove === 'function') {
  //                     try {
  //                       temporders[orderIndex][10].remove();
  //                     }
  //                     catch { }
  //                     temporders[orderIndex].splice(10, 1)
  //                   }
  //                   temporders.splice(orderIndex, 1);
  //                   tempcanceledorders[canceledOrderIndex][9] =
  //                     1;
  //                   tempcanceledorders[canceledOrderIndex][7] = order[2]
  //                   tempcanceledorders[canceledOrderIndex][8] = order[8];
  //                 } else {
  //                   if (temporders[orderIndex]?.[10] && typeof temporders[orderIndex][10].setQuantity === 'function') {
  //                     try {
  //                       temporders[orderIndex][10].setQuantity(formatDisplay(customRound((size / order[0]) / 10 ** Number(markets[order[4]].baseDecimals), 3)))
  //                     }
  //                     catch { }
  //                   }
  //                   temporders[orderIndex][7] =
  //                     order[2] - size / order[0];
  //                 }
  //                 if (canceledOrderIndex != -1) {
  //                   canceledOrdersChanged = true;
  //                   tempcanceledorders[canceledOrderIndex] = [...tempcanceledorders[canceledOrderIndex]]
  //                   if (size == 0) {
  //                     tempcanceledorders[canceledOrderIndex][9] =
  //                       1;
  //                     tempcanceledorders[canceledOrderIndex][7] = order[2]
  //                     tempcanceledorders[canceledOrderIndex][8] = order[8];
  //                   }
  //                   else {
  //                     tempcanceledorders[canceledOrderIndex][7] =
  //                       order[2] - size / order[0];
  //                   }
  //                 }
  //               }
  //             }
  //           }
  //         }
  //         if (tradeHistoryChanged) {
  //           settradehistory(temptradehistory)
  //         }
  //         if (tradesByMarketChanged) {
  //           settradesByMarket(temptradesByMarket)
  //         }
  //         if (canceledOrdersChanged) {
  //           setcanceledorders(tempcanceledorders)
  //         }
  //         if (ordersChanged) {
  //           setorders(temporders)
  //         }
  //         return tempset;
  //       })
  //     } catch {
  //     }
  //   };

  //   (async () => {
  //     if (address) {
  //       setTransactions([]);
  //       settradehistory([]);
  //       setorders([]);
  //       setcanceledorders([]);
  //       setrecipient('');
  //       isAddressInfoFetching = true;
  //       try {
  //         ;
  //         const query = `
  //           query {
  //             account(id: "${address}") {
  //               id
  //               userIds {
  //                 id
  //               }
  //               openOrderMap {
  //                 shards(first: 1000) { batches(first: 1000) { orders(first: 1000) {
  //                   id
  //                   market { id baseAsset quoteAsset }
  //                   isBuy
  //                   price
  //                   originalSize
  //                   remainingSize
  //                   status
  //                   placedAt
  //                   updatedAt
  //                   txHash
  //                 }}}
  //               }
  //               orderMap {
  //                 shards(first: 1000) { batches(first: 1000) { orders(first: 1000) {
  //                   id
  //                   market { id baseAsset quoteAsset }
  //                   isBuy
  //                   price
  //                   originalSize
  //                   remainingSize
  //                   status
  //                   placedAt
  //                   updatedAt
  //                   txHash
  //                 }}}
  //               }
  //               tradeMap {
  //                 shards(first: 1000) { batches(first: 1000) { trades(first: 1000) {
  //                   id
  //                   market { id baseAsset quoteAsset }
  //                   amountIn
  //                   amountOut
  //                   startPrice
  //                   endPrice
  //                   isBuy
  //                   timestamp
  //                   tx
  //                 }}}
  //               }
  //             }
  //           }
  //         `;

  //         const response = await fetch(SUBGRAPH_URL, {
  //           method: "POST",
  //           headers: { "content-type": "application/json" },
  //           body: JSON.stringify({ query }),
  //         });
  //         if (!response.ok) throw new Error(`http ${response.status} ${response.statusText}`);

  //         const result = await response.json();
  //         if (result?.errors?.length) throw new Error(result.errors[0]?.message || "graphql error");

  //         if (!isAddressInfoFetching) return;

  //         const flatten = (map: any, key: "orders" | "trades") =>
  //           (map?.shards ?? [])
  //             .flatMap((s: any) => s?.batches ?? [])
  //             .flatMap((b: any) => b?.[key] ?? []);

  //         const statusCode = (s: any) => {
  //           if (typeof s === "number") return s;
  //           const m: Record<string, number> = { open: 0, filled: 1, cancelled: 2, canceled: 2, expired: 3 };
  //           return m[(s ?? "").toString().toLowerCase()] ?? -1;
  //         };

  //         const getMarketKey = (m: any) => {
  //           if (m?.id && addresstoMarket?.[m.id]) return addresstoMarket[m.id];
  //           return ''
  //         };

  //         const acct = result?.data?.account;
  //         let temptradehistory: any[] = [];
  //         let temporders: any[] = [];
  //         let tempcanceledorders: any[] = [];

  //         if (acct) {
  //           const trades = flatten(acct.tradeMap, "trades") || [];
  //           for (const t of trades) {
  //             const marketKey = getMarketKey(t.market);
  //             if (marketKey) {
  //               temptradehistory.push([
  //                 Number(t.amountIn ?? 0),
  //                 Number(t.amountOut ?? 0),
  //                 t.isBuy ? 1 : 0,
  //                 Number((t.endPrice ?? t.startPrice) ?? 0),
  //                 marketKey,
  //                 t.tx,
  //                 Number(t.timestamp ?? 0),
  //                 1,
  //               ]);
  //             }
  //           }

  //           const openOrders = flatten(acct.openOrderMap, "orders") || [];
  //           for (const o of openOrders) {
  //             const marketKey = getMarketKey(o.market);
  //             if (marketKey) {
  //               const idParts = (o.id ?? "").split(":");
  //               const price = Number(o.price);
  //               const tail = parseInt(idParts[idParts.length - 1] ?? "0", 10) || 0;
  //               const original = Number(o.originalSize ?? 0);
  //               const remaining = Number(o.remainingSize ?? 0);
  //               const filled = Math.max(0, original - remaining);

  //               temporders.push([
  //                 price,
  //                 tail,
  //                 o.isBuy ? original * Number(markets[marketKey].scaleFactor) / price : original,
  //                 o.isBuy ? 1 : 0,
  //                 marketKey,
  //                 o.txHash,
  //                 Number(o.placedAt ?? o.updatedAt ?? 0),
  //                 o.isBuy ? filled * Number(markets[marketKey].scaleFactor) / price : filled,
  //                 o.isBuy ? original * Number(markets[marketKey].scaleFactor) : Number(o.price ?? 0) * original,
  //                 statusCode(o.status),
  //               ]);
  //             }
  //           }

  //           const allOrders = flatten(acct.orderMap, "orders") || [];
  //           for (const o of allOrders) {
  //             const marketKey = getMarketKey(o.market);
  //             if (marketKey) {
  //               const idParts = (o.id ?? "").split(":");
  //               const price = Number(o.price);
  //               const tail = parseInt(idParts[idParts.length - 1] ?? "0", 10) || 0;
  //               const original = Number(o.originalSize ?? 0);
  //               const remaining = Number(o.remainingSize ?? 0);
  //               const filled = Math.max(0, original - remaining);

  //               tempcanceledorders.push([
  //                 price,
  //                 tail,
  //                 o.isBuy ? original * Number(markets[marketKey].scaleFactor) / price : original,
  //                 o.isBuy ? 1 : 0,
  //                 marketKey,
  //                 o.txHash,
  //                 Number(o.updatedAt ?? o.placedAt ?? 0),
  //                 o.isBuy ? filled * Number(markets[marketKey].scaleFactor) / price : filled,
  //                 o.isBuy ? original * Number(markets[marketKey].scaleFactor) : Number(o.price ?? 0) * original,
  //                 statusCode(o.status),
  //               ]);
  //             }
  //           }
  //         }

  //         settradehistory(temptradehistory);
  //         setorders(temporders);
  //         setcanceledorders(tempcanceledorders);
  //         setaddressinfoloading(false);
  //         isAddressInfoFetching = false;
  //       } catch (error) {
  //         console.error("Error fetching logs:", error);
  //         setaddressinfoloading(false);
  //         isAddressInfoFetching = false;
  //       }
  //     }
  //     else if (!user) {
  //       setSliderPercent(0)
  //       const slider = document.querySelector('.balance-amount-slider');
  //       const popup = document.querySelector('.slider-percentage-popup');
  //       if (slider && popup) {
  //         (popup as HTMLElement).style.left = `${15 / 2}px`;
  //       }
  //       setTransactions([]);
  //       settradehistory([]);
  //       setorders([]);
  //       setcanceledorders([]);
  //       setaddressinfoloading(false);
  //     }
  //   })();

  //   const connectWebSocket = () => {
  //     if (liveStreamCancelled) return;
  //     wsRef.current = new WebSocket(WS_URL);

  //     wsRef.current.onopen = async () => {
  //       const subscriptionMessages = [
  //         JSON.stringify({
  //           jsonrpc: '2.0',
  //           id: 'sub1',
  //           method: 'eth_subscribe',
  //           params: [
  //             'monadLogs',
  //             {
  //               address: router,
  //               topics: [
  //                 '0x9adcf0ad0cda63c4d50f26a48925cf6405df27d422a39c456b5f03f661c82982',
  //               ],
  //             },
  //           ],
  //         }), ...(address?.slice(2) ? [JSON.stringify({
  //           jsonrpc: '2.0',
  //           id: 'sub2',
  //           method: 'eth_subscribe',
  //           params: [
  //             'monadLogs',
  //             {
  //               address: router,
  //               topics: [
  //                 ['0xa195980963150be5fcca4acd6a80bf5a9de7f9c862258501b7c705e7d2c2d2f4', '0x7ebb55d14fb18179d0ee498ab0f21c070fad7368e44487d51cdac53d6f74812c'],
  //                 null,
  //                 '0x000000000000000000000000' + address?.slice(2),
  //               ],
  //             },
  //           ],
  //         })] : [])
  //       ];

  //       pingIntervalRef.current = setInterval(() => {
  //         if (wsRef.current?.readyState === WebSocket.OPEN) {
  //           wsRef.current.send(JSON.stringify({
  //             jsonrpc: '2.0',
  //             id: 'ping',
  //             method: 'eth_syncing'
  //           }));
  //         }
  //       }, 15000);

  //       subscriptionMessages.forEach((message) => {
  //         wsRef.current?.send(message);
  //       });

  //       if (blockNumber.current) {
  //         startBlockNumber = '0x' + (blockNumber.current - BigInt(80)).toString(16)
  //         endBlockNumber = '0x' + (blockNumber.current + BigInt(10)).toString(16)
  //       } else {
  //         let firstBlockNumber = await getBlockNumber(config);
  //         startBlockNumber = '0x' + (firstBlockNumber - BigInt(80)).toString(16)
  //         endBlockNumber = '0x' + (firstBlockNumber + BigInt(10)).toString(16)
  //       }
  //       fetchData();
  //     };

  //     wsRef.current.onmessage = (event) => {
  //       const message = JSON.parse(event.data);
  //       if (message?.params?.result && message?.params?.result?.commitState == "Voted") {
  //         const log = message?.params?.result;
  //         let ordersChanged = false;
  //         let canceledOrdersChanged = false;
  //         let tradesByMarketChanged = false;
  //         let tradeHistoryChanged = false;
  //         let temporders: any;
  //         let tempcanceledorders: any;
  //         let temptradesByMarket: any;
  //         let temptradehistory: any;
  //         setorders((orders) => {
  //           temporders = [...orders];
  //           return orders;
  //         })
  //         setcanceledorders((canceledorders) => {
  //           tempcanceledorders = [...canceledorders];
  //           return canceledorders;
  //         })
  //         settradesByMarket((tradesByMarket: any) => {
  //           temptradesByMarket = { ...tradesByMarket };
  //           return tradesByMarket;
  //         })
  //         settradehistory((tradehistory: any) => {
  //           temptradehistory = [...tradehistory];
  //           return tradehistory;
  //         })
  //         setProcessedLogs(prev => {
  //           let tempset = new Set(prev);
  //           let temptrades: any = {};
  //           if (log['topics']?.[0] == '0x9adcf0ad0cda63c4d50f26a48925cf6405df27d422a39c456b5f03f661c82982') {
  //             const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
  //             const marketKey = addresstoMarket['0x' + log['topics'][1].slice(26)];
  //             if (!tempset.has(logIdentifier) && marketKey && !temptradesByMarket[marketKey]?.some((trade: any) =>
  //               trade[0] == parseInt(log['data'].slice(66, 130), 16) &&
  //               trade[1] == parseInt(log['data'].slice(130, 194), 16) &&
  //               trade[5] == log['transactionHash'])) {
  //               if (tempset.size >= 10000) {
  //                 const first = tempset.values().next().value;
  //                 if (first !== undefined) {
  //                   tempset.delete(first);
  //                 }
  //               }
  //               tempset.add(logIdentifier);
  //               const resolve = txReceiptResolvers.current.get(log['transactionHash']);
  //               if (resolve) {
  //                 resolve();
  //                 txReceiptResolvers.current.delete(log['transactionHash']);
  //               }
  //               let _timestamp = Math.floor(Date.now() / 1000);
  //               tradesByMarketChanged = true;
  //               if (!Array.isArray(temptradesByMarket[marketKey])) {
  //                 temptradesByMarket[marketKey] = [];
  //               }
  //               let amountIn = parseInt(log['data'].slice(66, 130), 16);
  //               let amountOut = parseInt(log['data'].slice(130, 194), 16);
  //               let buy = parseInt(log['data'].slice(65, 66), 16);
  //               let price = parseInt(log['data'].slice(258, 322), 16);
  //               temptradesByMarket[marketKey].unshift([
  //                 amountIn,
  //                 amountOut,
  //                 buy,
  //                 price,
  //                 marketKey,
  //                 log['transactionHash'],
  //                 _timestamp,
  //               ]);
  //               if (!Array.isArray(temptrades[marketKey])) {
  //                 temptrades[marketKey] = [];
  //               }
  //               temptrades[marketKey].unshift([
  //                 amountIn,
  //                 amountOut,
  //                 buy,
  //                 price,
  //                 marketKey,
  //                 log['transactionHash'],
  //                 _timestamp,
  //                 parseInt(log['data'].slice(194, 258), 16),
  //               ])
  //               if (
  //                 log['topics'][2].slice(26) ==
  //                 address?.slice(2).toLowerCase()
  //               ) {
  //                 tradeHistoryChanged = true;
  //                 temptradehistory.push([
  //                   amountIn,
  //                   amountOut,
  //                   buy,
  //                   price,
  //                   marketKey,
  //                   log['transactionHash'],
  //                   _timestamp,
  //                   1,
  //                 ])
  //                 let quoteasset =
  //                   markets[marketKey].quoteAddress;
  //                 let baseasset =
  //                   markets[marketKey].baseAddress;
  //                 let popupAmountIn = customRound(
  //                   amountIn /
  //                   10 **
  //                   Number(
  //                     buy
  //                       ? markets[marketKey]
  //                         .quoteDecimals
  //                       : markets[marketKey]
  //                         .baseDecimals,
  //                   ),
  //                   3,
  //                 );
  //                 let popupAmountOut = customRound(
  //                   amountOut /
  //                   10 **
  //                   Number(
  //                     buy
  //                       ? markets[marketKey]
  //                         .baseDecimals
  //                       : markets[marketKey]
  //                         .quoteDecimals,
  //                   ),
  //                   3,
  //                 );
  //                 newTxPopup(
  //                   log['transactionHash'],
  //                   'swap',
  //                   buy ? quoteasset : baseasset,
  //                   buy ? baseasset : quoteasset,
  //                   popupAmountIn,
  //                   popupAmountOut,
  //                   '',
  //                   '',
  //                 );
  //               }
  //             }
  //             if (tradesByMarketChanged) {
  //               setChartData(([existingBars, existingIntervalLabel, existingShowOutliers]) => {
  //                 const marketKey = existingIntervalLabel?.match(/^\D*/)?.[0];
  //                 const updatedBars = [...existingBars];
  //                 let rawVolume;
  //                 if (marketKey && Array.isArray(temptrades?.[marketKey])) {
  //                   const barSizeSec =
  //                     existingIntervalLabel?.match(/\d.*/)?.[0] === '1' ? 60 :
  //                       existingIntervalLabel?.match(/\d.*/)?.[0] === '5' ? 5 * 60 :
  //                         existingIntervalLabel?.match(/\d.*/)?.[0] === '15' ? 15 * 60 :
  //                           existingIntervalLabel?.match(/\d.*/)?.[0] === '30' ? 30 * 60 :
  //                             existingIntervalLabel?.match(/\d.*/)?.[0] === '60' ? 60 * 60 :
  //                               existingIntervalLabel?.match(/\d.*/)?.[0] === '240' ? 4 * 60 * 60 :
  //                                 existingIntervalLabel?.match(/\d.*/)?.[0] === '1D' ? 24 * 60 * 60 :
  //                                   5 * 60;
  //                   const priceFactor = Number(markets[marketKey].priceFactor);
  //                   for (const lastTrade of temptrades[marketKey]) {
  //                     const lastBarIndex = updatedBars.length - 1;
  //                     const lastBar = updatedBars[lastBarIndex];

  //                     let openPrice = parseFloat((lastTrade[7] / priceFactor).toFixed(Math.floor(Math.log10(priceFactor))));
  //                     let closePrice = parseFloat((lastTrade[3] / priceFactor).toFixed(Math.floor(Math.log10(priceFactor))));
  //                     rawVolume =
  //                       (lastTrade[2] == 0 ? lastTrade[0] : lastTrade[1]) /
  //                       10 ** Number(markets[marketKey].baseDecimals);

  //                     const tradeTimeSec = lastTrade[6];
  //                     const flooredTradeTimeSec = Math.floor(tradeTimeSec / barSizeSec) * barSizeSec;
  //                     const lastBarTimeSec = Math.floor(new Date(lastBar?.time).getTime() / 1000);
  //                     if (flooredTradeTimeSec === lastBarTimeSec) {
  //                       updatedBars[lastBarIndex] = {
  //                         ...lastBar,
  //                         high: Math.max(lastBar.high, Math.max(openPrice, closePrice)),
  //                         low: Math.min(lastBar.low, Math.min(openPrice, closePrice)),
  //                         close: closePrice,
  //                         volume: lastBar.volume + rawVolume,
  //                       };
  //                       if (realtimeCallbackRef.current[existingIntervalLabel]) {
  //                         realtimeCallbackRef.current[existingIntervalLabel]({
  //                           ...lastBar,
  //                           high: Math.max(lastBar.high, Math.max(openPrice, closePrice)),
  //                           low: Math.min(lastBar.low, Math.min(openPrice, closePrice)),
  //                           close: closePrice,
  //                           volume: lastBar.volume + rawVolume,
  //                         });
  //                       }
  //                     } else {
  //                       updatedBars.push({
  //                         time: flooredTradeTimeSec * 1000,
  //                         open: lastBar?.close ?? openPrice,
  //                         high: Math.max(lastBar?.close ?? openPrice, closePrice),
  //                         low: Math.min(lastBar?.close ?? openPrice, closePrice),
  //                         close: closePrice,
  //                         volume: rawVolume,
  //                       });
  //                       if (realtimeCallbackRef.current[existingIntervalLabel]) {
  //                         realtimeCallbackRef.current[existingIntervalLabel]({
  //                           time: flooredTradeTimeSec * 1000,
  //                           open: lastBar?.close ?? openPrice,
  //                           high: Math.max(lastBar?.close ?? openPrice, closePrice),
  //                           low: Math.min(lastBar?.close ?? openPrice, closePrice),
  //                           close: closePrice,
  //                           volume: rawVolume,
  //                         });
  //                       }
  //                     }
  //                   }
  //                 }
  //                 setMarketsData((marketsData) =>
  //                   marketsData.map((market) => {
  //                     if (!market) return;
  //                     const marketKey = market?.marketKey.replace(
  //                       new RegExp(`^${wethticker}|${wethticker}$`, 'g'),
  //                       ethticker
  //                     );
  //                     const newTrades = temptrades?.[marketKey]
  //                     if (!Array.isArray(newTrades) || newTrades.length < 1) return market;
  //                     const firstKlineOpen: number =
  //                       market?.mini && Array.isArray(market?.mini) && market?.mini.length > 0
  //                         ? Number(market?.mini[0].value * Number(market.priceFactor))
  //                         : 0;
  //                     const currentPriceRaw = Number(newTrades[newTrades.length - 1][3]);
  //                     const percentageChange = firstKlineOpen === 0 ? 0 : ((currentPriceRaw - firstKlineOpen) / firstKlineOpen) * 100;
  //                     const quotePrice = market.quoteAsset == 'USDC' ? 1 : temptradesByMarket[(market.quoteAsset == settings.chainConfig[activechain].wethticker ? settings.chainConfig[activechain].ethticker : market.quoteAsset) + 'USDC']?.[0]?.[3]
  //                       / Number(markets[(market.quoteAsset == settings.chainConfig[activechain].wethticker ? settings.chainConfig[activechain].ethticker : market.quoteAsset) + 'USDC']?.priceFactor)
  //                     let high = market.high24h ? Number(market.high24h.replace(/,/g, '')) : null;
  //                     let low = market.low24h ? Number(market.low24h.replace(/,/g, '')) : null;
  //                     const volume = newTrades.reduce((sum: number, trade: any) => {
  //                       if (high && trade[3] / Number(market.priceFactor) > high) {
  //                         high = trade[3] / Number(market.priceFactor)
  //                       }
  //                       if (low && trade[3] / Number(market.priceFactor) < low) {
  //                         low = trade[3] / Number(market.priceFactor)
  //                       }
  //                       const amount = Number(trade[2] === 1 ? trade[0] : trade[1]);
  //                       return sum + amount;
  //                     }, 0) / 10 ** Number(market?.quoteDecimals) * quotePrice;

  //                     return {
  //                       ...market,
  //                       volume: formatCommas(
  //                         (parseFloat(market.volume.replace(/,/g, '')) + volume).toFixed(2)
  //                       ),
  //                       currentPrice: formatSig(
  //                         (currentPriceRaw / Number(market.priceFactor)).toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
  //                       ),
  //                       priceChange: `${percentageChange >= 0 ? '+' : ''}${percentageChange.toFixed(2)}`,
  //                       priceChangeAmount: formatSig(((currentPriceRaw - firstKlineOpen) / Number(market.priceFactor)).toFixed(formatSig(
  //                         (currentPriceRaw / Number(market.priceFactor)).toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
  //                       ).split('.')[1]?.length || 0)),
  //                       ...(high != null && {
  //                         high24h: formatSig(
  //                           high.toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
  //                         )
  //                       }),
  //                       ...(low != null && {
  //                         low24h: formatSig(
  //                           low.toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
  //                         )
  //                       })
  //                     };
  //                   })
  //                 );
  //                 return [updatedBars, existingIntervalLabel, existingShowOutliers];
  //               });
  //             }
  //           }
  //           else if (log['topics']?.[0] == '0x7ebb55d14fb18179d0ee498ab0f21c070fad7368e44487d51cdac53d6f74812c') {
  //             const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
  //             const marketKey = addresstoMarket['0x' + log['topics'][1].slice(26)];
  //             if (!tempset.has(logIdentifier) && marketKey && log['topics'][2].slice(26) ==
  //               address?.slice(2).toLowerCase()) {
  //               if (tempset.size >= 10000) {
  //                 const first = tempset.values().next().value;
  //                 if (first !== undefined) {
  //                   tempset.delete(first);
  //                 }
  //               }
  //               tempset.add(logIdentifier);
  //               const resolve = txReceiptResolvers.current.get(log['transactionHash']);
  //               if (resolve) {
  //                 resolve();
  //                 txReceiptResolvers.current.delete(log['transactionHash']);
  //               }
  //               let _timestamp = Math.floor(Date.now() / 1000);
  //               let _orderdata = log['data'].slice(130);
  //               for (let i = 0; i < _orderdata.length; i += 64) {
  //                 let chunk = _orderdata.slice(i, i + 64);
  //                 let _isplace = parseInt(chunk.slice(0, 1), 16) >= 2;
  //                 if (_isplace) {
  //                   let buy = 3 - parseInt(chunk.slice(0, 1), 16);
  //                   let price = parseInt(chunk.slice(2, 22), 16);
  //                   let id = parseInt(chunk.slice(22, 36), 16);
  //                   let size = parseInt(chunk.slice(36, 64), 16);
  //                   let alreadyExist = tempcanceledorders.some(
  //                     (o: any) => o[0] == price && o[1] == id && o[4] == marketKey
  //                   );
  //                   buy ? size *= Number(markets[marketKey].scaleFactor) : size *= price
  //                   if (!alreadyExist) {
  //                     ordersChanged = true;
  //                     canceledOrdersChanged = true;
  //                     let order = [
  //                       price,
  //                       id,
  //                       size /
  //                       price,
  //                       buy,
  //                       marketKey,
  //                       log['transactionHash'],
  //                       _timestamp,
  //                       0,
  //                       size,
  //                       2,
  //                     ];
  //                     temporders.push(order)
  //                     tempcanceledorders.push([
  //                       price,
  //                       id,
  //                       size /
  //                       price,
  //                       buy,
  //                       marketKey,
  //                       log['transactionHash'],
  //                       _timestamp,
  //                       0,
  //                       size,
  //                       2,
  //                     ])
  //                     let quoteasset =
  //                       markets[marketKey].quoteAddress;
  //                     let baseasset =
  //                       markets[marketKey].baseAddress;
  //                     let amountquote = (
  //                       size /
  //                       (Number(
  //                         markets[marketKey].scaleFactor,
  //                       ) *
  //                         10 **
  //                         Number(
  //                           markets[marketKey]
  //                             .quoteDecimals,
  //                         ))
  //                     ).toFixed(2);
  //                     let amountbase = customRound(
  //                       size /
  //                       price /
  //                       10 **
  //                       Number(
  //                         markets[marketKey]
  //                           .baseDecimals,
  //                       ),
  //                       3,
  //                     );
  //                     newTxPopup(
  //                       log['transactionHash'],
  //                       'limit',
  //                       buy ? quoteasset : baseasset,
  //                       buy ? baseasset : quoteasset,
  //                       buy ? amountquote : amountbase,
  //                       buy ? amountbase : amountquote,
  //                       `${price / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
  //                       '',
  //                     );
  //                   }
  //                 } else {
  //                   let buy = parseInt(chunk.slice(0, 1), 16) == 0;
  //                   let price = parseInt(chunk.slice(2, 22), 16);
  //                   let id = parseInt(chunk.slice(22, 36), 16);
  //                   let size = parseInt(chunk.slice(36, 64), 16);
  //                   let index = temporders.findIndex(
  //                     (o: any) =>
  //                       o[0] == price &&
  //                       o[1] == id &&
  //                       o[4] == marketKey,
  //                   );
  //                   if (index != -1) {
  //                     ordersChanged = true;
  //                     canceledOrdersChanged = true;
  //                     let canceledOrderIndex: number;
  //                     canceledOrderIndex = tempcanceledorders.findIndex(
  //                       (canceledOrder: any) =>
  //                         canceledOrder[0] ==
  //                         price &&
  //                         canceledOrder[1] ==
  //                         id &&
  //                         canceledOrder[4] ==
  //                         marketKey,
  //                     );
  //                     if (canceledOrderIndex !== -1 && tempcanceledorders[canceledOrderIndex][9] != 0) {
  //                       tempcanceledorders[canceledOrderIndex] = [...tempcanceledorders[canceledOrderIndex]]
  //                       tempcanceledorders[canceledOrderIndex][9] = 0;
  //                       tempcanceledorders[canceledOrderIndex][8] =
  //                         tempcanceledorders[canceledOrderIndex][8] -
  //                         size;
  //                       tempcanceledorders[canceledOrderIndex][6] =
  //                         _timestamp;
  //                     }
  //                     if (temporders[index]?.[10] && typeof temporders[index][10].remove === 'function') {
  //                       temporders[index] = [...temporders[index]]
  //                       try {
  //                         temporders[index][10].remove();
  //                       }
  //                       catch { }
  //                       temporders[index].splice(10, 1)
  //                     }
  //                     temporders.splice(index, 1);
  //                     let quoteasset =
  //                       markets[marketKey].quoteAddress;
  //                     let baseasset =
  //                       markets[marketKey].baseAddress;
  //                     let amountquote = (
  //                       (buy ? size : size * price / Number(
  //                         markets[marketKey].scaleFactor
  //                       )) /
  //                       (10 **
  //                         Number(
  //                           markets[marketKey]
  //                             .quoteDecimals,
  //                         ))
  //                     ).toFixed(2);
  //                     let amountbase = customRound(
  //                       (buy ? size * Number(
  //                         markets[marketKey].scaleFactor
  //                       ) / price : size) /
  //                       10 **
  //                       Number(
  //                         markets[marketKey]
  //                           .baseDecimals,
  //                       ),
  //                       3,
  //                     );
  //                     newTxPopup(
  //                       log['transactionHash'],
  //                       'cancel',
  //                       buy ? quoteasset : baseasset,
  //                       buy ? baseasset : quoteasset,
  //                       buy ? amountquote : amountbase,
  //                       buy ? amountbase : amountquote,
  //                       `${price / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
  //                       '',
  //                     );
  //                   }
  //                 }
  //               }
  //             }
  //           }
  //           else {
  //             const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
  //             const marketKey = addresstoMarket['0x' + log['topics'][1].slice(26)];
  //             if (!tempset.has(logIdentifier) && marketKey && log['topics'][2].slice(26) ==
  //               address?.slice(2).toLowerCase()) {
  //               if (tempset.size >= 10000) {
  //                 const first = tempset.values().next().value;
  //                 if (first !== undefined) {
  //                   tempset.delete(first);
  //                 }
  //               }
  //               tempset.add(logIdentifier);
  //               let _timestamp = Math.floor(Date.now() / 1000);
  //               let _orderdata = log['data'].slice(2);
  //               let buy = 1 - parseInt(_orderdata.slice(0, 1), 16);
  //               let price = parseInt(_orderdata.slice(1, 22), 16);
  //               let id = parseInt(_orderdata.slice(22, 36), 16);
  //               let size = parseInt(_orderdata.slice(36, 64), 16);
  //               buy ? size *= price : size *= Number(markets[marketKey].scaleFactor)
  //               let orderIndex = temporders.findIndex(
  //                 (sublist: any) =>
  //                   sublist[0] ==
  //                   price &&
  //                   sublist[1] ==
  //                   id &&
  //                   sublist[4] == marketKey,
  //               );
  //               let canceledOrderIndex = tempcanceledorders.findIndex(
  //                 (sublist: any) =>
  //                   sublist[0] ==
  //                   price &&
  //                   sublist[1] ==
  //                   id &&
  //                   sublist[4] == marketKey,
  //               );
  //               if (orderIndex != -1 && canceledOrderIndex != -1) {
  //                 ordersChanged = true;
  //                 temporders[orderIndex] = [...temporders[orderIndex]]
  //                 let order = [...temporders[orderIndex]];
  //                 let buy = order[3];
  //                 let quoteasset =
  //                   markets[marketKey]
  //                     .quoteAddress;
  //                 let baseasset =
  //                   markets[marketKey]
  //                     .baseAddress;
  //                 let amountquote = (
  //                   ((order[2] - order[7] - size / order[0]) *
  //                     order[0]) /
  //                   (Number(
  //                     markets[marketKey]
  //                       .scaleFactor,
  //                   ) *
  //                     10 **
  //                     Number(
  //                       markets[marketKey]
  //                         .quoteDecimals,
  //                     ))
  //                 ).toFixed(2);
  //                 let amountbase = customRound(
  //                   (order[2] - order[7] - size / order[0]) /
  //                   10 **
  //                   Number(
  //                     markets[marketKey]
  //                       .baseDecimals,
  //                   ),
  //                   3,
  //                 );
  //                 newTxPopup(
  //                   log['transactionHash'],
  //                   'fill',
  //                   buy ? quoteasset : baseasset,
  //                   buy ? baseasset : quoteasset,
  //                   buy ? amountquote : amountbase,
  //                   buy ? amountbase : amountquote,
  //                   `${order[0] / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
  //                   '',
  //                 );
  //                 if (size == 0) {
  //                   tradeHistoryChanged = true;
  //                   temptradehistory.push([
  //                     order[3] == 1
  //                       ? (order[2] * order[0]) /
  //                       Number(markets[order[4]].scaleFactor)
  //                       : order[2],
  //                     order[3] == 1
  //                       ? order[2]
  //                       : (order[2] * order[0]) /
  //                       Number(markets[order[4]].scaleFactor),
  //                     order[3],
  //                     order[0],
  //                     order[4],
  //                     order[5],
  //                     _timestamp,
  //                     0,
  //                   ]);
  //                   if (temporders[orderIndex]?.[10] && typeof temporders[orderIndex][10].remove === 'function') {
  //                     try {
  //                       temporders[orderIndex][10].remove();
  //                     }
  //                     catch { }
  //                     temporders[orderIndex].splice(10, 1)
  //                   }
  //                   temporders.splice(orderIndex, 1);
  //                   tempcanceledorders[canceledOrderIndex][9] =
  //                     1;
  //                   tempcanceledorders[canceledOrderIndex][7] = order[2]
  //                   tempcanceledorders[canceledOrderIndex][8] = order[8];
  //                 } else {
  //                   if (temporders[orderIndex]?.[10] && typeof temporders[orderIndex][10].setQuantity === 'function') {
  //                     try {
  //                       temporders[orderIndex][10].setQuantity(formatDisplay(customRound((size / order[0]) / 10 ** Number(markets[order[4]].baseDecimals), 3)))
  //                     }
  //                     catch { }
  //                   }
  //                   temporders[orderIndex][7] =
  //                     order[2] - size / order[0];
  //                 }
  //                 if (canceledOrderIndex != -1) {
  //                   canceledOrdersChanged = true;
  //                   tempcanceledorders[canceledOrderIndex] = [...tempcanceledorders[canceledOrderIndex]]
  //                   if (size == 0) {
  //                     tempcanceledorders[canceledOrderIndex][9] =
  //                       1;
  //                     tempcanceledorders[canceledOrderIndex][7] = order[2]
  //                     tempcanceledorders[canceledOrderIndex][8] = order[8];
  //                   }
  //                   else {
  //                     tempcanceledorders[canceledOrderIndex][7] =
  //                       order[2] - size / order[0];
  //                   }
  //                 }
  //               }
  //             }
  //           }
  //           if (tradeHistoryChanged) {
  //             settradehistory(temptradehistory)
  //           }
  //           if (tradesByMarketChanged) {
  //             settradesByMarket(temptradesByMarket)
  //           }
  //           if (canceledOrdersChanged) {
  //             setcanceledorders(tempcanceledorders)
  //           }
  //           if (ordersChanged) {
  //             setorders(temporders)
  //           }
  //           return tempset;
  //         })
  //       }
  //     }

  //     wsRef.current.onclose = () => {
  //       if (pingIntervalRef.current) {
  //         clearInterval(pingIntervalRef.current);
  //         pingIntervalRef.current = null;
  //       }
  //       reconnectIntervalRef.current = setTimeout(() => {
  //         connectWebSocket();
  //       }, 500);
  //     };

  //     wsRef.current.onerror = (error) => {
  //       console.error(error);
  //     };
  //   };

  //   connectWebSocket();

  //   return () => {
  //     liveStreamCancelled = true;
  //     isAddressInfoFetching = false;
  //     if (pingIntervalRef.current) {
  //       clearInterval(pingIntervalRef.current);
  //       pingIntervalRef.current = null;
  //     }
  //     if (reconnectIntervalRef.current) {
  //       clearTimeout(reconnectIntervalRef.current);
  //       reconnectIntervalRef.current = null;
  //     }
  //     if (wsRef.current) {
  //       wsRef.current.close();
  //       wsRef.current = null;
  //     }
  //   };
  // }, [activechain, address]);

  // // klines + trades
  // useEffect(() => {
  //   (async () => {
  //     try {
  //       settradesloading(true);

  //       const query = `
  //         query {
  //           markets(first: 100, orderBy: volume, orderDirection: desc, where: {isCanonical:true}) {
  //             id
  //             baseAsset
  //             quoteAsset
  //             baseDecimals
  //             quoteDecimals
  //             baseTicker
  //             quoteTicker
  //             baseName
  //             quoteName
  //             marketType
  //             scaleFactor
  //             tickSize
  //             minSize
  //             maxPrice
  //             takerFee
  //             makerRebate
  //             volume
  //             latestPrice
  //             series(where:{intervalSeconds:3600}) {
  //               intervalSeconds
  //               klines(first: 24, orderBy:time, orderDirection: desc) {
  //                 time
  //                 open
  //                 high
  //                 low
  //                 close
  //                 usdVolume
  //               }
  //             }
  //             trades(first: 50, orderBy: id, orderDirection: desc) {
  //               trade {
  //                 id
  //                 amountIn
  //                 amountOut
  //                 isBuy
  //                 timestamp
  //                 tx
  //                 endPrice
  //               }
  //             }
  //           }
  //         }
  //       `;
  //       const res = await fetch(SUBGRAPH_URL, {
  //         method: "POST",
  //         headers: { "Content-Type": "application/json" },
  //         body: JSON.stringify({ query }),
  //       });
  //       const json = await res.json();
  //       const list = Array.isArray(json?.data?.markets) ? [...json.data.markets].reverse() : []

  //       const ETH_ADDR = settings.chainConfig[activechain].eth;
  //       const WETH_ADDR = settings.chainConfig[activechain].weth;
  //       const ETH_TICKER = settings.chainConfig[activechain].ethticker;
  //       const WETH_TICKER = settings.chainConfig[activechain].wethticker;
  //       const newMarkets: Record<string, any> = settings.chainConfig[activechain].markets;
  //       for (const m of list) {
  //         const baseAddr0 = getAddress(String(m.baseAsset || ''));
  //         const quoteAddr0 = getAddress(String(m.quoteAsset || ''));
  //         if (!tokendict[baseAddr0]) {
  //           tokendict[baseAddr0] = {
  //             address: baseAddr0,
  //             decimals: BigInt(Number(m.baseDecimals ?? 18)),
  //             image: '',
  //             name: m.baseName,
  //             ticker: m.baseTicker,
  //             website: '',
  //             autofetched: true,
  //           }
  //         }
  //         if (!tokendict[quoteAddr0]) {
  //           tokendict[quoteAddr0] = {
  //             address: quoteAddr0,
  //             decimals: BigInt(Number(m.quoteDecimals ?? 18)),
  //             image: '',
  //             name: m.quoteName,
  //             ticker: m.quoteTicker,
  //             website: '',
  //             autofetched: true,
  //           }
  //         }
  //         const scaleExp = Number(m.scaleFactor ?? 0);
  //         const scaleFactor = (BigInt(10) ** BigInt(scaleExp));
  //         const baseDec = Number(m.baseDecimals ?? 18);
  //         const quoteDec = Number(m.quoteDecimals ?? 18);
  //         const pfExp = Math.max(0, quoteDec + scaleExp - baseDec);
  //         const priceFactor = (BigInt(10) ** BigInt(pfExp));

  //         const common = {
  //           address: String(m.id ?? '').toLowerCase(),
  //           marketType: Number(m.marketType ?? 0),
  //           precision: 5,
  //           scaleFactor,
  //           priceFactor,
  //           tickSize: BigInt(m.tickSize ?? 1),
  //           minSize: BigInt(m.minSize ?? 0),
  //           maxPrice: BigInt(m.maxPrice ?? 0),
  //           fee: BigInt(m.takerFee ?? 100000),
  //           makerRebate: BigInt(m.makerRebate ?? 100000),
  //           baseDecimals: BigInt(baseDec),
  //           quoteDecimals: BigInt(quoteDec),
  //         };

  //         const baseIsEthish = baseAddr0 === ETH_ADDR || baseAddr0 === WETH_ADDR;
  //         const quoteIsEthish = quoteAddr0 === ETH_ADDR || quoteAddr0 === WETH_ADDR;

  //         const variants: Array<{ baseAddr: string; quoteAddr: string, baseAsset: string, quoteAsset: string }> = [];
  //         if (baseIsEthish) {
  //           variants.push({ baseAddr: ETH_ADDR, quoteAddr: quoteAddr0, baseAsset: ETH_TICKER, quoteAsset: m.quoteTicker });
  //           variants.push({ baseAddr: WETH_ADDR, quoteAddr: quoteAddr0, baseAsset: WETH_TICKER, quoteAsset: m.quoteTicker });
  //         } else if (quoteIsEthish) {
  //           variants.push({ baseAddr: baseAddr0, quoteAddr: ETH_ADDR, baseAsset: m.baseTicker, quoteAsset: ETH_TICKER });
  //           variants.push({ baseAddr: baseAddr0, quoteAddr: WETH_ADDR, baseAsset: m.baseTicker, quoteAsset: WETH_TICKER });
  //         } else {
  //           variants.push({ baseAddr: baseAddr0, quoteAddr: quoteAddr0, baseAsset: m.baseTicker, quoteAsset: m.quoteTicker });
  //         }

  //         for (const v of variants) {
  //           const bTok = tokendict[v.baseAddr];

  //           const marketKey = `${v.baseAsset}${v.quoteAsset}`;
  //           const image = (bTok?.image ?? settings.chainConfig[activechain].image ?? null);
  //           const website = (bTok?.website ?? '');
  //           newMarkets[marketKey] = {
  //             baseAsset: v.baseAsset,
  //             quoteAsset: v.quoteAsset,
  //             baseAddress: v.baseAddr,
  //             quoteAddress: v.quoteAddr,
  //             path: [v.quoteAddr, v.baseAddr],
  //             image,
  //             website,
  //             marketKey,
  //             ...common,
  //           };
  //         }
  //       }
  //       settings.chainConfig[activechain].markets = newMarkets;
  //       const newAddrToMarket: Record<string, string> = {};
  //       Object.values(newMarkets).reverse().forEach((m: any) => {
  //         if (m?.address) newAddrToMarket[String(m.address).toLowerCase()] = m.marketKey;
  //       });
  //       settings.chainConfig[activechain].addresstomarket = newAddrToMarket;

  //       const temptradesByMarket: Record<string, any[]> = {};
  //       Object.keys(newMarkets).forEach((k) => { temptradesByMarket[k] = []; });

  //       const addrToKey: Record<string, string> = {};
  //       Object.values(newMarkets).forEach((m: any) => {
  //         if (m?.address) addrToKey[String(m.address).toLowerCase()] = m.marketKey;
  //       });

  //       const rows: any[] = [];
  //       const buildMiniPointsDesc = (mkt: any): Array<any> => {
  //         const oneHourSeries = Array.isArray(mkt.series)
  //           ? mkt.series.find((s: any) => Number(s?.intervalSeconds) === 3600)
  //           : null;

  //         const klinesDesc = Array.isArray(oneHourSeries?.klines) ? oneHourSeries.klines : [];

  //         const nowSec = Math.floor(Date.now() / 1000);
  //         const endBucket = Math.floor(nowSec / 3600) * 3600;
  //         const startCutoff = endBucket - 24 * 3600;

  //         return klinesDesc
  //           .filter((k: any) => {
  //             const t = Number(k.time ?? 0);
  //             return t >= startCutoff && t <= endBucket;
  //           })
  //           .map((k: any) => ({
  //             time: Number(k.time ?? 0),
  //             open: Number(k.open ?? 0),
  //             close: Number(k.close ?? 0),
  //             high: Number(k.high ?? 0),
  //             low: Number(k.low ?? 0),
  //             usdVolume: String(k.usdVolume ?? "0"),
  //           }));
  //       };
  //       for (const m of list) {
  //         const mk = addrToKey[String(m.id ?? '').toLowerCase()];
  //         if (!mk) continue;

  //         const cfg = newMarkets[mk];
  //         if (!cfg) continue;
  //         const isWMON = cfg.baseAsset === WETH_TICKER || cfg.quoteAsset === WETH_TICKER;

  //         const pf = Number(cfg.priceFactor);
  //         const decs = Math.max(0, Math.floor(Math.log10(pf)));
  //         const lastRaw = Number(m.latestPrice ?? 0);
  //         const last = pf ? lastRaw / pf : 0;

  //         const miniDesc = buildMiniPointsDesc(m);
  //         const r = [...miniDesc].reverse()
  //         const miniAsc = r[0]
  //           ? [{ time: Number(r[0].time) * 1000, value: Number(r[0].open) / pf, high: Number(r[0].high) / pf, low: Number(r[0].low) / pf },
  //           ...r.map((p: any) => ({
  //             time: Number(p.time) * 1000,
  //             value: Number(p.close) / pf,
  //             high: Number(p.high) / pf,
  //             low: Number(p.low) / pf,
  //             open: Number(p.open) / pf
  //           }))]
  //           : []
  //         const open24 = miniAsc.length ? miniAsc[0].value : last;
  //         const highs = miniAsc.length ? miniAsc.map((p) => p.high) : [last];
  //         const lows = miniAsc.length ? miniAsc.map((p) => p.low) : [last];
  //         const high24 = Math.max(...highs);
  //         const low24 = Math.min(...lows);
  //         const pct = open24 === 0 ? 0 : ((last - open24) / open24) * 100;
  //         const deltaRaw = last - open24;

  //         const volQ = miniAsc.length == 0 ? 0 : Number((m.volume ?? 0) / 10 ** Number(6));
  //         const volumeDisplay = formatCommas(volQ.toFixed(2));

  //         const trades = Array.isArray(m.trades) ? m.trades : [];
  //         if (trades.length) {
  //           for (const t of trades) {
  //             if (temptradesByMarket[mk]) {
  //               temptradesByMarket[mk].push([
  //                 Number(t.trade.amountIn ?? 0),
  //                 Number(t.trade.amountOut ?? 0),
  //                 t.trade.isBuy ? 1 : 0,
  //                 t.trade.endPrice,
  //                 mk,
  //                 t.trade.tx,
  //                 Number(t.trade.timestamp ?? 0),
  //               ]);
  //             }
  //           }
  //         }

  //         if (!isWMON) {
  //           rows.push({
  //             ...cfg,
  //             pair: `${cfg.baseAsset}/${cfg.quoteAsset}`,
  //             mini: miniAsc,
  //             currentPrice: formatSig(last.toFixed(decs), m.marketType != 0),
  //             high24h: formatSig(high24.toFixed(decs), m.marketType != 0),
  //             low24h: formatSig(low24.toFixed(decs), m.marketType != 0),
  //             volume: volumeDisplay,
  //             priceChange: `${pct >= 0 ? '+' : ''}${pct.toFixed(2)}`,
  //             priceChangeAmount: formatSig(deltaRaw.toFixed(formatSig(last.toFixed(decs), m.marketType != 0).split('.')[1]?.length || 0)),
  //           });
  //         }


  //         const bIsEthish = cfg.baseAddress === ETH_ADDR || cfg.baseAddress === WETH_ADDR;
  //         const qIsEthish = cfg.quoteAddress === ETH_ADDR || cfg.quoteAddress === WETH_ADDR;

  //         if (bIsEthish || qIsEthish) {
  //           const sibBaseTicker = bIsEthish
  //             ? (cfg.baseAsset === ETH_TICKER ? WETH_TICKER : ETH_TICKER)
  //             : cfg.baseAsset;
  //           const sibQuoteTicker = qIsEthish
  //             ? (cfg.quoteAsset === ETH_TICKER ? WETH_TICKER : ETH_TICKER)
  //             : cfg.quoteAsset;
  //           const siblingKey = `${sibBaseTicker}${sibQuoteTicker}`;
  //           const siblingCfg = newMarkets[siblingKey];

  //           if (siblingCfg) {
  //             const isSiblingWMON =
  //               siblingCfg.baseAsset === wethticker || siblingCfg.quoteAsset === wethticker;

  //             if (!isSiblingWMON) {
  //               if (trades.length && temptradesByMarket[siblingKey]) {
  //                 for (const t of trades) {
  //                   temptradesByMarket[siblingKey].push([
  //                     Number(t.trade.amountIn ?? 0),
  //                     Number(t.trade.amountOut ?? 0),
  //                     t.trade.isBuy ? 1 : 0,
  //                     t.trade.endPrice,
  //                     siblingKey,
  //                     t.trade.tx,
  //                     Number(t.trade.timestamp ?? 0),
  //                   ]);
  //                 }
  //               }

  //               rows.push({
  //                 ...siblingCfg,
  //                 pair: `${siblingCfg.baseAsset}/${siblingCfg.quoteAsset}`,
  //                 mini: miniAsc,
  //                 currentPrice: formatSig(last.toFixed(decs), m.marketType != 0),
  //                 high24h: formatSig(high24.toFixed(decs), m.marketType != 0),
  //                 low24h: formatSig(low24.toFixed(decs), m.marketType != 0),
  //                 volume: volumeDisplay,
  //                 priceChange: `${pct >= 0 ? '+' : ''}${pct.toFixed(2)}`,
  //                 priceChangeAmount: formatSig(deltaRaw.toFixed(formatSig(last.toFixed(decs), m.marketType != 0).split('.')[1]?.length || 0)),
  //               });
  //             }
  //           }
  //         }
  //       }

  //       settradesByMarket(temptradesByMarket);
  //       setMarketsData(rows);
  //       settradesloading(false);

  //       if (
  //         sendInputString === '' &&
  //         location.pathname.slice(1) === 'send' &&
  //         amountIn &&
  //         BigInt(amountIn) !== BigInt(0)
  //       ) {
  //         const mkObj = getMarket(activeMarket.path.at(0), activeMarket.path.at(1));
  //         const wethticker = settings.chainConfig[activechain].wethticker;
  //         const ethticker = settings.chainConfig[activechain].ethticker;
  //         const mkKey = (({ baseAsset, quoteAsset }: any) =>
  //           (baseAsset === wethticker ? ethticker : baseAsset) +
  //           (quoteAsset === wethticker ? ethticker : quoteAsset)
  //         )(mkObj);

  //         setsendInputString(
  //           `$${calculateUSDValue(
  //             BigInt(amountIn),
  //             temptradesByMarket[mkKey],
  //             tokenIn,
  //             mkObj
  //           ).toFixed(2)}`
  //         );
  //       }
  //     } catch (error) {
  //       console.error("Error fetching data:", error);
  //       settradesloading(false);
  //     }
  //   })();
  // }, [activechain]);

  // mobile trade
  useEffect(() => {
    const handleEscapeKey = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && popup != 11) {
        setpopup(0);
        setSendUsdValue('');
        setSendInputAmount('');
        setSendAmountIn(BigInt(0));
        settokenString('');
        window.dispatchEvent(new Event('high-impact-cancel'));
        setSelectedConnector(null);

        if (showTrade && !simpleView) {
          document.body.style.overflow = 'auto'
          document.querySelector('.right-column')?.classList.add('hide');
          document.querySelector('.right-column')?.classList.remove('show');
          document.querySelector('.trade-mobile-switch')?.classList.remove('open');
          setShowTrade(false);
        }
      }
    };
    const handleMouseDown = (e: MouseEvent) => {
      setpopup((popup) => {
        if (showTrade && popup == 0 && !simpleView) {
          const rectangleElement = document.querySelector('.rectangle');
          if (
            rectangleElement &&
            !rectangleElement.contains(e.target as Node)
          ) {
            document.body.style.overflow = 'auto'
            document.querySelector('.right-column')?.classList.add('hide');
            document.querySelector('.right-column')?.classList.remove('show');
            document.querySelector('.trade-mobile-switch')?.classList.remove('open');
            setShowTrade(false);
          }
        }

        if (!popupref.current?.contains(e.target as Node) && popup != 11) {
          setSendUsdValue('');
          setSendInputAmount('');
          setSendAmountIn(BigInt(0));
          settokenString('');
          window.dispatchEvent(new Event('high-impact-cancel'));
          return 0;
        }
        return popup;
      });
    };
    const handleResize = () => setWindowWidth(window.innerWidth);
    document.addEventListener('keydown', handleEscapeKey);
    document.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('resize', handleResize);
    return () => {
      document.removeEventListener('keydown', handleEscapeKey);
      document.removeEventListener('mousedown', handleMouseDown);
      window.removeEventListener('resize', handleResize);
    };
  }, [showTrade]);

  // url
  useEffect(() => {
    const path = location.pathname.slice(1);
    if (['swap', 'limit', 'send', 'scale', 'market'].includes(path)) {
      setSearchParams({
        ...(path != 'send' ? { tokenIn } : { token: tokenIn }),
        ...(tokenOut && path != 'send' && { tokenOut }),
        ...(switched && (path == 'swap' || path == 'market')
          ? { amountOut: amountOutSwap }
          : { amountIn }),
      });
    }
  }, [tokenIn, tokenOut, location.pathname.slice(1), amountIn, amountOutSwap, switched]);

  // update active tab
  useLayoutEffect(() => {
    const path = location.pathname.slice(1);
    if (path === 'swap') {
      setSimpleView(true);
    } else if (path === 'market') {
      setSimpleView(false);
    }
    if (path === 'send' || path === 'scale') {
      setCurrentProText(path.toLowerCase());
    } else {
      setCurrentProText('pro');
    }
    if (['swap', 'limit', 'send', 'scale', 'market'].includes(path)) {
      if (amountIn == BigInt(0)) {
        setInputString('');
      }
      const slider = document.querySelector('.balance-amount-slider');
      const popup = document.querySelector('.slider-percentage-popup');
      if (slider && popup) {
        const rect = slider.getBoundingClientRect();
        (popup as HTMLElement).style.left =
          `${(rect.width - 15) * (sliderPercent / 100) + 15 / 2}px`;
      }
      if (path == 'send') {
        setsendInputString(
          amountIn != BigInt(0)
            ? `$${calculateUSDValue(
              amountIn,
              tradesByMarket[
              (({ baseAsset, quoteAsset }) =>
                (baseAsset === wethticker ? ethticker : baseAsset) +
                (quoteAsset === wethticker ? ethticker : quoteAsset)
              )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
              ],
              tokenIn,
              getMarket(activeMarket.path.at(0), activeMarket.path.at(1)),
            ).toFixed(2)}`
            : '',
        );
      } else if (path == 'limit') {
        if (multihop || isWrap) {
          let token;
          let pricefetchmarket;
          let found = false;
          for (const market in markets) {
            if (markets[market].baseAddress === tokenOut) {
              token = tokendict[markets[market].quoteAddress];
              pricefetchmarket = getMarket(
                markets[market].quoteAddress,
                tokenOut,
              );
              setTokenIn(markets[market].quoteAddress);
              found = true;
              break;
            }
          }
          if (!found) {
            for (const market in markets) {
              if (markets[market].quoteAddress === tokenOut) {
                token = tokendict[markets[market].baseAddress];
                pricefetchmarket = getMarket(
                  markets[market].baseAddress,
                  tokenOut,
                );
                setTokenIn(markets[market].baseAddress);
                break;
              }
            }
          }
          setswitched(true);
          setamountIn(
            limitPrice != BigInt(0) && amountOutSwap != BigInt(0)
              ? token.address === pricefetchmarket?.baseAddress
                ? (amountOutSwap *
                  (pricefetchmarket.scaleFactor || BigInt(1))) /
                limitPrice
                : (amountOutSwap * limitPrice) /
                (pricefetchmarket.scaleFactor || BigInt(1))
              : BigInt(0),
          );
          setInputString(
            (limitPrice != BigInt(0) && amountOutSwap != BigInt(0)
              ? token.address === pricefetchmarket?.baseAddress
                ? customRound(
                  Number(
                    (amountOutSwap *
                      (pricefetchmarket.scaleFactor || BigInt(1))) /
                    limitPrice,
                  ) /
                  10 ** Number(token.decimals),
                  3,
                )
                : customRound(
                  Number(
                    (amountOutSwap * limitPrice) /
                    (pricefetchmarket.scaleFactor || BigInt(1)),
                  ) /
                  10 ** Number(token.decimals),
                  3,
                )
              : ''
            ).toString(),
          );
          const percentage = !tokenBalances[token.address]
            ? 0
            : Math.min(
              100,
              Math.floor(
                Number(
                  ((limitPrice != BigInt(0) && amountOutSwap != BigInt(0)
                    ? token === pricefetchmarket?.baseAddress
                      ? (amountOutSwap *
                        (pricefetchmarket.scaleFactor || BigInt(1))) /
                      limitPrice
                      : (amountOutSwap * limitPrice) /
                      (pricefetchmarket.scaleFactor || BigInt(1))
                    : BigInt(0)) *
                    BigInt(100)) /
                  tokenBalances[token.address],
                ),
              ),
            );
          setSliderPercent(percentage);
          const slider = document.querySelector('.balance-amount-slider');
          const popup = document.querySelector('.slider-percentage-popup');
          if (slider && popup) {
            const rect = slider.getBoundingClientRect();
            (popup as HTMLElement).style.left =
              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
          }
        } else {
          if (switched) {
            setamountIn(
              limitPrice !== BigInt(0) && amountOutSwap !== BigInt(0)
                ? tokenIn === activeMarket?.baseAddress
                  ? (amountOutSwap *
                    (activeMarket.scaleFactor || BigInt(1))) /
                  limitPrice
                  : (amountOutSwap * limitPrice) /
                  (activeMarket.scaleFactor || BigInt(1))
                : BigInt(0),
            );
            setInputString(
              (limitPrice !== BigInt(0) && amountOutSwap !== BigInt(0)
                ? tokenIn === activeMarket?.baseAddress
                  ? customRound(
                    Number(
                      (amountOutSwap *
                        (activeMarket.scaleFactor || BigInt(1))) /
                      limitPrice,
                    ) /
                    10 ** Number(tokendict[tokenIn].decimals),
                    3,
                  )
                  : customRound(
                    Number(
                      (amountOutSwap * limitPrice) /
                      (activeMarket.scaleFactor || BigInt(1)),
                    ) /
                    10 ** Number(tokendict[tokenIn].decimals),
                    3,
                  )
                : ''
              ).toString(),
            );
            const percentage =
              tokenBalances[tokenIn] === BigInt(0)
                ? 0
                : Math.min(
                  100,
                  Math.floor(
                    Number(
                      (limitPrice !== BigInt(0) &&
                        amountOutSwap !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (amountOutSwap *
                            (activeMarket.scaleFactor ||
                              BigInt(1))) /
                          limitPrice
                          : (amountOutSwap * limitPrice) /
                          (activeMarket.scaleFactor || BigInt(1))
                        : BigInt(0)) * BigInt(100) / tokenBalances[tokenIn]
                    )
                  ),
                );
            setSliderPercent(percentage);
            const slider = document.querySelector(
              '.balance-amount-slider',
            );
            const popup = document.querySelector(
              '.slider-percentage-popup',
            );
            if (slider && popup) {
              const rect = slider.getBoundingClientRect();
              (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                }px`;
            }
          }
          else {
            setamountOutSwap(
              limitPrice != BigInt(0) && amountIn != BigInt(0)
                ? tokenIn === activeMarket?.baseAddress
                  ? (amountIn * limitPrice) /
                  (activeMarket.scaleFactor || BigInt(1))
                  : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                  limitPrice
                : BigInt(0),
            );
            setoutputString(
              (limitPrice != BigInt(0) && amountIn != BigInt(0)
                ? tokenIn === activeMarket?.baseAddress
                  ? customRound(
                    Number(
                      (amountIn * limitPrice) /
                      (activeMarket.scaleFactor || BigInt(1)),
                    ) /
                    10 ** Number(tokendict[tokenOut].decimals),
                    3,
                  )
                  : customRound(
                    Number(
                      (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                      limitPrice,
                    ) /
                    10 ** Number(tokendict[tokenOut].decimals),
                    3,
                  )
                : ''
              )
                .toString()
                .replace(/(\.\d*?[1-9])0+$/g, '$1')
                .replace(/\.0+$/, ''),
            );
          }
        }
      } else if (path == 'swap' || path == 'market') {
      } else if (path == 'scale') {
        if (multihop || isWrap) {
          let token;
          let found = false;
          for (const market in markets) {
            if (markets[market].baseAddress === tokenOut) {
              token = tokendict[markets[market].quoteAddress];
              setTokenIn(markets[market].quoteAddress);
              found = true;
              break;
            }
          }
          if (!found) {
            for (const market in markets) {
              if (markets[market].quoteAddress === tokenOut) {
                token = tokendict[markets[market].baseAddress];
                setTokenIn(markets[market].baseAddress);
                break;
              }
            }
          }
          setamountIn(
            BigInt(0)
          );
          setInputString('')
          setScaleStart(BigInt(0))
          setScaleEnd(BigInt(0))
          setScaleStartString('')
          setScaleEndString('')
          const percentage = !tokenBalances[token.address]
            ? 0
            : Math.min(
              100,
              Math.floor(
                Number(
                  (BigInt(0) *
                    BigInt(100)) /
                  tokenBalances[token.address],
                ),
              ),
            );
          setSliderPercent(percentage);
          const slider = document.querySelector('.balance-amount-slider');
          const popup = document.querySelector('.slider-percentage-popup');
          if (slider && popup) {
            const rect = slider.getBoundingClientRect();
            (popup as HTMLElement).style.left =
              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
          }
        }
        else {
          if (scaleStart && scaleEnd && scaleOrders && scaleSkew) {
            if (switched) {
              const requiredInput = calculateScaleInput(
                amountOutSwap,
                Number(scaleStart),
                Number(scaleEnd),
                Number(scaleOrders),
                Number(scaleSkew)
              );
              setamountIn(requiredInput);
              setInputString(
                customRound(
                  Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                  3
                ).toString()
              );
              const percentage =
                tokenBalances[tokenIn] === BigInt(0)
                  ? 0
                  : Math.min(
                    100,
                    Math.floor(
                      Number(
                        (requiredInput) * BigInt(100) / tokenBalances[tokenIn])
                    ),
                  );
              setSliderPercent(percentage);
              const slider = document.querySelector(
                '.balance-amount-slider',
              );
              const popup = document.querySelector(
                '.slider-percentage-popup',
              );
              if (slider && popup) {
                const rect = slider.getBoundingClientRect();
                (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                  }px`;
              }
            }
            else {
              setScaleOutput(Number(amountIn), Number(scaleStart), Number(scaleEnd), Number(scaleOrders), Number(scaleSkew))
            }
          }
          else {
            if (switched) {
              const requiredInput = calculateScaleInput(
                amountOutSwap,
                Number(scaleStart),
                Number(scaleEnd),
                Number(0),
                Number(scaleSkew)
              );
              setamountIn(requiredInput);
              setInputString('');
              const percentage =
                tokenBalances[tokenIn] === BigInt(0)
                  ? 0
                  : Math.min(
                    100,
                    Math.floor(
                      Number(
                        (requiredInput) * BigInt(100) / tokenBalances[tokenIn])
                    ),
                  );
              setSliderPercent(percentage);
              const slider = document.querySelector(
                '.balance-amount-slider',
              );
              const popup = document.querySelector(
                '.slider-percentage-popup',
              );
              if (slider && popup) {
                const rect = slider.getBoundingClientRect();
                (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                  }px`;
              }
            }
            else {
              setScaleOutput(Number(amountIn), Number(scaleStart), Number(scaleEnd), Number(0), Number(scaleSkew))
            }
          }
        }
      }
    }
    if (!path.startsWith('perps')) {
      setPerpsMarketsData({})
      setPerpsFilterOptions({})
    }
  }, [location.pathname.slice(1)]);

  // limit chase
  /* useEffect(() => {
    if (limitChase && !isLimitEditing) {
      let price = mids?.[activeMarketKey]?.[0] ? (tokenIn === activeMarket?.baseAddress ? mids[activeMarketKey][0] == mids[activeMarketKey][1] ? mids[activeMarketKey][2] : mids[activeMarketKey][0] : mids[activeMarketKey][0] == mids[activeMarketKey][2] ? mids[activeMarketKey][1] : mids[activeMarketKey][0]) : 0n
      setlimitPrice(price);
      setlimitPriceString(
        price == 0n ? '' : (
          Number(price) / Number(activeMarket.priceFactor)
        ).toFixed(Math.floor(Math.log10(activeMarket?.marketType != 0 ? Math.min(10 ** Math.max(0, 5 - Math.floor(Math.log10((Number(price) / Number(activeMarket.priceFactor)) || 1)) - 1), Number(activeMarket.priceFactor)) : Number(activeMarket.priceFactor)))),
      );
      if (switched && location.pathname.slice(1) == 'limit' && !multihop && !isWrap) {
        setamountIn(
          price !== BigInt(0) && amountOutSwap !== BigInt(0)
            ? tokenIn === activeMarket?.baseAddress
              ? (amountOutSwap *
                (activeMarket.scaleFactor || BigInt(1))) /
              price
              : (amountOutSwap * price) /
              (activeMarket.scaleFactor || BigInt(1))
            : BigInt(0),
        );
        setInputString(
          (price !== BigInt(0) && amountOutSwap !== BigInt(0)
            ? tokenIn === activeMarket?.baseAddress
              ? customRound(
                Number(
                  (amountOutSwap *
                    (activeMarket.scaleFactor || BigInt(1))) /
                  price,
                ) /
                10 ** Number(tokendict[tokenIn].decimals),
                3,
              )
              : customRound(
                Number(
                  (amountOutSwap * price) /
                  (activeMarket.scaleFactor || BigInt(1)),
                ) /
                10 ** Number(tokendict[tokenIn].decimals),
                3,
              )
            : ''
          ).toString(),
        );
        const percentage =
          tokenBalances[tokenIn] === BigInt(0)
            ? 0
            : Math.min(
              100,
              Math.floor(
                Number(
                  (price !== BigInt(0) &&
                    amountOutSwap !== BigInt(0)
                    ? tokenIn === activeMarket?.baseAddress
                      ? (amountOutSwap *
                        (activeMarket.scaleFactor ||
                          BigInt(1))) /
                      price
                      : (amountOutSwap * price) /
                      (activeMarket.scaleFactor || BigInt(1))
                    : BigInt(0)) * BigInt(100) / tokenBalances[tokenIn]
                )
              ),
            );
        setSliderPercent(percentage);
        const slider = document.querySelector(
          '.balance-amount-slider',
        );
        const popup = document.querySelector(
          '.slider-percentage-popup',
        );
        if (slider && popup) {
          const rect = slider.getBoundingClientRect();
          (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
            }px`;
        }
      }
      else if (location.pathname.slice(1) == 'limit' && !multihop && !isWrap) {
        setamountOutSwap(
          price != BigInt(0) && amountIn != BigInt(0)
            ? tokenIn === activeMarket?.baseAddress
              ? (amountIn * price) /
              (activeMarket.scaleFactor || BigInt(1))
              : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
              price
            : BigInt(0),
        );
        setoutputString(
          (price != BigInt(0) && amountIn != BigInt(0)
            ? tokenIn === activeMarket?.baseAddress
              ? customRound(
                Number(
                  (amountIn * price) /
                  (activeMarket.scaleFactor || BigInt(1)),
                ) /
                10 ** Number(tokendict[tokenOut].decimals),
                3,
              )
              : customRound(
                Number(
                  (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                  price,
                ) /
                10 ** Number(tokendict[tokenOut].decimals),
                3,
              )
            : ''
          ).toString(),
        );
      }
    }
  }, [limitChase, activechain, mids?.[activeMarketKey]?.[0], activeMarketKey, tokenIn, location.pathname.slice(1), isLimitEditing]); */

  // tx popup time
  useEffect(() => {
    const interval = setInterval(() => {
      setTransactions((prevTransactions) => {
        const time = Date.now();
        const filteredTransactions = prevTransactions
          .filter((tx) => time - tx.timestamp < 9950)
          .map((tx) => ({
            ...tx,
            isNew: time - tx.timestamp < 300 ? true : false,
            isExiting: time - tx.timestamp > 9700 ? true : false,
          }));
        return filteredTransactions.length !== prevTransactions.length ||
          filteredTransactions.some(
            (tx, i) => tx.isNew !== prevTransactions[i]?.isNew,
          ) ||
          filteredTransactions.some(
            (tx, i) => tx.isExiting !== prevTransactions[i]?.isExiting,
          )
          ? filteredTransactions
          : prevTransactions;
      });
    }, 100);

    return () => clearInterval(interval);
  }, []);

  // popup
  useEffect(() => {
    if (user && !(scaAddress != undefined)) {
      setpopup(11);
    }
    else if (scaAddress && popup === 11 && subWallets.length == 0) {
      (async () => {
        await createSubWallet(true);
        setpopup(12);
      })();
    }
    else {
      if (connected) {
        if (!localStorage.getItem("firstConnect")) {
          localStorage.setItem("firstConnect", "true");
          if (typedRefCode) {
            setpopup(17)
          }
          else if (!oneCTSigner) {
            setpopup(28)
          }
          // if (window.location.hostname == 'test.crystal.exchange' && address != '0x16A6AD07571a73b1C043Db515EC29C4FCbbbBb5d') {
          //   (async () => {
          //     const amountInWei = BigInt(Math.round(30 * 10 ** 18));
          //     await sendUserOperationAsync({
          //       uo: {
          //         target: address as `0x${string}`,
          //         value: amountInWei,
          //         data: '0x'
          //       }
          //     }, 100000n, 0n, false, '', await getTransactionCount(config, { address: ('0x14e60c954f13df0c1cc7e96dd485a245485c8813' as any), }))
          //   })()
          // }
        }
        else {
          if (scaAddress && popup === 11) {
            setpopup(0);
          }
        }
      }
    }
  }, [popup, connected, scaAddress, typedRefCode, user != null, loading]);

  const { data: tempQueryData, isFetching: isQuoteFetching, dataUpdatedAt: quoteUpdatedAt, refetch: quoteRefetch } = useQuery({
    queryKey: ['madhouse_quote', tokenIn, tokenOut, address, activechain, slippage.toString(), amountIn ? amountIn.toString() : null],
    queryFn: async () => {
      const allowanceBody = address ? JSON.stringify({
        jsonrpc: '2.0',
        id: 1,
        method: 'eth_call',
        params: [{
          to: tokenIn,
          data: '0xdd62ed3e' + address.replace('0x', '').padStart(64, '0') + settings.chainConfig[activechain]?.madHouseRouter.replace('0x', '').padStart(64, '0')
        }, 'latest']
      }) : ''

      let gasEstimateCall: any = null;
      if (address && tempQueryData?.aggregatorRes?.tx?.data) {
        try {
          let tx: any = null;

          tx = {
            target: settings.chainConfig[activechain].madHouseRouter,
            data: tempQueryData?.aggregatorRes?.tx?.data,
            value: BigInt(tempQueryData?.aggregatorRes?.tx?.value)
          }

          if (tx) {
            gasEstimateCall = JSON.stringify({
              jsonrpc: '2.0',
              id: 1,
              method: 'eth_estimateGas',
              params: [{
                from: address as `0x${string}`,
                to: tx.target,
                data: tx.data,
                value: tx.value ? `0x${BigInt(tx.value).toString(16)}` : '0x',
              }]
            });
          }
        } catch (e) {
          gasEstimateCall = null;
        }
      }

      const [aggregatorRes, allowanceRes, gasEstimateRes] = await Promise.all([
        fetch(`https://api.madhouse.ag/swap/v1/quote?chain=${activechain}&tokenIn=${tokenIn == eth ? '0x0000000000000000000000000000000000000000' : tokenIn}&tokenOut=${tokenOut == eth ? '0x0000000000000000000000000000000000000000' : tokenOut}&amountIn=${amountIn.toString()}&slippage=${(10000 - Number(slippage)) / 10000}`).then(r => r.json()),
        allowanceBody ? fetch(HTTP_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: allowanceBody }).then(r => r.json()) : Promise.resolve({ result: '0x0' }),
        gasEstimateCall ? fetch(HTTP_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: gasEstimateCall }).then(r => r.json()) : Promise.resolve({ result: '0x0' })
      ])
      return { aggregatorRes, allowanceRes: BigInt(allowanceRes?.result == '0x' ? 0 : allowanceRes?.result), gasEstimateRes: BigInt(gasEstimateRes?.result == '0x' ? 0 : gasEstimateRes?.result) }
    },
    enabled: !!tokenIn && !!tokenOut && !!activechain && !!amountIn && ['swap'].includes(location.pathname.split('/')[1]),
    refetchInterval: 3000,
    gcTime: 0
  })

  useLayoutEffect(() => {
    if (!isQuoteFetching && tempQueryData?.aggregatorRes) {
      if (!txPending.current && !debounceTimerRef.current) {
        if (tempQueryData?.allowanceRes != null) {
          setallowance(tempQueryData?.allowanceRes);
        }
        if (tempQueryData?.aggregatorRes != null) {
          setStateIsLoading(false);
          setstateloading(false);
          setamountOutSwap(BigInt(tempQueryData?.aggregatorRes?.amountOut || 0))
          setoutputString(Number(tempQueryData?.aggregatorRes?.amountOut || 0) == 0 ? '' : customRound(Number(tempQueryData?.aggregatorRes?.amountOut || 0) / (10 ** Number(tokendict[tokenOut].decimals)), 3))
        }
      }
    } else {
    }
  }, [tempQueryData, activechain, isQuoteFetching, quoteUpdatedAt, location.pathname.slice(1)]);

  // temp update display values when loading is finished
  useLayoutEffect(() => {
    if (!isLoading && !stateIsLoading && tempQueryData?.aggregatorRes) {
      setDisplayValuesLoading(false);
      if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
        let estPrice = 0;
        setAveragePrice(amountOutSwap == 0n ? '0' : `${customRound((Number(amountIn) / 10 ** Number(tokendict[tokenIn].decimals)) / (Number(amountOutSwap) / 10 ** Number(tokendict[tokenOut].decimals)), 2)}`);
        setPriceImpact(() => {
          let temppriceimpact;
          if (multihop) {
            let price = 1;
            let mid;
            for (let i = 0; i < activeMarket.path.length - 1; i++) {
              let market = getMarket(
                activeMarket.path[i],
                activeMarket.path[i + 1],
              );
              mid = Number(mids[(market.baseAsset + market.quoteAsset).replace(
                new RegExp(
                  `^${wethticker}|${wethticker}$`,
                  'g'
                ),
                ethticker
              )][0]);
              if (activeMarket.path[i] == market.quoteAddress) {
                price *= mid / Number(market.priceFactor);
              } else {
                price /= mid / Number(market.priceFactor);
              }
            }
            temppriceimpact = `${customRound(
              0.001 > Math.abs(((estPrice - price) / price) * 100)
                ? 0
                : Math.abs(((estPrice - price) / price) * 100),
              3,
            )}%`;
          } else {
            temppriceimpact = `${customRound(
              0.001 >
                Math.abs(
                  ((estPrice -
                    (tokenIn == activeMarket.quoteAddress
                      ? Number(lowestAsk) / Number(activeMarket.priceFactor)
                      : Number(highestBid) / Number(activeMarket.priceFactor))) /
                    (tokenIn == activeMarket.quoteAddress
                      ? Number(lowestAsk) / Number(activeMarket.priceFactor)
                      : Number(highestBid) / Number(activeMarket.priceFactor))) *
                  100,
                )
                ? 0
                : Math.abs(
                  ((estPrice -
                    (tokenIn == activeMarket.quoteAddress
                      ? Number(lowestAsk) / Number(activeMarket.priceFactor)
                      : Number(highestBid) /
                      Number(activeMarket.priceFactor))) /
                    (tokenIn == activeMarket.quoteAddress
                      ? Number(lowestAsk) / Number(activeMarket.priceFactor)
                      : Number(highestBid) /
                      Number(activeMarket.priceFactor))) *
                  100,
                ),
              3,
            )}%`;
          }
          setSwapButtonDisabled(
            (amountIn === BigInt(0) ||
              amountIn > walletTokenBalances[address]?.[tokenIn] ||
              ((orderType == 1 || multihop) &&
                !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) &&
                tempQueryData?.aggregatorRes == undefined)) &&
            connected &&
            userchain == activechain,
          );
          setSwapButton(
            connected && userchain == activechain
              ? (switched &&
                amountOutSwap != BigInt(0) &&
                amountIn == BigInt(0)) ||
                ((orderType == 1 || multihop) &&
                  !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) &&
                  tempQueryData?.aggregatorRes == undefined)
                ? 0
                : amountIn === BigInt(0)
                  ? 1
                  : amountIn <= walletTokenBalances[address]?.[tokenIn]
                    ? allowance < amountIn && tokenIn != eth && !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake)
                      ? 6
                      : 2
                    : 3
              : connected
                ? 4
                : 5,
          );
          setwarning(
            !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) &&
              ((amountIn == BigInt(0) && amountOutSwap != BigInt(0)) ||
                ((orderType == 1 || multihop) &&
                  tempQueryData?.aggregatorRes == undefined))
              ? multihop
                ? 3
                : 2
              : parseFloat(temppriceimpact.slice(0, -1)) > 5 &&
                !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) &&
                (orderType != 0 || (slippage < BigInt(9500))) &&
                !isLoading &&
                !stateIsLoading
                ? 1
                : 0,
          );
          return temppriceimpact == 'NaN%' ? '0%' : temppriceimpact;
        });
        setTradeFee(
          `${(Number(amountIn) * (100000 - Number(activeMarket.fee))) /
            100000 /
            10 ** Number(tokendict[tokenIn].decimals) >
            0.0001
            ? customRound(
              (Number(amountIn) * (100000 - Number(activeMarket.fee))) /
              100000 /
              10 ** Number(tokendict[tokenIn].decimals),
              2,
            )
            : (Number(amountIn) * (100000 - Number(activeMarket.fee))) /
              100000 /
              10 ** Number(tokendict[tokenIn].decimals) ==
              0
              ? '0'
              : '<0.0001'
          } ${tokendict[tokenIn].ticker}`,
        );
      }
    } else if (stateIsLoading && !isWrap) {
      setDisplayValuesLoading(true);
    }
    else {
      setSwapButtonDisabled(true)
    }
  }, [
    isLoading,
    stateIsLoading,
    amountIn,
    amountOutSwap,
    tokenIn,
    tokenOut,
    activechain,
    isWrap,
    orderType,
    slippage,
    connected,
    userchain,
    walletTokenBalances[address],
    multihop,
    recipient,
  ]);

  // changed to quoteRefetch
  const handleRefreshQuote = useCallback(async (e: any) => {
    e.preventDefault();
    if (isRefreshing) return;
    setIsRefreshing(true);
    setStateIsLoading(true);
    await quoteRefetch()
    setIsRefreshing(false);
  }, [isRefreshing, quoteRefetch]);

  const handleSetRef = async (used: string) => {
    let lookup
    setIsRefSigning(true);
    if (used !== '') {
      lookup = (await readContracts(config, {
        contracts: [
          {
            abi: CrystalReferralAbi,
            address: settings.chainConfig[activechain].referralManager,
            functionName: 'refCodeToAddress',
            args: [used.toLowerCase()],
          },
        ],
      })) as any[];

      if (lookup[0].result === '0x0000000000000000000000000000000000000000') {
        setError(t('setRefFailed'));
        setIsRefSigning(false);
        return false;
      }
    }

    if (used === '') {
      try {
        await sendUserOperationAsync({
          uo: {
            target: settings.chainConfig[activechain].referralManager,
            data: encodeFunctionData({
              abi: CrystalReferralAbi,
              functionName: 'setUsedRef',
              args: [used],
            }),
            value: 0n,
          },
        });
        setUsedRefLink(used);
        setUsedRefAddress('0x0000000000000000000000000000000000000000')
        setIsRefSigning(false);
        return true;
      } catch {
        setIsRefSigning(false);
        return false;
      }
    } else {
      try {
        await sendUserOperationAsync({
          uo: {
            target: settings.chainConfig[activechain].referralManager,
            data: encodeFunctionData({
              abi: CrystalReferralAbi,
              functionName: 'setUsedRef',
              args: [used],
            }),
            value: 0n,
          },
        });
        setUsedRefLink(used);
        setUsedRefAddress(lookup?.[0].result)
        setIsRefSigning(false);
        return true;
      } catch (error) {
        setIsRefSigning(false);
        return false;
      }
    }
  };

  const formatKeyDisplay = (key: string) => {
    if (!key) return '';
    const keyMap: { [key: string]: string } = {
      'Enter': 'Enter',
      'Escape': 'Esc',
      'Space': 'Space',
      'Slash': '/',
      'Backslash': '\\',
      'Comma': ',',
      'Period': '.',
      'Semicolon': ';',
      'Quote': "'",
      'BracketLeft': '[',
      'BracketRight': ']',
      'Backquote': '`',
      'Minus': '-',
      'Equal': '=',
      'Tab': 'Tab',
      'CapsLock': 'Caps Lock',
      'ShiftLeft': 'Shift',
      'ShiftRight': 'Shift',
      'ControlLeft': 'Ctrl',
      'ControlRight': 'Ctrl',
      'AltLeft': 'Alt',
      'AltRight': 'Alt',
      'MetaLeft': 'Cmd',
      'MetaRight': 'Cmd',
      'ArrowUp': '',
      'ArrowDown': '',
      'ArrowLeft': '',
      'ArrowRight': '',
      'Delete': 'Del',
      'Backspace': '',
    };

    if (keyMap[key]) return keyMap[key];
    if (key.startsWith('Key')) return key.slice(3).toUpperCase();
    if (key.startsWith('Digit')) return key.slice(5);
    if (key.startsWith('F') && key.length <= 3) return key.toUpperCase();
    return key;
  };

  const handleCancelTopOrder = useCallback(async () => {
    if (!connected || userchain !== activechain || orders.length === 0 || isSigning) {
      return;
    }

    try {
      const topOrder = orders[0];
      await cancelOrder(
        sendUserOperationAsync,
        router,
        topOrder[3] == 1
          ? markets[topOrder[4]].quoteAddress
          : markets[topOrder[4]].baseAddress,
        topOrder[3] == 1
          ? markets[topOrder[4]].baseAddress
          : markets[topOrder[4]].quoteAddress,
        BigInt(topOrder[0]),
        BigInt(topOrder[1]),
        BigInt(Math.floor(Date.now() / 1000) + 900)
      );

      refetch();

    } catch {
    }
  }, [connected, userchain, activechain, orders, router, markets, sendUserOperationAsync, refetch, isSigning]);

  const handleCancelAllOrders = useCallback(async () => {
    if (!connected || userchain !== activechain || orders.length === 0 || isSigning) {
      return;
    }

    try {
      const orderbatch: Record<string, any> = {}

      orders.forEach(order => {
        const k = markets[order[4]].address
        if (!orderbatch[k]) orderbatch[k] = []
        orderbatch[k].push({
          isRequireSuccess: false,
          action: 1n,
          param1: order[0], // price
          param2: order[1], // size/id
          param3: BigInt(0),  // cloid or extra id
        })
      })

      const batches: any = Object.entries(orderbatch).map(([market, actions]) => ({
        market: market as `0x${string}`,
        actions,
        options: BigInt(0)
      }))

      await sendUserOperationAsync({
        uo: multiBatchOrders(
          router,
          BigInt(0),
          batches,
          BigInt(Math.floor(Date.now() / 1000) + 900),
          '0x0000000000000000000000000000000000000000',
        )
      });

      refetch();

    } catch {
    }
  }, [connected, userchain, activechain, orders, markets, router, address, sendUserOperationAsync, refetch, isSigning]);

  const handleSubmitTransaction = useCallback(() => {
    if (popup !== 0) return;

    const currentPath = location.pathname.slice(1);
    if (!['swap', 'market', 'limit', 'send', 'scale'].includes(currentPath)) {
      return;
    }

    switch (currentPath) {
      case 'swap':
      case 'market':
        if (!swapButtonDisabled && !displayValuesLoading && !isSigning && connected && userchain === activechain) {
          const swapButton = document.querySelector('.swap-button') as HTMLButtonElement;
          if (swapButton && !swapButton.disabled) {
            swapButton.click();
          }
        }
        break;
      case 'limit':
        if (!limitButtonDisabled && !isSigning && connected && userchain === activechain) {
          const limitButton = document.querySelector('.limit-swap-button') as HTMLButtonElement;
          if (limitButton && !limitButton.disabled) {
            limitButton.click();
          }
        }
        break;
      case 'send':
        if (!sendButtonDisabled && !isSigning && connected && userchain === activechain) {
          const sendButton = document.querySelector('.send-swap-button') as HTMLButtonElement;
          if (sendButton && !sendButton.disabled) {
            sendButton.click();
          }
        }
        break;
      case 'scale':
        if (!scaleButtonDisabled && !isSigning && connected && userchain === activechain) {
          const scaleButton = document.querySelector('.limit-swap-button') as HTMLButtonElement;
          if (scaleButton && !scaleButton.disabled) {
            scaleButton.click();
          }
        }
        break;
    }
  }, [popup, location.pathname, swapButtonDisabled, displayValuesLoading, isSigning, connected, userchain, activechain, limitButtonDisabled, sendButtonDisabled, scaleButtonDisabled]);

  /* useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (isListeningForKey && editingKeybind) {
        event.preventDefault();
        event.stopPropagation();

        const forbiddenKeys = ['F5', 'F11', 'F12', 'Tab', 'AltLeft', 'AltRight', 'ControlLeft', 'ControlRight', 'Escape', 'ArrowUp', 'ArrowDown'];
        if (forbiddenKeys.includes(event.code)) {
          return;
        }

        const existingKeybindEntry = Object.entries(keybinds).find(
          ([key, value]) => value === event.code && key !== editingKeybind
        );

        if (existingKeybindEntry) {
          const [duplicateKey] = existingKeybindEntry;
          setKeybindError(`This key is already assigned to "${duplicateKey}"`);
          setDuplicateKeybind(duplicateKey);
          setTimeout(() => {
            setKeybindError(null);
            setDuplicateKeybind(null);
          }, 3000);

          return;
        }

        const newKeybinds = { ...keybinds, [editingKeybind]: event.code };
        setKeybinds(newKeybinds);
        localStorage.setItem('crystal_keybinds', JSON.stringify(newKeybinds));
        setEditingKeybind(null);
        setIsListeningForKey(false);

        setKeybindError(null);
        setDuplicateKeybind(null);
        return;
      }

      if (isListeningForKey || (popup !== 0 && event.code !== keybinds.cancelTopOrder)) {
        return;
      }

      const activeElement = document.activeElement;
      if (activeElement && event.code !== keybinds.submitTransaction && (
        activeElement.tagName === 'INPUT' ||
        activeElement.tagName === 'TEXTAREA' ||
        activeElement.hasAttribute('contenteditable')
      )) {
        return;
      }

      if (event.code === keybinds.submitTransaction) {
        event.preventDefault();
        handleSubmitTransaction();
        return;
      }

      if (event.code === keybinds.switchTokens && ['swap', 'limit', 'market', 'scale'].includes(location.pathname.slice(1))) {
        event.preventDefault();
        const switchButton = document.querySelector('.switch-button') as HTMLElement;
        if (switchButton) switchButton.click();
        return;
      }

      if (event.code === keybinds.maxAmount && ['swap', 'limit', 'send', 'scale', 'market'].includes(location.pathname.slice(1))) {
        event.preventDefault();
        const maxButton = document.querySelector('.max-button') as HTMLElement;
        if (maxButton) maxButton.click();
        return;
      }

      if (event.code === keybinds.focusInput && ['swap', 'limit', 'send', 'scale', 'market'].includes(location.pathname.slice(1))) {
        event.preventDefault();
        const mainInput = document.querySelector('.input') as HTMLInputElement;
        if (mainInput) mainInput.focus();
        return;
      }

      if (event.code === keybinds.openSettings) {
        event.preventDefault();
        setpopup(5);
        return;
      }

      if (event.code === keybinds.openWallet) {
        event.preventDefault();
        setpopup(4);
        return;
      }

      if (event.code === keybinds.openTokenInSelect && ['swap', 'limit', 'send', 'scale', 'market'].includes(location.pathname.slice(1))) {
        event.preventDefault();
        setpopup(1);
        return;
      }

      if (event.code === keybinds.openTokenOutSelect && ['swap', 'limit', 'scale', 'market'].includes(location.pathname.slice(1))) {
        event.preventDefault();
        setpopup(2);
        return;
      }

      if (event.code === keybinds.cancelAllOrders) {
        event.preventDefault();
        handleCancelAllOrders();
        return;
      }

      if (event.code === keybinds.cancelTopOrder) {
        event.preventDefault();
        handleCancelTopOrder();
        return;
      }

      if (event.code === keybinds.openMarketSearch) {
        event.preventDefault();
        setpopup(8);
        return;
      }

      if (event.code === keybinds.toggleFavorite && activeMarket) {
        event.preventDefault();
        toggleFavorite(activeMarket.baseAddress?.toLowerCase() ?? '');
        return;
      }

      if (event.code === keybinds.toggleSimpleView) {
        event.preventDefault();
        const newSimpleView = !simpleView;
        setSimpleView(newSimpleView);

        if (newSimpleView) {
          navigate('/swap');
        } else {
          navigate('/market');
        }
        return;
      }

      if (event.code === keybinds.refreshQuote && ['swap', 'limit', 'send', 'scale', 'market'].includes(location.pathname.slice(1))) {
        event.preventDefault();
        handleRefreshQuote(event as any);
        return;
      }

      if (isOrderCenterVisible && !simpleView) {
        if (event.code === keybinds.switchToOrders) {
          event.preventDefault();
          setActiveSection('orders');
          localStorage.setItem('crystal_oc_tab', 'orders');
          return;
        }

        if (event.code === keybinds.switchToTrades) {
          event.preventDefault();
          setActiveSection('tradeHistory');
          localStorage.setItem('crystal_oc_tab', 'tradeHistory');
          return;
        }

        if (event.code === keybinds.switchToHistory) {
          event.preventDefault();
          setActiveSection('orderHistory');
          localStorage.setItem('crystal_oc_tab', 'orderHistory');
          return;
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [
    keybinds,
    isListeningForKey,
    editingKeybind,
    popup,
    location.pathname,
    simpleView,
    isOrderCenterVisible,
    activeMarket,
    navigate,
    toggleFavorite,
    setSimpleView,
    setActiveSection,
    handleRefreshQuote,
    handleSubmitTransaction,
    handleCancelAllOrders,
    handleCancelTopOrder,
    setpopup
  ]); */

  const renderKeybindButton = (keybindKey: string, labelText: string, descriptionText: string) => (
    <>
      <div className="keybind-setting-row">
        <div className="keybind-info">
          <span className="keybind-label">{labelText}</span>
          <span className="keybind-description">{descriptionText}</span>
        </div>
        <div className="keybind-button-container">
          <button
            className={`keybind-button ${editingKeybind === keybindKey && isListeningForKey ? 'listening' : ''
              } ${duplicateKeybind === keybindKey ? 'error' : ''
              }`}
            onClick={() => {
              if (editingKeybind === keybindKey && isListeningForKey) {
                setEditingKeybind(null);
                setIsListeningForKey(false);
                setKeybindError(null);
                setDuplicateKeybind(null);
              } else {
                setEditingKeybind(keybindKey);
                setIsListeningForKey(true);
                setKeybindError(null);
                setDuplicateKeybind(null);
              }
            }}
          >
            {editingKeybind === keybindKey && isListeningForKey
              ? t('pressAKey')
              : formatKeyDisplay(keybinds[keybindKey])}
          </button>
        </div>

      </div>
      {keybindError && editingKeybind === keybindKey && (
        <div className="keybind-error-message">
          {keybindError}
        </div>
      )}
    </>
  );

  const [arbUSDCBalance, setarbUSDCBalance] = useState(0n);
  const [arbUSDCAllowance, setarbUSDCAllowance] = useState(0n);
  const perpsDepositDisabled = !perpsDepositAmount || parseFloat(perpsDepositAmount) < 1 || isVaultDepositSigning || (parseFloat(perpsDepositAmount) > (Number(arbUSDCBalance) / 1e6))

  useEffect(() => {
    if (popup != 30 && popup != 31) return;
  
    let disposed = false;
    let inFlight: AbortController | null = null;
  
    const tick = async () => {
      if (disposed) return;
      try {
        inFlight?.abort();
        inFlight = new AbortController();
  
        const rpc = "https://arb1.arbitrum.io/rpc";
        const usdc = "0xaf88d065e77c8cC2239327C5EDb3A432268e5831";
        const spender = "0x81144d6E7084928830f9694a201E8c1ce6eD0cb2";

        const balData = "0x70a08231" + scaAddress.toLowerCase().replace("0x", "").padStart(64, "0");
        const allowanceData = "0xdd62ed3e"
          + scaAddress.toLowerCase().replace("0x", "").padStart(64, "0")
          + spender.replace("0x", "").padStart(64, "0");
  
        const body = JSON.stringify([
          { jsonrpc: "2.0", id: 1, method: "eth_call", params: [{ to: usdc, data: balData }, "latest"] },
          { jsonrpc: "2.0", id: 2, method: "eth_call", params: [{ to: usdc, data: allowanceData }, "latest"] }
        ]);
  
        const res = await fetch(rpc, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          signal: inFlight.signal,
          body
        });
  
        if (!res.ok) return;
  
        const replies = await res.json();
  
        const bal = replies[0]?.result ? BigInt(replies[0].result) : 0n;
        const allowance = replies[1]?.result ? BigInt(replies[1].result) : 0n;
  
        setarbUSDCBalance(bal);
        setarbUSDCAllowance(allowance);
      } catch {}
    };
  
    const handle = setInterval(tick, 3000);
    tick();
  
    return () => { disposed = true; inFlight?.abort(); clearInterval(handle); };
  }, [popup, scaAddress]);

  // input tokenlist
  const TokenList1 = (
    <div className="tokenlistcontainer">
      <ul className="tokenlist">
        {Object.values(tokendict).filter(
          (token) =>
            token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
            token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
            token.address.toLowerCase().includes(tokenString.toLowerCase()),
        ).length === 0 ? (
          <div className="empty-token-list">
            <div className="empty-token-list-content">
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="empty-token-list-icon"
              >
                <circle cx="11" cy="11" r="8" />
                <path d="M21 21l-4.35-4.35" />
              </svg>
              <div className="empty-token-list-text">{t('noTokens')}</div>
            </div>
          </div>
        ) : (
          Object.values(tokendict)
            .filter(
              (token) =>
                token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
                token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
                token.address.toLowerCase().includes(tokenString.toLowerCase()),
            )
            .sort((a, b) => {
              return (Number(tokenBalances[b.address] ?? 0) == 0) !== (Number(tokenBalances[a.address] ?? 0) == 0)
                ? (Number(tokenBalances[a.address] ?? 0) == 0 ? 1 : -1)
                : a?.autofetched && !b?.autofetched ? 1 : !a?.autofetched && b?.autofetched ? -1 : (Number(tokenBalances[b.address] ?? 0) / 10 ** Number(b.decimals)) - (Number(tokenBalances[a.address] ?? 0) / 10 ** Number(a.decimals));
            })
            .map((token, index) => (
              <button
                className={`tokenbutton ${index === selectedTokenIndex ? 'selected' : ''}`}
                key={token.address}
                onMouseEnter={() => setSelectedTokenIndex(index)}
                onClick={() => {
                  if ((location.pathname.slice(1) == 'lending' || location.pathname.slice(1) == 'earn/liquidity') && onSelectTokenCallback) {
                    onSelectTokenCallback({
                      icon: token.image,
                      symbol: token.ticker
                    });
                    setpopup(0);
                    settokenString('');
                    return;
                  }
                  let pricefetchmarket;
                  let newTokenOut;
                  setpopup(0);
                  settokenString('');
                  setTokenIn(token.address);
                  setStateIsLoading(true);
                  if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
                    if (token.address !== tokenOut) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenOut].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenOut].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenOut = tokenOut;
                      } else {
                        const path = findShortestPath(token.address, tokenOut);
                        if (path && path.length > 1 && (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market')) {
                          newTokenOut = tokenOut;
                        } else {
                          let found = false;
                          for (const market in markets) {
                            if (
                              markets[market].baseAddress === token.address
                            ) {
                              setTokenOut(markets[market].quoteAddress);
                              newTokenOut = markets[market].quoteAddress;
                              found = true;
                              break;
                            }
                          }
                          if (!found) {
                            for (const market in markets) {
                              if (
                                markets[market].quoteAddress === token.address
                              ) {
                                setTokenOut(markets[market].baseAddress);
                                newTokenOut = markets[market].baseAddress;
                                break;
                              }
                            }
                          }
                        }
                      }
                      if (
                        (tokenOut == eth && token.address == weth) ||
                        (tokenOut == weth && token.address == eth)
                      ) {
                        if (switched == false) {
                          setamountIn((amountIn * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenIn].decimals)
                          setamountOutSwap((amountIn * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenIn].decimals);
                          setoutputString(inputString);
                          const percentage = !tokenBalances[token.address]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  ((amountIn * BigInt(10) ** token.decimals) /
                                    BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                  tokenBalances[token.address],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                        else {
                          setamountIn(amountOutSwap);
                          setInputString(outputString);
                          const percentage = !tokenBalances[token.address]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  (amountOutSwap * BigInt(100)) /
                                  tokenBalances[token.address],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                      } else {
                        if (switched === false && token.address != tokenIn) {
                          setamountIn(
                            (amountIn * BigInt(10) ** token.decimals) /
                            BigInt(10) ** tokendict[tokenIn].decimals
                          );
                          setamountOutSwap(BigInt(0));
                          setoutputString('');
                          const percentage = !tokenBalances[token.address]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  ((amountIn * BigInt(10) ** token.decimals) /
                                    BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                  tokenBalances[token.address],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        } else if (newTokenOut != tokenOut) {
                          setamountOutSwap(
                            (amountOutSwap *
                              BigInt(10) ** tokendict[newTokenOut].decimals) /
                            BigInt(10) ** tokendict[tokenOut].decimals,
                          );
                          setamountIn(BigInt(0));
                          setInputString('');
                        }
                      }
                      setlimitChase(true);
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                    } else {
                      setTokenOut(tokenIn);
                      if (
                        (amountIn != BigInt(0) || amountOutSwap != BigInt(0)) &&
                        !isWrap
                      ) {
                        if (switched == false) {
                          setswitched(true);
                          setStateIsLoading(true);
                          setInputString('');
                          setamountIn(BigInt(0));
                          setamountOutSwap(amountIn);
                          setoutputString(
                            amountIn === BigInt(0)
                              ? ''
                              : String(
                                customRound(
                                  Number(amountIn) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                ),
                              ),
                          );
                        } else {
                          setswitched(false);
                          setStateIsLoading(true);
                          setoutputString('');
                          setamountOutSwap(BigInt(0));
                          setamountIn(amountOutSwap);
                          setInputString(
                            amountOutSwap === BigInt(0)
                              ? ''
                              : String(
                                customRound(
                                  Number(amountOutSwap) /
                                  10 **
                                  Number(tokendict[tokenOut].decimals),
                                  3,
                                ),
                              ),
                          );
                          const percentage = !tokenBalances[tokenOut]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  (amountOutSwap * BigInt(100)) /
                                  tokenBalances[tokenOut],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                      }
                    }
                  } else if (location.pathname.slice(1) == 'limit') {
                    if ((token.address == weth ? eth : token.address) != (tokenOut == weth ? eth : tokenOut)) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenOut].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenOut].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenOut = tokenOut;
                      } else {
                        let found = false;
                        for (const market in markets) {
                          if (
                            markets[market].baseAddress === token.address
                          ) {
                            newTokenOut = markets[market].quoteAddress;
                            setTokenOut(markets[market].quoteAddress);
                            found = true;
                            break;
                          }
                        }
                        if (!found) {
                          for (const market in markets) {
                            if (markets[market].quoteAddress === token.address) {
                              newTokenOut = markets[market].baseAddress;
                              setTokenOut(markets[market].baseAddress);
                              break;
                            }
                          }
                        }
                      }
                      if (switched) {
                        setamountOutSwap(
                          (amountOutSwap * BigInt(10) ** tokendict[newTokenOut].decimals) /
                          BigInt(10) ** tokendict[tokenOut].decimals
                        )
                      }
                      else {
                        setamountIn(
                          (amountIn * BigInt(10) ** token.decimals) /
                          BigInt(10) ** tokendict[tokenIn].decimals
                        );
                        const percentage = !tokenBalances[token.address]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                ((amountIn * BigInt(10) ** token.decimals) /
                                  BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                tokenBalances[token.address],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                      setlimitChase(true);
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                    } else {
                      setTokenOut(tokenIn);
                      setswitched((switched) => { return !switched });
                      if (amountIn != BigInt(0)) {
                        if (limitChase && mids?.[activeMarketKey]?.[0]) {
                          const price = tokenOut === activeMarket?.baseAddress ? mids[activeMarketKey][0] == mids[activeMarketKey][1] ? mids[activeMarketKey][2] : mids[activeMarketKey][0] : mids[activeMarketKey][0] == mids[activeMarketKey][2] ? mids[activeMarketKey][1] : mids[activeMarketKey][0]
                          setlimitPrice(price);
                          setlimitPriceString(
                            (
                              Number(price) / Number(activeMarket.priceFactor)
                            ).toFixed(Math.floor(Math.log10(activeMarket?.marketType != 0 ? Math.min(10 ** Math.max(0, 5 - Math.floor(Math.log10((Number(price) / Number(activeMarket.priceFactor)) || 1)) - 1), Number(activeMarket.priceFactor)) : Number(activeMarket.priceFactor)))),
                          );
                          setamountOutSwap(
                            price != BigInt(0) && amountIn != BigInt(0)
                              ? tokenOut === activeMarket?.baseAddress
                                ? (amountIn * price) /
                                (activeMarket.scaleFactor || BigInt(1))
                                : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                                price
                              : BigInt(0),
                          );
                          setoutputString(
                            (price != BigInt(0) && amountIn != BigInt(0)
                              ? tokenOut === activeMarket?.baseAddress
                                ? customRound(
                                  Number(
                                    (amountIn * price) /
                                    (activeMarket.scaleFactor || BigInt(1)),
                                  ) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                )
                                : customRound(
                                  Number(
                                    (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                                    price,
                                  ) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        setInputString(outputString);
                        setoutputString(inputString);
                        setamountIn(amountOutSwap);
                        setamountOutSwap(amountIn);
                        const percentage = !tokenBalances[tokenOut]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (amountOutSwap * BigInt(100)) /
                                tokenBalances[tokenOut],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                    }
                  } else if (location.pathname.slice(1) == 'send') {
                    if (token.address == tokenIn) return;
                    setlimitChase(true);
                    setScaleStart(BigInt(0))
                    setScaleEnd(BigInt(0))
                    setScaleStartString('')
                    setScaleEndString('')
                    if (((token.address == weth ? eth : token.address) != (tokenOut == weth ? eth : tokenOut)) && multihop == false) {
                      setTokenOut(tokenIn);
                      pricefetchmarket = getMarket(token.address, tokenIn);
                    } else if (
                      markets[
                      `${tokendict[token.address].ticker}${tokendict[tokenOut].ticker}`
                      ] ||
                      markets[
                      `${tokendict[tokenOut].ticker}${tokendict[token.address].ticker}`
                      ]
                    ) {
                      pricefetchmarket = getMarket(token.address, tokenOut);
                    } else {
                      let found = false;
                      for (const market in markets) {
                        if (
                          markets[market].baseAddress === token.address
                        ) {
                          setTokenOut(markets[market].quoteAddress);
                          pricefetchmarket = getMarket(
                            token.address,
                            markets[market].quoteAddress,
                          );
                          found = true;
                          break;
                        }
                      }
                      if (!found) {
                        for (const market in markets) {
                          if (markets[market].quoteAddress === token.address) {
                            setTokenOut(markets[market].baseAddress);
                            pricefetchmarket = getMarket(
                              token.address,
                              markets[market].baseAddress,
                            );
                            break;
                          }
                        }
                      }
                    }
                    if (displayMode == 'usd') {
                      setInputString(
                        customRound(
                          Number(
                            calculateTokenAmount(
                              sendInputString.replace(/^\$|,/g, ''),
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(pricefetchmarket)
                              ],
                              token.address,
                              pricefetchmarket,
                            ),
                          ) /
                          10 ** Number(token.decimals),
                          3,
                        ).toString(),
                      );
                      setamountIn(
                        calculateTokenAmount(
                          sendInputString.replace(/^\$|,/g, ''),
                          tradesByMarket[
                          (({ baseAsset, quoteAsset }) =>
                            (baseAsset === wethticker ? ethticker : baseAsset) +
                            (quoteAsset === wethticker ? ethticker : quoteAsset)
                          )(pricefetchmarket)
                          ],
                          token.address,
                          pricefetchmarket,
                        ),
                      );
                      const percentage = !tokenBalances[token.address]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (calculateTokenAmount(
                                sendInputString.replace(/^\$|,/g, ''),
                                tradesByMarket[
                                (({ baseAsset, quoteAsset }) =>
                                  (baseAsset === wethticker ? ethticker : baseAsset) +
                                  (quoteAsset === wethticker ? ethticker : quoteAsset)
                                )(pricefetchmarket)
                                ],
                                token.address,
                                pricefetchmarket,
                              ) * BigInt(100)) /
                              tokenBalances[token.address],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    } else {
                      setamountIn(
                        (amountIn * BigInt(10) ** token.decimals) /
                        BigInt(10) ** tokendict[tokenIn].decimals
                      );
                      setsendInputString(
                        `$${calculateUSDValue(
                          (amountIn * BigInt(10) ** token.decimals) /
                          BigInt(10) ** tokendict[tokenIn].decimals,
                          tradesByMarket[
                          (({ baseAsset, quoteAsset }) =>
                            (baseAsset === wethticker ? ethticker : baseAsset) +
                            (quoteAsset === wethticker ? ethticker : quoteAsset)
                          )(pricefetchmarket)
                          ],
                          token.address,
                          pricefetchmarket,
                        ).toFixed(2)}`,
                      );
                      const percentage = !tokenBalances[token.address]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              ((amountIn * BigInt(10) ** token.decimals) /
                                BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                              tokenBalances[token.address],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    }
                  } else if (location.pathname.slice(1) == 'scale') {
                    if ((token.address == weth ? eth : token.address) != (tokenOut == weth ? eth : tokenOut)) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenOut].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenOut].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                      } else {
                        let found = false;
                        for (const market in markets) {
                          if (
                            markets[market].baseAddress === token.address
                          ) {
                            setTokenOut(markets[market].quoteAddress);
                            found = true;
                            break;
                          }
                        }
                        if (!found) {
                          for (const market in markets) {
                            if (markets[market].quoteAddress === token.address) {
                              setTokenOut(markets[market].baseAddress);
                              break;
                            }
                          }
                        }
                      }
                      setamountIn(
                        BigInt(0)
                      );
                      setInputString('')
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                      setlimitChase(true);
                      const percentage = !tokenBalances[token.address]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              BigInt(0) /
                              tokenBalances[token.address],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    } else {
                      setTokenOut(tokenIn);
                      setswitched((switched) => { return !switched });
                      if (amountIn != BigInt(0) && scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                        setInputString(outputString);
                        setoutputString(inputString);
                        setamountIn(amountOutSwap);
                        setamountOutSwap(amountIn);
                        const percentage = !tokenBalances[tokenOut]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (amountOutSwap * BigInt(100)) /
                                tokenBalances[tokenOut],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                      else {
                        setamountIn(BigInt(0))
                        setInputString('')
                      }
                    }
                  }
                }}
              >
                <img className="tokenlistimage" src={token.image} />
                <div className="tokenlisttext">
                  <div className="tokenlistname">
                    {token.ticker}
                  </div>
                  <div className="tokenlistticker">{token.name}</div>
                </div>
                <div className="token-right-content">
                  <div className="tokenlistbalance">
                    {formatSubscript(customRound(
                      Number(tokenBalances[token.address] ?? 0) /
                      10 ** Number(token.decimals ?? 18),
                      3,
                    )
                      .replace(/(\.\d*?[1-9])0+$/g, '$1')
                      .replace(/\.0+$/, ''))}
                  </div>
                  <div className="token-address-container">
                    <span className="token-address">
                      {`${token.address.slice(0, 6)}...${token.address.slice(-4)}`}
                    </span>
                    <div
                      className="copy-address-button"
                      onClick={(e) => {
                        e.stopPropagation();
                        navigator.clipboard.writeText(token.address);
                        const copyIcon =
                          e.currentTarget.querySelector('.copy-icon');
                        const checkIcon =
                          e.currentTarget.querySelector('.check-icon');
                        if (copyIcon && checkIcon) {
                          copyIcon.classList.add('hidden');
                          checkIcon.classList.add('visible');
                          setTimeout(() => {
                            copyIcon.classList.remove('hidden');
                            checkIcon.classList.remove('visible');
                          }, 2000);
                        }
                      }}
                    >
                      <svg
                        className="copy-icon"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <rect
                          x="9"
                          y="9"
                          width="13"
                          height="13"
                          rx="2"
                          ry="2"
                        ></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                      </svg>
                      <svg
                        className="check-icon"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <circle cx="12" cy="12" r="10" />
                        <path d="M8 12l3 3 6-6" />
                      </svg>
                    </div>
                  </div>
                </div>
              </button>
            ))
        )}
      </ul>
    </div>
  );

  // output tokenlist
  const TokenList2 = (
    <div className="tokenlistcontainer">
      <ul className="tokenlist">
        {Object.values(tokendict).filter(
          (token) =>
            token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
            token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
            token.address.toLowerCase().includes(tokenString.toLowerCase()),
        ).length === 0 ? (
          <div className="empty-token-list">
            <div className="empty-token-list-content">
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="empty-token-list-icon"
              >
                <circle cx="11" cy="11" r="8" />
                <path d="M21 21l-4.35-4.35" />
              </svg>
              <div className="empty-token-list-text">{t('noTokens')}</div>
            </div>
          </div>
        ) : (
          Object.values(tokendict)
            .filter(
              (token) =>
                token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
                token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
                token.address.toLowerCase().includes(tokenString.toLowerCase()),
            )
            .map((token, index) => (
              <button
                className={`tokenbutton ${index === selectedTokenIndex ? 'selected' : ''}`}
                key={token.address}
                onMouseEnter={() => setSelectedTokenIndex(index)}
                onClick={() => {
                  let newTokenIn;
                  setpopup(0);
                  settokenString('');
                  setTokenOut(token.address);
                  setStateIsLoading(true);
                  if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
                    if (token.address != tokenIn) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenIn].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenIn].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenIn = tokenIn;
                      } else {
                        const path = findShortestPath(
                          tokendict[tokenIn].address,
                          token.address,
                        );
                        if (path && path.length > 1) {
                          newTokenIn = tokenIn;
                        } else {
                          let found = false;
                          for (const market in markets) {
                            if (
                              markets[market].baseAddress === token.address
                            ) {
                              setTokenIn(markets[market].quoteAddress);
                              newTokenIn = markets[market].quoteAddress;
                              found = true;
                              break;
                            }
                          }
                          if (!found) {
                            for (const market in markets) {
                              if (
                                markets[market].quoteAddress === token.address
                              ) {
                                setTokenIn(markets[market].baseAddress);
                                newTokenIn = markets[market].baseAddress;
                                break;
                              }
                            }
                          }
                        }
                      }
                      if (
                        (tokenIn == eth && token.address == weth) ||
                        (tokenIn == weth && token.address == eth)
                      ) {
                        if (switched == false) {
                          setamountOutSwap(amountIn);
                          setoutputString(inputString);
                        }
                        else {
                          setamountOutSwap((amountOutSwap * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenOut].decimals)
                          setamountIn((amountOutSwap * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenOut].decimals);
                          setInputString(outputString);
                          const percentage = !tokenBalances[tokenIn]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  ((amountOutSwap * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenOut].decimals * BigInt(100)) /
                                  tokenBalances[tokenIn],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                      } else {
                        if (switched == false) {
                          setamountIn(
                            (amountIn *
                              BigInt(10) ** tokendict[newTokenIn].decimals) /
                            BigInt(10) ** tokendict[tokenIn].decimals
                          );
                          setamountOutSwap(BigInt(0));
                          setoutputString('');
                          const percentage = !tokenBalances[newTokenIn]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  ((amountIn *
                                    BigInt(10) ** tokendict[newTokenIn].decimals) /
                                    BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                  tokenBalances[newTokenIn],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        } else if (token.address != tokenOut) {
                          setamountOutSwap(
                            (amountOutSwap * BigInt(10) ** token.decimals) /
                            BigInt(10) ** tokendict[tokenOut].decimals,
                          );
                          setamountIn(BigInt(0));
                          setInputString('');
                        }
                      }
                      setlimitChase(true);
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                    } else {
                      setTokenIn(tokenOut);
                      if (
                        (amountIn != BigInt(0) || amountOutSwap != BigInt(0)) &&
                        !isWrap
                      ) {
                        if (switched == false) {
                          setswitched(true);
                          setStateIsLoading(true);
                          setInputString('');
                          setamountIn(BigInt(0));
                          setamountOutSwap(amountIn);
                          setoutputString(
                            amountIn === BigInt(0)
                              ? ''
                              : String(
                                customRound(
                                  Number(amountIn) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                ),
                              ),
                          );
                        } else {
                          setswitched(false);
                          setStateIsLoading(true);
                          setoutputString('');
                          setamountOutSwap(BigInt(0));
                          setamountIn(amountOutSwap);
                          setInputString(
                            amountOutSwap === BigInt(0)
                              ? ''
                              : String(
                                customRound(
                                  Number(amountOutSwap) /
                                  10 **
                                  Number(tokendict[tokenOut].decimals),
                                  3,
                                ),
                              ),
                          );
                          const percentage = !tokenBalances[tokenOut]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  (amountOutSwap * BigInt(100)) /
                                  tokenBalances[tokenOut],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                      }
                    }
                  } else if (location.pathname.slice(1) == 'limit') {
                    if ((token.address == weth ? eth : token.address) != (tokenIn == weth ? eth : tokenIn)) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenIn].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenIn].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenIn = tokenIn;
                      } else {
                        let found = false;
                        for (const market in markets) {
                          if (
                            markets[market].baseAddress === token.address
                          ) {
                            setTokenIn(markets[market].quoteAddress);
                            newTokenIn = markets[market].quoteAddress;
                            found = true;
                            break;
                          }
                        }
                        if (!found) {
                          for (const market in markets) {
                            if (markets[market].quoteAddress === token.address) {
                              setTokenIn(markets[market].baseAddress);
                              newTokenIn = markets[market].baseAddress;
                              break;
                            }
                          }
                        }
                      }
                      if (switched) {
                        setamountOutSwap(
                          (amountOutSwap * BigInt(10) ** token.decimals) /
                          BigInt(10) ** tokendict[tokenOut].decimals
                        )
                      }
                      else {
                        setamountIn(
                          (amountIn *
                            BigInt(10) ** tokendict[newTokenIn].decimals) /
                          BigInt(10) ** tokendict[tokenIn].decimals,
                        );
                        const percentage = !tokenBalances[newTokenIn]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                ((amountIn * BigInt(10) ** tokendict[newTokenIn].decimals) /
                                  BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                tokenBalances[newTokenIn],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                      setlimitChase(true);
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                    } else {
                      setTokenIn(tokenOut);
                      setswitched((switched) => { return !switched });
                      if (amountIn != BigInt(0)) {
                        if (limitChase && mids?.[activeMarketKey]?.[0]) {
                          const price = tokenOut === activeMarket?.baseAddress ? mids[activeMarketKey][0] == mids[activeMarketKey][1] ? mids[activeMarketKey][2] : mids[activeMarketKey][0] : mids[activeMarketKey][0] == mids[activeMarketKey][2] ? mids[activeMarketKey][1] : mids[activeMarketKey][0]
                          setlimitPrice(price);
                          setlimitPriceString(
                            (
                              Number(price) / Number(activeMarket.priceFactor)
                            ).toFixed(Math.floor(Math.log10(activeMarket?.marketType != 0 ? Math.min(10 ** Math.max(0, 5 - Math.floor(Math.log10((Number(price) / Number(activeMarket.priceFactor)) || 1)) - 1), Number(activeMarket.priceFactor)) : Number(activeMarket.priceFactor)))),
                          );
                          setamountOutSwap(
                            price != BigInt(0) && amountIn != BigInt(0)
                              ? tokenOut === activeMarket?.baseAddress
                                ? (amountIn * price) /
                                (activeMarket.scaleFactor || BigInt(1))
                                : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                                price
                              : BigInt(0),
                          );
                          setoutputString(
                            (price != BigInt(0) && amountIn != BigInt(0)
                              ? tokenOut === activeMarket?.baseAddress
                                ? customRound(
                                  Number(
                                    (amountIn * price) /
                                    (activeMarket.scaleFactor || BigInt(1)),
                                  ) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                )
                                : customRound(
                                  Number(
                                    (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                                    price,
                                  ) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        setInputString(outputString);
                        setoutputString(inputString);
                        setamountIn(amountOutSwap);
                        setamountOutSwap(amountIn);
                        const percentage = !tokenBalances[tokenOut]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (amountOutSwap * BigInt(100)) /
                                tokenBalances[tokenOut],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                    }
                  } else if (location.pathname.slice(1) == 'scale') {
                    if ((token.address == weth ? eth : token.address) != (tokenIn == weth ? eth : tokenIn)) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenIn].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenIn].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenIn = tokenIn;
                      } else {
                        let found = false;
                        for (const market in markets) {
                          if (
                            markets[market].baseAddress === token.address
                          ) {
                            setTokenIn(markets[market].quoteAddress);
                            newTokenIn = markets[market].quoteAddress;
                            found = true;
                            break;
                          }
                        }
                        if (!found) {
                          for (const market in markets) {
                            if (markets[market].quoteAddress === token.address) {
                              setTokenIn(markets[market].baseAddress);
                              newTokenIn = markets[market].baseAddress;
                              break;
                            }
                          }
                        }
                      }
                      setamountIn(
                        BigInt(0)
                      );
                      setInputString('')
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                      setlimitChase(true);
                      const percentage = !tokenBalances[newTokenIn]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              BigInt(0) /
                              tokenBalances[newTokenIn],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    } else {
                      setTokenIn(tokenOut);
                      setswitched((switched) => { return !switched });
                      if (amountIn != BigInt(0) && scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                        setInputString(outputString);
                        setoutputString(inputString);
                        setamountIn(amountOutSwap);
                        setamountOutSwap(amountIn);
                        const percentage = !tokenBalances[tokenOut]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (amountOutSwap * BigInt(100)) /
                                tokenBalances[tokenOut],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                      else {
                        setamountIn(BigInt(0))
                        setInputString('')
                      }
                    }
                  }
                }}
              >
                <img className="tokenlistimage" src={token.image} />
                <div className="tokenlisttext">
                  <div className="tokenlistname">
                    {token.ticker}
                  </div>
                  <div className="tokenlistticker">{token.name}</div>
                </div>
                <div className="token-right-content">
                  <div className="tokenlistbalance">
                    {formatSubscript(customRound(
                      Number(tokenBalances[token.address] ?? 0) /
                      10 ** Number(token.decimals ?? 18),
                      3,
                    )
                      .replace(/(\.\d*?[1-9])0+$/g, '$1')
                      .replace(/\.0+$/, ''))}
                  </div>
                  <div className="token-address-container">
                    <span className="token-address">
                      {`${token.address.slice(0, 6)}...${token.address.slice(-4)}`}
                    </span>
                    <div
                      className="copy-address-button"
                      onClick={(e) => {
                        e.stopPropagation();
                        navigator.clipboard.writeText(token.address);
                        const copyIcon =
                          e.currentTarget.querySelector('.copy-icon');
                        const checkIcon =
                          e.currentTarget.querySelector('.check-icon');
                        if (copyIcon && checkIcon) {
                          copyIcon.classList.add('hidden');
                          checkIcon.classList.add('visible');
                          setTimeout(() => {
                            copyIcon.classList.remove('hidden');
                            checkIcon.classList.remove('visible');
                          }, 2000);
                        }
                      }}
                    >
                      <svg
                        className="copy-icon"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <rect
                          x="9"
                          y="9"
                          width="13"
                          height="13"
                          rx="2"
                          ry="2"
                        ></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                      </svg>
                      <svg
                        className="check-icon"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <circle cx="12" cy="12" r="10" />
                        <path d="M8 12l3 3 6-6" />
                      </svg>
                    </div>
                  </div>
                </div>
              </button>
            ))
        )}
      </ul>
    </div>
  );

  // input tokenlist
  const tempTokenList1 = (
    <div className="tokenlistcontainer">
      <ul className="tokenlist">
        {Object.values(tokendict).filter(
          (token) =>
            token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
            token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
            token.address.toLowerCase().includes(tokenString.toLowerCase()),
        ).length === 0 ? (
          <div className="empty-token-list">
            <div className="empty-token-list-content">
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="empty-token-list-icon"
              >
                <circle cx="11" cy="11" r="8" />
                <path d="M21 21l-4.35-4.35" />
              </svg>
              <div className="empty-token-list-text">{t('noTokens')}</div>
            </div>
          </div>
        ) : (
          Object.values(tokendict)
            .filter(
              (token) =>
                token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
                token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
                token.address.toLowerCase().includes(tokenString.toLowerCase()),
            )
            .sort((a, b) => {
              return (Number(walletTokenBalances[address]?.[b.address] ?? 0) == 0) !== (Number(walletTokenBalances[address]?.[a.address] ?? 0) == 0)
                ? (Number(walletTokenBalances[address]?.[a.address] ?? 0) == 0 ? 1 : -1)
                : a?.autofetched && !b?.autofetched ? 1 : !a?.autofetched && b?.autofetched ? -1 : (Number(walletTokenBalances[address]?.[b.address] ?? 0) / 10 ** Number(b.decimals)) - (Number(walletTokenBalances[address]?.[a.address] ?? 0) / 10 ** Number(a.decimals));
            })
            .map((token, index) => (
              <button
                className={`tokenbutton ${index === selectedTokenIndex ? 'selected' : ''}`}
                key={token.address}
                onMouseEnter={() => setSelectedTokenIndex(index)}
                onClick={() => {
                  if ((location.pathname.slice(1) == 'lending' || location.pathname.slice(1) == 'earn/liquidity') && onSelectTokenCallback) {
                    onSelectTokenCallback({
                      icon: token.image,
                      symbol: token.ticker
                    });
                    setpopup(0);
                    settokenString('');
                    return;
                  }
                  let pricefetchmarket;
                  let newTokenOut;
                  setpopup(0);
                  settokenString('');
                  setTokenIn(token.address);
                  setStateIsLoading(true);
                  if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
                    if (token.address !== tokenOut) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenOut].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenOut].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenOut = tokenOut;
                      } else {
                        const path = findShortestPath(token.address, tokenOut);
                        if (path && path.length > 1 && (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market')) {
                          newTokenOut = tokenOut;
                        } else {
                          let found = false;
                          for (const market in markets) {
                            if (
                              markets[market].baseAddress === token.address
                            ) {
                              setTokenOut(markets[market].quoteAddress);
                              newTokenOut = markets[market].quoteAddress;
                              found = true;
                              break;
                            }
                          }
                          if (!found) {
                            for (const market in markets) {
                              if (
                                markets[market].quoteAddress === token.address
                              ) {
                                setTokenOut(markets[market].baseAddress);
                                newTokenOut = markets[market].baseAddress;
                                break;
                              }
                            }
                          }
                        }
                      }
                      if (
                        (tokenOut == eth && token.address == weth) ||
                        (tokenOut == weth && token.address == eth)
                      ) {
                        if (switched == false) {
                          setamountIn((amountIn * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenIn].decimals)
                          setamountOutSwap((amountIn * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenIn].decimals);
                          setoutputString(inputString);
                          const percentage = !walletTokenBalances[address]?.[token.address]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  ((amountIn * BigInt(10) ** token.decimals) /
                                    BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                  walletTokenBalances[address]?.[token.address],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                        else {
                          setamountIn(amountOutSwap);
                          setInputString(outputString);
                          const percentage = !walletTokenBalances[address]?.[token.address]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  (amountOutSwap * BigInt(100)) /
                                  walletTokenBalances[address]?.[token.address],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                      } else {
                        if (switched === false && token.address != tokenIn) {
                          setamountIn(
                            (amountIn * BigInt(10) ** token.decimals) /
                            BigInt(10) ** tokendict[tokenIn].decimals
                          );
                          setamountOutSwap(BigInt(0));
                          setoutputString('');
                          const percentage = !walletTokenBalances[address]?.[token.address]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  ((amountIn * BigInt(10) ** token.decimals) /
                                    BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                  walletTokenBalances[address]?.[token.address],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        } else if (newTokenOut != tokenOut) {
                          setamountOutSwap(
                            (amountOutSwap *
                              BigInt(10) ** tokendict[newTokenOut].decimals) /
                            BigInt(10) ** tokendict[tokenOut].decimals,
                          );
                          setamountIn(BigInt(0));
                          setInputString('');
                        }
                      }
                      setlimitChase(true);
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                    } else {
                      setTokenOut(tokenIn);
                      if (
                        (amountIn != BigInt(0) || amountOutSwap != BigInt(0)) &&
                        !isWrap
                      ) {
                        if (switched == false) {
                          setswitched(true);
                          setStateIsLoading(true);
                          setInputString('');
                          setamountIn(BigInt(0));
                          setamountOutSwap(amountIn);
                          setoutputString(
                            amountIn === BigInt(0)
                              ? ''
                              : String(
                                customRound(
                                  Number(amountIn) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                ),
                              ),
                          );
                        } else {
                          setswitched(false);
                          setStateIsLoading(true);
                          setoutputString('');
                          setamountOutSwap(BigInt(0));
                          setamountIn(amountOutSwap);
                          setInputString(
                            amountOutSwap === BigInt(0)
                              ? ''
                              : String(
                                customRound(
                                  Number(amountOutSwap) /
                                  10 **
                                  Number(tokendict[tokenOut].decimals),
                                  3,
                                ),
                              ),
                          );
                          const percentage = !walletTokenBalances[address]?.[tokenOut]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  (amountOutSwap * BigInt(100)) /
                                  walletTokenBalances[address]?.[tokenOut],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                      }
                    }
                  } else if (location.pathname.slice(1) == 'limit') {
                    if ((token.address == weth ? eth : token.address) != (tokenOut == weth ? eth : tokenOut)) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenOut].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenOut].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenOut = tokenOut;
                      } else {
                        let found = false;
                        for (const market in markets) {
                          if (
                            markets[market].baseAddress === token.address
                          ) {
                            newTokenOut = markets[market].quoteAddress;
                            setTokenOut(markets[market].quoteAddress);
                            found = true;
                            break;
                          }
                        }
                        if (!found) {
                          for (const market in markets) {
                            if (markets[market].quoteAddress === token.address) {
                              newTokenOut = markets[market].baseAddress;
                              setTokenOut(markets[market].baseAddress);
                              break;
                            }
                          }
                        }
                      }
                      if (switched) {
                        setamountOutSwap(
                          (amountOutSwap * BigInt(10) ** tokendict[newTokenOut].decimals) /
                          BigInt(10) ** tokendict[tokenOut].decimals
                        )
                      }
                      else {
                        setamountIn(
                          (amountIn * BigInt(10) ** token.decimals) /
                          BigInt(10) ** tokendict[tokenIn].decimals
                        );
                        const percentage = !walletTokenBalances[address]?.[token.address]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                ((amountIn * BigInt(10) ** token.decimals) /
                                  BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                walletTokenBalances[address]?.[token.address],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                      setlimitChase(true);
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                    } else {
                      setTokenOut(tokenIn);
                      setswitched((switched) => { return !switched });
                      if (amountIn != BigInt(0)) {
                        if (limitChase && mids?.[activeMarketKey]?.[0]) {
                          const price = tokenOut === activeMarket?.baseAddress ? mids[activeMarketKey][0] == mids[activeMarketKey][1] ? mids[activeMarketKey][2] : mids[activeMarketKey][0] : mids[activeMarketKey][0] == mids[activeMarketKey][2] ? mids[activeMarketKey][1] : mids[activeMarketKey][0]
                          setlimitPrice(price);
                          setlimitPriceString(
                            (
                              Number(price) / Number(activeMarket.priceFactor)
                            ).toFixed(Math.floor(Math.log10(activeMarket?.marketType != 0 ? Math.min(10 ** Math.max(0, 5 - Math.floor(Math.log10((Number(price) / Number(activeMarket.priceFactor)) || 1)) - 1), Number(activeMarket.priceFactor)) : Number(activeMarket.priceFactor)))),
                          );
                          setamountOutSwap(
                            price != BigInt(0) && amountIn != BigInt(0)
                              ? tokenOut === activeMarket?.baseAddress
                                ? (amountIn * price) /
                                (activeMarket.scaleFactor || BigInt(1))
                                : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                                price
                              : BigInt(0),
                          );
                          setoutputString(
                            (price != BigInt(0) && amountIn != BigInt(0)
                              ? tokenOut === activeMarket?.baseAddress
                                ? customRound(
                                  Number(
                                    (amountIn * price) /
                                    (activeMarket.scaleFactor || BigInt(1)),
                                  ) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                )
                                : customRound(
                                  Number(
                                    (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                                    price,
                                  ) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        setInputString(outputString);
                        setoutputString(inputString);
                        setamountIn(amountOutSwap);
                        setamountOutSwap(amountIn);
                        const percentage = !walletTokenBalances[address]?.[tokenOut]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (amountOutSwap * BigInt(100)) /
                                walletTokenBalances[address]?.[tokenOut],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                    }
                  } else if (location.pathname.slice(1) == 'send') {
                    if (token.address == tokenIn) return;
                    setlimitChase(true);
                    setScaleStart(BigInt(0))
                    setScaleEnd(BigInt(0))
                    setScaleStartString('')
                    setScaleEndString('')
                    if (((token.address == weth ? eth : token.address) != (tokenOut == weth ? eth : tokenOut)) && multihop == false) {
                      setTokenOut(tokenIn);
                      pricefetchmarket = getMarket(token.address, tokenIn);
                    } else if (
                      markets[
                      `${tokendict[token.address].ticker}${tokendict[tokenOut].ticker}`
                      ] ||
                      markets[
                      `${tokendict[tokenOut].ticker}${tokendict[token.address].ticker}`
                      ]
                    ) {
                      pricefetchmarket = getMarket(token.address, tokenOut);
                    } else {
                      let found = false;
                      for (const market in markets) {
                        if (
                          markets[market].baseAddress === token.address
                        ) {
                          setTokenOut(markets[market].quoteAddress);
                          pricefetchmarket = getMarket(
                            token.address,
                            markets[market].quoteAddress,
                          );
                          found = true;
                          break;
                        }
                      }
                      if (!found) {
                        for (const market in markets) {
                          if (markets[market].quoteAddress === token.address) {
                            setTokenOut(markets[market].baseAddress);
                            pricefetchmarket = getMarket(
                              token.address,
                              markets[market].baseAddress,
                            );
                            break;
                          }
                        }
                      }
                    }
                    if (displayMode == 'usd') {
                      setInputString(
                        customRound(
                          Number(
                            calculateTokenAmount(
                              sendInputString.replace(/^\$|,/g, ''),
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(pricefetchmarket)
                              ],
                              token.address,
                              pricefetchmarket,
                            ),
                          ) /
                          10 ** Number(token.decimals),
                          3,
                        ).toString(),
                      );
                      setamountIn(
                        calculateTokenAmount(
                          sendInputString.replace(/^\$|,/g, ''),
                          tradesByMarket[
                          (({ baseAsset, quoteAsset }) =>
                            (baseAsset === wethticker ? ethticker : baseAsset) +
                            (quoteAsset === wethticker ? ethticker : quoteAsset)
                          )(pricefetchmarket)
                          ],
                          token.address,
                          pricefetchmarket,
                        ),
                      );
                      const percentage = !walletTokenBalances[address]?.[token.address]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (calculateTokenAmount(
                                sendInputString.replace(/^\$|,/g, ''),
                                tradesByMarket[
                                (({ baseAsset, quoteAsset }) =>
                                  (baseAsset === wethticker ? ethticker : baseAsset) +
                                  (quoteAsset === wethticker ? ethticker : quoteAsset)
                                )(pricefetchmarket)
                                ],
                                token.address,
                                pricefetchmarket,
                              ) * BigInt(100)) /
                              walletTokenBalances[address]?.[token.address],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    } else {
                      setamountIn(
                        (amountIn * BigInt(10) ** token.decimals) /
                        BigInt(10) ** tokendict[tokenIn].decimals
                      );
                      setsendInputString(
                        `$${calculateUSDValue(
                          (amountIn * BigInt(10) ** token.decimals) /
                          BigInt(10) ** tokendict[tokenIn].decimals,
                          tradesByMarket[
                          (({ baseAsset, quoteAsset }) =>
                            (baseAsset === wethticker ? ethticker : baseAsset) +
                            (quoteAsset === wethticker ? ethticker : quoteAsset)
                          )(pricefetchmarket)
                          ],
                          token.address,
                          pricefetchmarket,
                        ).toFixed(2)}`,
                      );
                      const percentage = !walletTokenBalances[address]?.[token.address]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              ((amountIn * BigInt(10) ** token.decimals) /
                                BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                              walletTokenBalances[address]?.[token.address],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    }
                  } else if (location.pathname.slice(1) == 'scale') {
                    if ((token.address == weth ? eth : token.address) != (tokenOut == weth ? eth : tokenOut)) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenOut].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenOut].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                      } else {
                        let found = false;
                        for (const market in markets) {
                          if (
                            markets[market].baseAddress === token.address
                          ) {
                            setTokenOut(markets[market].quoteAddress);
                            found = true;
                            break;
                          }
                        }
                        if (!found) {
                          for (const market in markets) {
                            if (markets[market].quoteAddress === token.address) {
                              setTokenOut(markets[market].baseAddress);
                              break;
                            }
                          }
                        }
                      }
                      setamountIn(
                        BigInt(0)
                      );
                      setInputString('')
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                      setlimitChase(true);
                      const percentage = !walletTokenBalances[address]?.[token.address]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              BigInt(0) /
                              walletTokenBalances[address]?.[token.address],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    } else {
                      setTokenOut(tokenIn);
                      setswitched((switched) => { return !switched });
                      if (amountIn != BigInt(0) && scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                        setInputString(outputString);
                        setoutputString(inputString);
                        setamountIn(amountOutSwap);
                        setamountOutSwap(amountIn);
                        const percentage = !walletTokenBalances[address]?.[tokenOut]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (amountOutSwap * BigInt(100)) /
                                walletTokenBalances[address]?.[tokenOut],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                      else {
                        setamountIn(BigInt(0))
                        setInputString('')
                      }
                    }
                  }
                }}
              >
                <img className="tokenlistimage" src={token.image} />
                <div className="tokenlisttext">
                  <div className="tokenlistname">
                    {token.ticker}
                  </div>
                  <div className="tokenlistticker">{token.name}</div>
                </div>
                <div className="token-right-content">
                  <div className="tokenlistbalance">
                    {formatSubscript(customRound(
                      Number(walletTokenBalances[address]?.[token.address] ?? 0) /
                      10 ** Number(token.decimals ?? 18),
                      3,
                    )
                      .replace(/(\.\d*?[1-9])0+$/g, '$1')
                      .replace(/\.0+$/, ''))}
                  </div>
                  <div className="token-address-container">
                    <span className="token-address">
                      {`${token.address.slice(0, 6)}...${token.address.slice(-4)}`}
                    </span>
                    <div
                      className="copy-address-button"
                      onClick={(e) => {
                        e.stopPropagation();
                        navigator.clipboard.writeText(token.address);
                        const copyIcon =
                          e.currentTarget.querySelector('.copy-icon');
                        const checkIcon =
                          e.currentTarget.querySelector('.check-icon');
                        if (copyIcon && checkIcon) {
                          copyIcon.classList.add('hidden');
                          checkIcon.classList.add('visible');
                          setTimeout(() => {
                            copyIcon.classList.remove('hidden');
                            checkIcon.classList.remove('visible');
                          }, 2000);
                        }
                      }}
                    >
                      <svg
                        className="copy-icon"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <rect
                          x="9"
                          y="9"
                          width="13"
                          height="13"
                          rx="2"
                          ry="2"
                        ></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                      </svg>
                      <svg
                        className="check-icon"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <circle cx="12" cy="12" r="10" />
                        <path d="M8 12l3 3 6-6" />
                      </svg>
                    </div>
                  </div>
                </div>
              </button>
            ))
        )}
      </ul>
    </div>
  );

  // output tokenlist
  const tempTokenList2 = (
    <div className="tokenlistcontainer">
      <ul className="tokenlist">
        {Object.values(tokendict).filter(
          (token) =>
            token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
            token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
            token.address.toLowerCase().includes(tokenString.toLowerCase()),
        ).length === 0 ? (
          <div className="empty-token-list">
            <div className="empty-token-list-content">
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="empty-token-list-icon"
              >
                <circle cx="11" cy="11" r="8" />
                <path d="M21 21l-4.35-4.35" />
              </svg>
              <div className="empty-token-list-text">{t('noTokens')}</div>
            </div>
          </div>
        ) : (
          Object.values(tokendict)
            .filter(
              (token) =>
                token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
                token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
                token.address.toLowerCase().includes(tokenString.toLowerCase()),
            )
            .map((token, index) => (
              <button
                className={`tokenbutton ${index === selectedTokenIndex ? 'selected' : ''}`}
                key={token.address}
                onMouseEnter={() => setSelectedTokenIndex(index)}
                onClick={() => {
                  let newTokenIn;
                  setpopup(0);
                  settokenString('');
                  setTokenOut(token.address);
                  setStateIsLoading(true);
                  if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
                    if (token.address != tokenIn) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenIn].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenIn].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenIn = tokenIn;
                      } else {
                        const path = findShortestPath(
                          tokendict[tokenIn].address,
                          token.address,
                        );
                        if (path && path.length > 1) {
                          newTokenIn = tokenIn;
                        } else {
                          let found = false;
                          for (const market in markets) {
                            if (
                              markets[market].baseAddress === token.address
                            ) {
                              setTokenIn(markets[market].quoteAddress);
                              newTokenIn = markets[market].quoteAddress;
                              found = true;
                              break;
                            }
                          }
                          if (!found) {
                            for (const market in markets) {
                              if (
                                markets[market].quoteAddress === token.address
                              ) {
                                setTokenIn(markets[market].baseAddress);
                                newTokenIn = markets[market].baseAddress;
                                break;
                              }
                            }
                          }
                        }
                      }
                      if (
                        (tokenIn == eth && token.address == weth) ||
                        (tokenIn == weth && token.address == eth)
                      ) {
                        if (switched == false) {
                          setamountOutSwap(amountIn);
                          setoutputString(inputString);
                        }
                        else {
                          setamountOutSwap((amountOutSwap * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenOut].decimals)
                          setamountIn((amountOutSwap * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenOut].decimals);
                          setInputString(outputString);
                          const percentage = !walletTokenBalances[address]?.[tokenIn]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  ((amountOutSwap * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenOut].decimals * BigInt(100)) /
                                  walletTokenBalances[address]?.[tokenIn],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                      } else {
                        if (switched == false) {
                          setamountIn(
                            (amountIn *
                              BigInt(10) ** tokendict[newTokenIn].decimals) /
                            BigInt(10) ** tokendict[tokenIn].decimals
                          );
                          setamountOutSwap(BigInt(0));
                          setoutputString('');
                          const percentage = !walletTokenBalances[address]?.[newTokenIn]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  ((amountIn *
                                    BigInt(10) ** tokendict[newTokenIn].decimals) /
                                    BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                  walletTokenBalances[address]?.[newTokenIn],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        } else if (token.address != tokenOut) {
                          setamountOutSwap(
                            (amountOutSwap * BigInt(10) ** token.decimals) /
                            BigInt(10) ** tokendict[tokenOut].decimals,
                          );
                          setamountIn(BigInt(0));
                          setInputString('');
                        }
                      }
                      setlimitChase(true);
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                    } else {
                      setTokenIn(tokenOut);
                      if (
                        (amountIn != BigInt(0) || amountOutSwap != BigInt(0)) &&
                        !isWrap
                      ) {
                        if (switched == false) {
                          setswitched(true);
                          setStateIsLoading(true);
                          setInputString('');
                          setamountIn(BigInt(0));
                          setamountOutSwap(amountIn);
                          setoutputString(
                            amountIn === BigInt(0)
                              ? ''
                              : String(
                                customRound(
                                  Number(amountIn) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                ),
                              ),
                          );
                        } else {
                          setswitched(false);
                          setStateIsLoading(true);
                          setoutputString('');
                          setamountOutSwap(BigInt(0));
                          setamountIn(amountOutSwap);
                          setInputString(
                            amountOutSwap === BigInt(0)
                              ? ''
                              : String(
                                customRound(
                                  Number(amountOutSwap) /
                                  10 **
                                  Number(tokendict[tokenOut].decimals),
                                  3,
                                ),
                              ),
                          );
                          const percentage = !walletTokenBalances[address]?.[tokenOut]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  (amountOutSwap * BigInt(100)) /
                                  walletTokenBalances[address]?.[tokenOut],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                      }
                    }
                  } else if (location.pathname.slice(1) == 'limit') {
                    if ((token.address == weth ? eth : token.address) != (tokenIn == weth ? eth : tokenIn)) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenIn].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenIn].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenIn = tokenIn;
                      } else {
                        let found = false;
                        for (const market in markets) {
                          if (
                            markets[market].baseAddress === token.address
                          ) {
                            setTokenIn(markets[market].quoteAddress);
                            newTokenIn = markets[market].quoteAddress;
                            found = true;
                            break;
                          }
                        }
                        if (!found) {
                          for (const market in markets) {
                            if (markets[market].quoteAddress === token.address) {
                              setTokenIn(markets[market].baseAddress);
                              newTokenIn = markets[market].baseAddress;
                              break;
                            }
                          }
                        }
                      }
                      if (switched) {
                        setamountOutSwap(
                          (amountOutSwap * BigInt(10) ** token.decimals) /
                          BigInt(10) ** tokendict[tokenOut].decimals
                        )
                      }
                      else {
                        setamountIn(
                          (amountIn *
                            BigInt(10) ** tokendict[newTokenIn].decimals) /
                          BigInt(10) ** tokendict[tokenIn].decimals,
                        );
                        const percentage = !walletTokenBalances[address]?.[newTokenIn]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                ((amountIn * BigInt(10) ** tokendict[newTokenIn].decimals) /
                                  BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                walletTokenBalances[address]?.[newTokenIn],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                      setlimitChase(true);
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                    } else {
                      setTokenIn(tokenOut);
                      setswitched((switched) => { return !switched });
                      if (amountIn != BigInt(0)) {
                        if (limitChase && mids?.[activeMarketKey]?.[0]) {
                          const price = tokenOut === activeMarket?.baseAddress ? mids[activeMarketKey][0] == mids[activeMarketKey][1] ? mids[activeMarketKey][2] : mids[activeMarketKey][0] : mids[activeMarketKey][0] == mids[activeMarketKey][2] ? mids[activeMarketKey][1] : mids[activeMarketKey][0]
                          setlimitPrice(price);
                          setlimitPriceString(
                            (
                              Number(price) / Number(activeMarket.priceFactor)
                            ).toFixed(Math.floor(Math.log10(activeMarket?.marketType != 0 ? Math.min(10 ** Math.max(0, 5 - Math.floor(Math.log10((Number(price) / Number(activeMarket.priceFactor)) || 1)) - 1), Number(activeMarket.priceFactor)) : Number(activeMarket.priceFactor)))),
                          );
                          setamountOutSwap(
                            price != BigInt(0) && amountIn != BigInt(0)
                              ? tokenOut === activeMarket?.baseAddress
                                ? (amountIn * price) /
                                (activeMarket.scaleFactor || BigInt(1))
                                : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                                price
                              : BigInt(0),
                          );
                          setoutputString(
                            (price != BigInt(0) && amountIn != BigInt(0)
                              ? tokenOut === activeMarket?.baseAddress
                                ? customRound(
                                  Number(
                                    (amountIn * price) /
                                    (activeMarket.scaleFactor || BigInt(1)),
                                  ) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                )
                                : customRound(
                                  Number(
                                    (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                                    price,
                                  ) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        setInputString(outputString);
                        setoutputString(inputString);
                        setamountIn(amountOutSwap);
                        setamountOutSwap(amountIn);
                        const percentage = !walletTokenBalances[address]?.[tokenOut]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (amountOutSwap * BigInt(100)) /
                                walletTokenBalances[address]?.[tokenOut],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                    }
                  } else if (location.pathname.slice(1) == 'scale') {
                    if ((token.address == weth ? eth : token.address) != (tokenIn == weth ? eth : tokenIn)) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenIn].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenIn].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenIn = tokenIn;
                      } else {
                        let found = false;
                        for (const market in markets) {
                          if (
                            markets[market].baseAddress === token.address
                          ) {
                            setTokenIn(markets[market].quoteAddress);
                            newTokenIn = markets[market].quoteAddress;
                            found = true;
                            break;
                          }
                        }
                        if (!found) {
                          for (const market in markets) {
                            if (markets[market].quoteAddress === token.address) {
                              setTokenIn(markets[market].baseAddress);
                              newTokenIn = markets[market].baseAddress;
                              break;
                            }
                          }
                        }
                      }
                      setamountIn(
                        BigInt(0)
                      );
                      setInputString('')
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                      setlimitChase(true);
                      const percentage = !walletTokenBalances[address]?.[newTokenIn]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              BigInt(0) /
                              walletTokenBalances[address]?.[newTokenIn],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    } else {
                      setTokenIn(tokenOut);
                      setswitched((switched) => { return !switched });
                      if (amountIn != BigInt(0) && scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                        setInputString(outputString);
                        setoutputString(inputString);
                        setamountIn(amountOutSwap);
                        setamountOutSwap(amountIn);
                        const percentage = !walletTokenBalances[address]?.[tokenOut]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (amountOutSwap * BigInt(100)) /
                                walletTokenBalances[address]?.[tokenOut],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                      else {
                        setamountIn(BigInt(0))
                        setInputString('')
                      }
                    }
                  }
                }}
              >
                <img className="tokenlistimage" src={token.image} />
                <div className="tokenlisttext">
                  <div className="tokenlistname">
                    {token.ticker}
                  </div>
                  <div className="tokenlistticker">{token.name}</div>
                </div>
                <div className="token-right-content">
                  <div className="tokenlistbalance">
                    {formatSubscript(customRound(
                      Number(walletTokenBalances[address]?.[token.address] ?? 0) /
                      10 ** Number(token.decimals ?? 18),
                      3,
                    )
                      .replace(/(\.\d*?[1-9])0+$/g, '$1')
                      .replace(/\.0+$/, ''))}
                  </div>
                  <div className="token-address-container">
                    <span className="token-address">
                      {`${token.address.slice(0, 6)}...${token.address.slice(-4)}`}
                    </span>
                    <div
                      className="copy-address-button"
                      onClick={(e) => {
                        e.stopPropagation();
                        navigator.clipboard.writeText(token.address);
                        const copyIcon =
                          e.currentTarget.querySelector('.copy-icon');
                        const checkIcon =
                          e.currentTarget.querySelector('.check-icon');
                        if (copyIcon && checkIcon) {
                          copyIcon.classList.add('hidden');
                          checkIcon.classList.add('visible');
                          setTimeout(() => {
                            copyIcon.classList.remove('hidden');
                            checkIcon.classList.remove('visible');
                          }, 2000);
                        }
                      }}
                    >
                      <svg
                        className="copy-icon"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <rect
                          x="9"
                          y="9"
                          width="13"
                          height="13"
                          rx="2"
                          ry="2"
                        ></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                      </svg>
                      <svg
                        className="check-icon"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <circle cx="12" cy="12" r="10" />
                        <path d="M8 12l3 3 6-6" />
                      </svg>
                    </div>
                  </div>
                </div>
              </button>
            ))
        )}
      </ul>
    </div>
  );

  const [displayNotifications, setDisplayNotifications] = useState(true);
  const [toastPosition, setToastPosition] = useState<string>(() => {
    try {
      return localStorage.getItem('crystal_toast_position') || 'top-center';
    } catch {
      return 'top-center';
    }
  });
  const [transactionSounds, setTransactionSounds] = useState(true);
  const [volume, setVolume] = useState(75);
  const [buySound, setBuySound] = useState('Step Audio');
  const [sellSound, setSellSound] = useState('Step Audio');
  const [openDropdowns, setOpenDropdowns] = useState<Record<string, boolean>>({});
  const audioRef = useRef<HTMLAudioElement | null>(new Audio(stepaudio));
  const lastVolumeRef = useRef<number>(volume);

  const toggleDropdown = (key: string) => {
    setOpenDropdowns((prev) => ({
      ...prev,
      [key]: !prev[key],
    }));
  };

  const closeDropdown = (key: string) => {
    setOpenDropdowns((prev) => ({
      ...prev,
      [key]: false,
    }));
  };

  const getSoundDisplayName = (soundPath: string) => {
    if (soundPath === stepaudio) return 'Step Audio';
    if (soundPath === kaching) return 'Ka-ching';
    if (soundPath.includes('blob:')) return 'Custom Audio';
    return 'Step Audio';
  };

  const playSound = (soundType: 'buy' | 'sell') => {
    if (!audioRef.current) return;

    const soundUrl = soundType === 'buy' ? buySound : sellSound;

    if (
      soundUrl === stepaudio ||
      soundUrl === kaching ||
      soundUrl === 'Default'
    ) {
      const audio = new Audio(soundUrl === 'Default' ? stepaudio : soundUrl);
      audio.volume = volume / 100;
      audio.currentTime = 0;
      audio.play().catch(console.error);
    } else {
      const customAudio = new Audio(soundUrl);
      customAudio.volume = volume / 100;
      customAudio.play().catch(console.error);
    }
  };

  const handleFileUpload = (
    soundType: 'buy' | 'sell',
    event: React.ChangeEvent<HTMLInputElement>,
  ) => {
    const file = event.target.files?.[0];
    if (file) {
      const url = URL.createObjectURL(file);
      if (soundType === 'buy') {
        setBuySound(url);
      } else {
        setSellSound(url);
      }
    }
    event.target.value = '';
  };

  const selectSound = (
    soundType: 'buy' | 'sell',
    soundValue: string,
  ) => {
    if (soundType === 'buy') {
      setBuySound(soundValue);
    } else {
      setSellSound(soundValue);
    }
  };

  const handleVolumeSliderChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      const newVolume = parseInt(e.target.value, 10);
      setVolume(newVolume);
    },
    [],
  );

  const handleVolumeChangeEnd = useCallback(() => {
    if (
      audioRef.current &&
      Math.abs(volume - lastVolumeRef.current) > 0
    ) {
      audioRef.current.currentTime = 0;
      audioRef.current.play().catch(console.error);
    }
    lastVolumeRef.current = volume;
    setIsDragging(false);
  }, [volume]);

  useEffect(() => {
    if (audioRef.current) {
      audioRef.current.volume = volume / 100;
    }
  }, [volume]);

  // popup modals
  const Modals = (
    <>
      <div className={`blur-background-popups ${popup != 0 ? 'active' : ''}`}>
        {popup === 1 ? ( // token select
          <div ref={popupref} className="tokenselectbg">
            <button
              className="tokenselect-close-button"
              onClick={() => {
                setpopup(0);
                settokenString('');
              }}
            >
              <img src={closebutton} className="close-button-icon" />
            </button>
            <div className="tokenselectheader1">{t('selectAToken')}</div>
            <div style={{ position: 'relative' }}>
              <input
                className="tokenselect"
                onChange={(e) => {
                  settokenString(e.target.value);
                }}
                onKeyDown={handleTokenSelectKeyDown}
                placeholder={t('searchToken')}
                autoFocus={!(windowWidth <= 1020)}
              />
              {tokenString && (
                <button
                  className="tokenselect-clear visible"
                  onClick={() => {
                    settokenString('');
                    const input = document.querySelector(
                      '.tokenselect',
                    ) as HTMLInputElement;
                    if (input) {
                      input.value = '';
                      input.focus();
                    }
                  }}
                >
                  {t('clear')}
                </button>
              )}
            </div>
            {tempTokenList1}
          </div>
        ) : null}
        {popup === 2 ? ( // token select
          <div ref={popupref} className="tokenselectbg" >
            <button
              className="tokenselect-close-button"
              onClick={() => {
                setpopup(0);
                settokenString('');
              }}
            >
              <img src={closebutton} className="close-button-icon" />
            </button>
            <div className="tokenselectheader1">{t('selectAToken')}</div>
            <div style={{ position: 'relative' }}>
              <input
                className="tokenselect"
                onChange={(e) => {
                  settokenString(e.target.value);
                }}
                onKeyDown={handleTokenSelectKeyDown}
                placeholder={t('searchToken')}
                autoFocus={!(windowWidth <= 1020)}
              />
              {tokenString && (
                <button
                  className="tokenselect-clear visible"
                  onClick={() => {
                    settokenString('');
                    const input = document.querySelector(
                      '.tokenselect',
                    ) as HTMLInputElement;
                    if (input) {
                      input.value = '';
                      input.focus();
                    }
                  }}
                >
                  {t('clear')}
                </button>
              )}
            </div>
            {tempTokenList2}
          </div>
        ) : null}
        {popup === 3 ? ( // send popup
          <div ref={popupref} className="send-popup-container">
            <div className="send-popup-background">
              <div className={`sendbg ${connected && sendAmountIn > walletTokenBalances[address]?.[sendTokenIn] ? 'exceed-balance' : ''}`}>

                <div className="sendbutton1container">
                  <div className="send-Send">{t('send')}</div>
                  <button
                    className="send-button1"
                    onClick={() => {
                      setpopup(10);
                    }}
                  >
                    <img className="send-button1pic" src={tokendict[sendTokenIn].image} />
                    <span>{tokendict[sendTokenIn].ticker || '?'}</span>
                  </button>

                </div>
                <div className="sendinputcontainer">
                  <input
                    inputMode="decimal"
                    className={`send-input ${connected && sendAmountIn > walletTokenBalances[address]?.[sendTokenIn] ? 'exceed-balance' : ''}`}
                    onCompositionStart={() => {
                      setIsComposing(true);
                    }}
                    onCompositionEnd={(
                      e: React.CompositionEvent<HTMLInputElement>,
                    ) => {
                      setIsComposing(false);
                      if (/^\$?\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                        if (displayMode == 'usd') {
                          if (e.currentTarget.value == '$') {
                            setSendUsdValue('');
                            setSendInputAmount('');
                            setSendAmountIn(BigInt(0));
                          } else {
                            setSendUsdValue(`$${e.currentTarget.value.replace(/^\$/, '')}`);
                            const calculatedAmount = calculateTokenAmount(
                              e.currentTarget.value.replace(/^\$/, ''),
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            );
                            setSendAmountIn(calculatedAmount);
                            setSendInputAmount(
                              customRound(
                                Number(calculatedAmount) / 10 ** Number(tokendict[sendTokenIn].decimals),
                                3,
                              ).toString()
                            );
                          }
                        } else {
                          const inputValue = BigInt(
                            Math.round((parseFloat(e.currentTarget.value || '0') || 0) * 10 ** Number(tokendict[sendTokenIn].decimals))
                          );
                          setSendAmountIn(inputValue);
                          setSendInputAmount(e.currentTarget.value);
                          setSendUsdValue(
                            `$${calculateUSDValue(
                              inputValue,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            ).toFixed(2)}`
                          );
                        }
                      }
                    }}
                    onChange={(e) => {
                      if (isComposing) {
                        setSendInputAmount(e.target.value);
                        return;
                      }
                      if (/^\$?\d*\.?\d{0,18}$/.test(e.target.value)) {
                        if (displayMode == 'usd') {
                          if (e.target.value == '$') {
                            setSendUsdValue('');
                            setSendInputAmount('');
                            setSendAmountIn(BigInt(0));
                          } else {
                            setSendUsdValue(`$${e.target.value.replace(/^\$/, '')}`);
                            const calculatedAmount = calculateTokenAmount(
                              e.target.value.replace(/^\$/, ''),
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            );
                            setSendAmountIn(calculatedAmount);
                            setSendInputAmount(
                              customRound(
                                Number(calculatedAmount) / 10 ** Number(tokendict[sendTokenIn].decimals),
                                3,
                              ).toString()
                            );
                          }
                        } else {
                          const inputValue = BigInt(
                            Math.round((parseFloat(e.target.value || '0') || 0) * 10 ** Number(tokendict[sendTokenIn].decimals))
                          );
                          setSendAmountIn(inputValue);
                          setSendInputAmount(e.target.value);
                          setSendUsdValue(
                            `$${calculateUSDValue(
                              inputValue,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            ).toFixed(2)}`
                          );
                        }
                      }
                    }}
                    placeholder={displayMode == 'usd' ? '$0.00' : '0.00'}
                    value={displayMode == 'usd' ? sendUsdValue : sendInputAmount}
                    autoFocus={!(windowWidth <= 1020)}
                  />
                </div>
                <div className="send-balance-wrapper">
                  <div className="send-balance-max-container">
                    <div className="send-balance1">
                      <img src={walleticon} className="send-balance-wallet-icon" />{' '}
                      {formatDisplayValue(walletTokenBalances[address]?.[sendTokenIn], Number(tokendict[sendTokenIn].decimals))}
                    </div>
                    <div
                      className="send-max-button"
                      onClick={() => {
                        if (walletTokenBalances[address]?.[sendTokenIn] != BigInt(0)) {
                          let amount =
                            (sendTokenIn == eth && !client)
                              ? walletTokenBalances[address]?.[sendTokenIn] - settings.chainConfig[activechain].gasamount > BigInt(0)
                                ? walletTokenBalances[address]?.[sendTokenIn] - settings.chainConfig[activechain].gasamount
                                : BigInt(0)
                              : walletTokenBalances[address]?.[sendTokenIn];
                          setSendAmountIn(amount);
                          setSendInputAmount(
                            customRound(Number(amount) / 10 ** Number(tokendict[sendTokenIn].decimals), 3).toString()
                          );
                          setSendUsdValue(
                            `$${calculateUSDValue(
                              amount,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            ).toFixed(2)}`
                          );
                        }
                      }}
                    >
                      {t('max')}
                    </div>
                  </div>
                  <div
                    className="send-usd-switch-wrapper"
                    onClick={() => {
                      if (displayMode === 'usd') {
                        setDisplayMode('token');
                        if (parseFloat(sendUsdValue.replace(/^\$|,/g, '')) == 0) {
                          setSendInputAmount('');
                        }
                      } else {
                        setDisplayMode('usd');
                        if (parseFloat(sendInputAmount) == 0) {
                          setSendUsdValue('');
                        }
                      }
                    }}
                  >
                    <div className="send-usd-value">
                      {displayMode === 'usd'
                        ? `${customRound(Number(sendAmountIn) / 10 ** Number(tokendict[sendTokenIn].decimals), 3)} ${tokendict[sendTokenIn].ticker}`
                        : sendAmountIn === BigInt(0)
                          ? '$0.00'
                          : formatUSDDisplay(
                            calculateUSDValue(
                              sendAmountIn,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            )
                          )}
                    </div>
                    <img src={sendSwitch} className="send-arrow" />
                  </div>
                </div>
              </div>
              <div className="sendaddressbg">
                <div className="send-To">{t('to')}</div>
                <div className="send-address-input-container">
                  <input
                    className="send-output"
                    onChange={(e) => {
                      if (e.target.value === '' || /^(0x[0-9a-fA-F]{0,40}|0)$/.test(e.target.value)) {
                        setrecipient(e.target.value);
                      }
                    }}
                    value={recipient}
                    placeholder={t('enterWalletAddress')}
                  />
                  <button
                    className="address-paste-button"
                    onClick={async () => {
                      try {
                        const text = await navigator.clipboard.readText();
                        if (/^(0x[0-9a-fA-F]{40})$/.test(text)) {
                          setrecipient(text);
                        }
                      } catch (err) {
                      }
                    }}
                  >
                    <svg
                      width="16"
                      height="16"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    >
                      <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                      <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                    </svg>
                  </button>
                </div>
              </div>
              <button
                className={`send-swap-button ${isSigning ? 'signing' : ''}`}
                onClick={async () => {
                  if (
                    connected &&
                    userchain === activechain
                  ) {
                    let hash: any;
                    setIsSigning(true)
                    if (client) {
                      txPending.current = true
                    }
                    try {
                      if (sendTokenIn == eth) {
                        hash = await sendUserOperationAsync({
                          uo: sendeth(
                            recipient as `0x${string}`,
                            sendAmountIn,
                          )
                        });
                        if (!client) {
                          txPending.current = true
                        }
                        newTxPopup(
                          (hash),
                          'send',
                          eth,
                          '',
                          customRound(
                            Number(sendAmountIn) / 10 ** Number(tokendict[eth].decimals),
                            3,
                          ),
                          0,
                          '',
                          recipient,
                        );
                      } else {
                        hash = await sendUserOperationAsync({
                          uo: sendtokens(
                            sendTokenIn as `0x${string}`,
                            recipient as `0x${string}`,
                            sendAmountIn,
                          )
                        });
                        if (!client) {
                          txPending.current = true
                        }
                        newTxPopup(
                          (hash),
                          'send',
                          sendTokenIn,
                          '',
                          customRound(
                            Number(sendAmountIn) /
                            10 ** Number(tokendict[sendTokenIn].decimals),
                            3,
                          ),
                          0,
                          '',
                          recipient,
                        );
                      }
                      setSendUsdValue('')
                      setSendInputAmount('');
                      setSendAmountIn(BigInt(0));
                      setSendPopupButton(0);
                      setSendPopupButtonDisabled(true);
                      setIsSigning(false)
                      await refetch()
                      txPending.current = false
                    } catch (error) {
                      if (!(error instanceof TransactionExecutionError)) {
                        newTxPopup(
                          hash,
                          "sendFailed",
                          sendTokenIn === eth ? eth : sendTokenIn,
                          "",
                          customRound(
                            Number(sendAmountIn) / 10 ** Number(tokendict[sendTokenIn === eth ? eth : sendTokenIn].decimals),
                            3,
                          ),
                          0,
                          "",
                          recipient,
                        );
                      }
                    } finally {
                      txPending.current = false
                      setIsSigning(false)
                    }
                  } else {
                    !connected
                      ? setpopup(4)
                      : handleSetChain()
                  }
                }}
                disabled={(sendAmountIn === BigInt(0) ||
                  sendAmountIn > walletTokenBalances[address]?.[sendTokenIn] ||
                  !/^(0x[0-9a-fA-F]{40})$/.test(recipient)) &&
                  connected &&
                  userchain == activechain || isSigning}
              >
                {isSigning ? (
                  <div className="button-content">
                    <div className="loading-spinner" />
                    {validOneCT ? t('') : t('signTransaction')}
                  </div>
                ) : !connected ? (
                  t('connectWallet')
                ) : tempsendPopupButton == 0 ? (
                  t('enterAmount')
                ) : tempsendPopupButton == 1 ? (
                  t('enterWalletAddress')
                ) : tempsendPopupButton == 2 ? (
                  t('send')
                ) : tempsendPopupButton == 3 ? (
                  t('insufficient') +
                  (tokendict[sendTokenIn].ticker || '?') +
                  ' ' +
                  t('bal')
                ) : tempsendPopupButton == 4 ? (
                  `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
                ) : (
                  t('connectWallet')
                )}
              </button>
            </div>
          </div>
        ) : null}
        {popup === 4 ? (
          !connected ? (
            <div ref={popupref} className="connect-wallet-background unconnected">
              <div className="connect-wallet-content-container">
                <AuthCard {...alchemyconfig.ui.auth} />
              </div>
            </div>
          ) : (
            <div ref={popupref} className="connect-wallet-background connected">
              <div className="wallet-header">
                <div className="wallet-info"
                  onMouseEnter={() =>
                    !copyTooltipVisible && setShowHoverTooltip(true)
                  }
                  onMouseLeave={() => setShowHoverTooltip(false)}
                  onClick={(e) => {
                    e.stopPropagation();
                    navigator.clipboard.writeText(
                      address || '',
                    );
                    setShowHoverTooltip(false);
                    setCopyTooltipVisible(true);
                    setTimeout(() => {
                      setCopyTooltipVisible(false);
                    }, 2000);
                  }}>
                  {connected &&
                    address && (
                      <>
                        <div
                          className="wallet-popup-address-container"
                        >
                          <span
                            className={`wallet-popup-address`}
                          >
                            <img
                              src={currentWalletIcon}
                              className="port-popup-wallet-icon"
                            />
                            {`${address.slice(0, 6)}...${address.slice(-4)}`}
                          </span>

                          {copyTooltipVisible && (
                            <div className="wallet-popup-copy-tooltip">
                              {t('copied')}!
                            </div>
                          )}
                          {!copyTooltipVisible && showHoverTooltip && (
                            <div className="wallet-popup-hover-tooltip">
                              {t('clickCopyAddress')}
                            </div>
                          )}
                        </div>
                      </>
                    )}
                </div>
                <button
                  className={`eye-button ${!isBlurred ? '' : 'h'}`}
                  onClick={() => setIsBlurred(!isBlurred)}
                >
                  <div className="eye-icon-container">
                    <svg
                      className="eye-icon"
                      viewBox="0 0 24 24"
                      fill="none"
                    >
                      <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" />
                      <circle cx="12" cy="12" r="3" />
                    </svg>
                    <div className="eye-slash" />
                  </div>
                </button>
                <button
                  className="popup-deposit-button"
                  onClick={() => {
                    setpopup(12)
                  }}
                >
                  <svg
                    className="deposit-icon"
                    viewBox="0 0 24 24"
                    width="24"
                    height="24"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  >
                    <polyline points="7 11 12 16 17 11"></polyline>
                    <line x1="12" y1="1" x2="12" y2="14"></line>
                    <path d="M22 14V19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V14" />

                  </svg>
                </button>
                <button
                  className="popup-disconnect-button"
                  onClick={() => {
                    logout()
                  }}
                >
                  <svg
                    className="disconnect-icon"
                    viewBox="0 0 24 24"
                    width="24"
                    height="24"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  >
                    <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                    <polyline points="16 17 21 12 16 7"></polyline>
                    <line x1="21" y1="12" x2="9" y2="12"></line>
                  </svg>
                </button>
                <div className="header-actions">
                  <button
                    className="connect-wallet-close-button"
                    onClick={() => {
                      setpopup(0);
                      settokenString('');
                    }}
                  >
                    <img src={closebutton} className="close-button-icon" />
                  </button>
                </div>
              </div>
              {portChartLoading ? (
                <div
                  className="portfolio-popup-graph"
                  style={{ marginTop: 15, marginBottom: 10, height: 215 }}
                >
                  <LoadingOverlay
                    isVisible={true}
                    bgcolor={'#00000000'}
                    height={30}
                  />
                </div>
              ) : (
                <>
                  <div className="total-account-summary-value">
                    <div
                      className={`total-value ${isBlurred ? 'blurred' : ''}`}
                    >
                      ${typeof totalAccountValue === 'number' ? formatCommas(totalAccountValue.toFixed(2)) : '0.00'}
                    </div>
                    <div
                      className={`percentage-change ${isBlurred ? 'blurred' : ''} ${percentage >= 0 ? 'positive' : 'negative'}`}
                    >
                      {percentage >= 0 ? '+' : ''}
                      {percentage.toFixed(2)}%
                    </div>
                  </div>
                  <div className="portfolio-popup-graph">
                    <PortfolioPopupGraph
                      address={address ?? ''}
                      onPercentageChange={setPercentage}
                      colorValue={portfolioColorValue}
                      setColorValue={setPortfolioColorValue}
                      isPopup={true}
                      chartData={typeof totalAccountValue === 'number' ? [
                        ...portGraph.slice(0, -1),
                        {
                          ...portGraph[portGraph.length - 1],
                          value: totalAccountValue,
                        },
                      ] : portGraph}
                      portChartLoading={portChartLoading}
                      chartDays={chartDays}
                      setChartDays={setChartDays}
                      isBlurred={isBlurred}
                    />
                  </div>
                </>
              )}
              <div className="graph-assets-divider" />
              <div className="portfolio-content-popup">
                <PortfolioContent
                  tokenList={Object.values(tokendict)}
                  onMarketSelect={onMarketSelect}
                  setSendTokenIn={setSendTokenIn}
                  setpopup={setpopup}
                  sortConfig={memoizedSortConfig}
                  tokenBalances={walletTokenBalances[address]}
                  marketsData={marketsData}
                  isBlurred={isBlurred}
                />
              </div>
            </div>
          )
        ) : null}
        {popup === 5 ? ( // settings
          <div
            className="layout-settings-background"
            ref={popupref}
          >
            <div className="layout-settings-header">
              <button
                className="layout-settings-close-button"
                onClick={() => setpopup(0)}
              >
                <img src={closebutton} className="close-button-icon" />
              </button>
              <div className="layout-settings-title">{t('settings')}</div>
            </div>

            <div className="settings-main-container">
              <div className="settings-sidebar">
                <div className="settings-section-buttons">
                  <button
                    className={`settings-section-button ${activeSettingsSection === 'general' ? 'active' : ''}`}
                    onClick={() => updateActiveSettingsSection('general')}
                  >
                    <span>{t('general')}</span>
                  </button>
                  {windowWidth >= 1020 && (
                    <button
                      className={`settings-section-button ${activeSettingsSection === 'layout' ? 'active' : ''}`}
                      onClick={() => updateActiveSettingsSection('layout')}
                    >
                      <span>{t('tradingLayout')}</span>
                    </button>
                  )}
                  <button
                    className={`settings-section-button ${activeSettingsSection === 'display' ? 'active' : ''}`}
                    onClick={() => updateActiveSettingsSection('display')}
                  >
                    <span>{t('tradingSettings')}</span>
                  </button>
                  <button
                    className={`settings-section-button ${activeSettingsSection === 'audio' ? 'active' : ''}`}
                    onClick={() => updateActiveSettingsSection('audio')}
                  >
                    <span>{t('notifications')}</span>
                  </button>
                  <button
                    className={`settings-section-button ${activeSettingsSection === 'keybinds' ? 'active' : ''}`}
                    onClick={() => updateActiveSettingsSection('keybinds')}
                  >
                    <span>{t('keybinds')}</span>
                  </button>
                </div>

                <button
                  className="revert-settings-button sidebar-revert-button"
                  onClick={() => {
                    setLanguage('EN');
                    localStorage.setItem('crystal_language', 'EN');

                    setHideNotificationPopups(false);
                    localStorage.setItem('crystal_hide_notification_popups', 'false');

                    setNotificationPosition('bottom-right');
                    localStorage.setItem('crystal_notification_position', 'bottom-right');

                    setHiddenPopupTypes({});
                    localStorage.setItem('crystal_hidden_popup_types', JSON.stringify({}));

                    setSpotLayoutSettings('default');
                    localStorage.setItem('crystal_layout', 'default');

                    setSpotOrderbookPosition('right');
                    localStorage.setItem('crystal_orderbook', 'right');

                    setIsMarksVisible(true);
                    localStorage.setItem('crystal_marks_visible', 'true');

                    setIsOrdersVisible(true);
                    localStorage.setItem('crystal_orders_visible', 'true');

                    setHideNotificationPopups(false);
                    localStorage.setItem('crystal_hide_notification_popups', 'false');

                    setIsOrderbookVisible(true);
                    localStorage.setItem('crystal_orderbook_visible', 'true');

                    setIsOrderCenterVisible(true);
                    localStorage.setItem(
                      'crystal_ordercenter_visible',
                      'true',
                    );

                    setShowChartOutliers(false);
                    localStorage.setItem('crystal_show_chart_outliers', 'false');

                    setIsAudioEnabled(false);
                    localStorage.setItem('crystal_audio_notifications', 'false');

                    setOrderbookWidth(300);
                    localStorage.setItem('orderbookWidth', '300');

                    setAddLiquidityOnly(false);
                    localStorage.setItem(
                      'crystal_add_liquidity_only',
                      'false',
                    );

                    setorderType(1);
                    localStorage.setItem('crystal_order_type', '1');

                    setSlippageString('1');
                    setSlippage(BigInt(9900));
                    localStorage.setItem('crystal_slippage_string', '1');
                    localStorage.setItem('crystal_slippage', '9900');

                    setActiveSection('orders');
                    localStorage.setItem('crystal_oc_tab', 'orders');

                    setFilter('all');
                    localStorage.setItem('crystal_oc_filter', 'all');

                    setOnlyThisMarket(false);
                    localStorage.setItem('crystal_only_this_market', 'false');

                    setOBInterval(baseInterval);
                    localStorage.setItem(
                      `${activeMarket.baseAsset}_ob_interval`,
                      JSON.stringify(baseInterval),
                    );

                    const currentKey = `${activeMarket.baseAsset}_ob_interval`;
                    for (let i = localStorage.length - 1; i >= 0; i--) {
                      const key = localStorage.key(i);
                      if (
                        key &&
                        key.endsWith('_ob_interval') &&
                        key !== currentKey
                      ) {
                        localStorage.removeItem(key);
                      }
                    }

                    setViewMode('both');
                    localStorage.setItem('ob_viewmode', 'both');

                    setOBTab('orderbook');
                    localStorage.setItem('ob_active_tab', 'orderbook');

                    setMobileView('chart');

                    setAmountsQuote('Quote');
                    localStorage.setItem('ob_amounts_quote', 'Quote');

                    localStorage.setItem('crystal_chart_timeframe', '5')

                    let defaultHeight: number;

                    if (window.innerHeight > 1080) defaultHeight = 367.58;
                    else if (window.innerHeight > 960) defaultHeight = 324.38;
                    else if (window.innerHeight > 840) defaultHeight = 282.18;
                    else if (window.innerHeight > 720) defaultHeight = 239.98;
                    else defaultHeight = 198.78;

                    setOrderCenterHeight(defaultHeight);
                    localStorage.setItem(
                      'orderCenterHeight',
                      defaultHeight.toString(),
                    );
                  }}
                >
                  {t('revertToDefault')}
                </button>
              </div>

              <div className="right-side-settings-panel">
                <div className="settings-content-panel">
                  {activeSettingsSection === 'general' && (
                    <div className="settings-section-content">
                      <div className="layout-language-row">
                        <span className="layout-language-label">{t('language')}</span>
                        <div className="settings-section-subtitle">
                          {t('selectPreferredLanguage')}
                        </div>
                        <div className="language-selector-app-container">
                          <div className="language-grid">
                            {languageOptions.map((lang) => (
                              <button
                                key={lang.code}
                                className={`language-grid-item ${language === lang.code ? 'active' : ''}`}
                                onClick={() => {
                                  setLanguage(lang.code);
                                  localStorage.setItem('crystal_language', lang.code);
                                }}
                              >
                                {lang.name}
                              </button>
                            ))}
                          </div>
                        </div>
                      </div>
                      <div className="slider-settings-section">
                        <div className="settings-subsection">
                          <div className="layout-section-title">{t('balanceSliderMode')}</div>
                          <div className="settings-section-subtitle">
                            {t('chooseBalancePercentages')}
                          </div>

                          <div className="slider-mode-options">
                            <button
                              className={`control-layout-option ${('spot' === 'spot' ? spotSliderMode : trenchesSliderMode) === 'slider' ? 'active' : ''}`}
                              onClick={() => {
                                if ('spot' === 'spot') {
                                  setSpotSliderMode('slider');
                                  localStorage.setItem('crystal_spot_slider_mode', 'slider');
                                } else {
                                  setTrenchesSliderMode('slider');
                                  localStorage.setItem('crystal_trenches_slider_mode', 'slider');
                                }
                              }}
                            >
                              <div className="layout-label">
                                <span className="control-layout-name">{t('slider')}</span>
                              </div>
                            </button>

                            <button
                              className={`control-layout-option ${('spot' === 'spot' ? spotSliderMode : trenchesSliderMode) === 'presets' ? 'active' : ''}`}
                              onClick={() => {
                                if ('spot' === 'spot') {
                                  setSpotSliderMode('presets');
                                  localStorage.setItem('crystal_spot_slider_mode', 'presets');
                                } else {
                                  setTrenchesSliderMode('presets');
                                  localStorage.setItem('crystal_trenches_slider_mode', 'presets');
                                }
                              }}
                            >
                              <div className="layout-label">
                                <span className="control-layout-name">{t('presets')}</span>
                              </div>
                            </button>

                            <button
                              className={`control-layout-option ${('spot' === 'spot' ? spotSliderMode : trenchesSliderMode) === 'increment' ? 'active' : ''}`}
                              onClick={() => {
                                if ('spot' === 'spot') {
                                  setSpotSliderMode('increment');
                                  localStorage.setItem('crystal_spot_slider_mode', 'increment');
                                } else {
                                  setTrenchesSliderMode('increment');
                                  localStorage.setItem('crystal_trenches_slider_mode', 'increment');
                                }
                              }}
                            >
                              <div className="layout-label">
                                <span className="control-layout-name">{t('increment')}</span>
                              </div>
                            </button>
                          </div>
                        </div>

                        {('spot' === 'spot' ? spotSliderMode : trenchesSliderMode) === 'presets' && (
                          <div className="settings-subsection">
                            <div className="layout-section-title">{t('presetPercentages')}</div>
                            <div className="settings-section-subtitle">
                              {t('setThreeFavoritePercentages')}
                            </div>
                            <div className="preset-inputs">
                              {('spot' === 'spot' ? spotSliderPresets : trenchesSliderPresets).map((preset: number, index: number) => (
                                <div key={index} className="preset-input-group">
                                  <label className="preset-label">{t('preset')} {index + 1}</label>
                                  <div className="preset-input-container">
                                    <input
                                      type="text"
                                      value={preset === 0 ? '' : preset.toString()}
                                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                                        const inputValue = e.target.value;
                                        const currentPresets = 'spot' === 'spot' ? spotSliderPresets : trenchesSliderPresets;
                                        const setCurrentPresets = 'spot' === 'spot' ? setSpotSliderPresets : setTrenchesSliderPresets;
                                        const storageKey = 'spot' === 'spot' ? 'crystal_spot_slider_presets' : 'crystal_trenches_slider_presets';

                                        if (inputValue === '') {
                                          const newPresets = [...currentPresets];
                                          newPresets[index] = 0;
                                          setCurrentPresets(newPresets);
                                          localStorage.setItem(storageKey, JSON.stringify(newPresets));
                                        } else if (/^\d*\.?\d*$/.test(inputValue)) {
                                          const numValue = parseFloat(inputValue);
                                          if (!isNaN(numValue) && numValue >= 0 && numValue <= 100) {
                                            const newPresets = [...currentPresets];
                                            newPresets[index] = numValue;
                                            setCurrentPresets(newPresets);
                                            localStorage.setItem(storageKey, JSON.stringify(newPresets));
                                          }
                                        }
                                      }}
                                      placeholder="0"
                                      className="preset-input"
                                    />
                                    <span className="preset-unit">%</span>
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}

                        {('spot' === 'spot' ? spotSliderMode : trenchesSliderMode) === 'increment' && (
                          <div className="settings-subsection">
                            <div className="layout-section-title">{t('incrementAmount')}</div>
                            <div className="settings-section-subtitle">
                              {t('setIncrementAmount')}
                            </div>
                            <div className="increment-input-group">
                              <div className="increment-input-container">
                                <div className="percentage-input-wrapper">
                                  <input
                                    type="text"
                                    value={('spot' === 'spot' ? spotSliderIncrement : trenchesSliderIncrement) === 0 ? '' : ('spot' === 'spot' ? spotSliderIncrement : trenchesSliderIncrement).toString()}
                                    onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                                      const inputValue = e.target.value;
                                      const setCurrentIncrement = 'spot' === 'spot' ? setSpotSliderIncrement : setTrenchesSliderIncrement;
                                      const storageKey = 'spot' === 'spot' ? 'crystal_spot_slider_increment' : 'crystal_trenches_slider_increment';

                                      if (inputValue === '') {
                                        setCurrentIncrement(0);
                                        localStorage.setItem(storageKey, '0');
                                      } else if (/^\d*\.?\d{0,2}$/.test(inputValue)) {
                                        const numValue = parseFloat(inputValue || '0') || 0;
                                        if (numValue <= 50) {
                                          setCurrentIncrement(numValue);
                                          localStorage.setItem(storageKey, numValue.toString());
                                        }
                                      }
                                    }}
                                    placeholder="10"
                                    className="percentage-input"
                                  />
                                  <span className="percentage-input-suffix">%</span>
                                </div>
                              </div>
                            </div>
                          </div>
                        )}
                        <div className="settings-subsection">
                          <div className="layout-section-title">
                            {t('customRPCGraphAPI')}
                          </div>
                          <div className="settings-section-subtitle">
                            {t('specifyCustomEndpoints')}
                          </div>

                          <div className="custom-rpc-settings">
                            <div className="input-group">
                              <label className="input-label">{t('rpcURL')}</label>
                              <input
                                type="text"
                                className="input-field"
                                value={rpcUrl}
                                placeholder="https://rpc.monad.xyz"
                                onChange={e => {
                                  setRpcUrl(e.target.value)
                                  localStorage.setItem('crystal_rpc_url', e.target.value)
                                }}
                              />
                            </div>

                            <div className="input-group">
                              <label className="input-label">{t('graphAPIURL')}</label>
                              <input
                                type="text"
                                className="input-field"
                                value={graphUrl}
                                placeholder="https://gateway.thegraph.com/api/YOUR_API_KEY/subgraphs/id/..."
                                onChange={e => {
                                  setGraphUrl(e.target.value)
                                  localStorage.setItem('crystal_graph_url', e.target.value)
                                }}
                              />
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  )}
                  {activeSettingsSection === 'layout' && (
                    <div className="settings-section-content">
                      {/* Trading Mode Selector */}
                      <div className="layout-options">
                        <div>
                          <div className="layout-section-title">
                            {t('tradingModeSettings')}
                          </div>
                          <div className="settings-section-subtitle">
                            {t('configureEachModeIndependently')}
                          </div>
                          <div className="layout-section" style={{ display: 'flex', gap: '12px' }}>
                            <button
                              className={`control-layout-option ${activeTradingMode === 'spot' ? 'active' : ''}`}
                              onClick={() => {
                                setActiveTradingMode('spot');
                                localStorage.setItem('crystal_trading_mode', 'spot');
                              }}
                              style={{ flex: 1 }}
                            >
                              <div className="layout-label">
                                <span className="control-layout-name">{t('spot')}</span>
                              </div>
                            </button>

                            <button
                              className={`control-layout-option ${activeTradingMode === 'perps' ? 'active' : ''}`}
                              onClick={() => {
                                setActiveTradingMode('perps');
                                localStorage.setItem('crystal_trading_mode', 'perps');
                              }}
                              style={{ flex: 1 }}
                            >
                              <div className="layout-label">
                                <span className="control-layout-name">{t('perps')}</span>
                              </div>
                            </button>

                            <button
                              className={`control-layout-option ${activeTradingMode === 'spectra' ? 'active' : ''}`}
                              onClick={() => {
                                setActiveTradingMode('spectra');
                                localStorage.setItem('crystal_trading_mode', 'spectra');
                              }}
                              style={{ flex: 1 }}
                            >
                              <div className="layout-label">
                                <span className="control-layout-name">{t('spectra')}</span>
                              </div>
                            </button>
                          </div>
                        </div>
                      </div>

                      {/* Trade Panel Position - only show for spot/perps, not spectra */}
                      {!simpleView && activeTradingMode !== 'spectra' && (
                        <div className="layout-options">
                          <div>
                            <div className="layout-section-title">
                              {t('tradePanelPosition')} ({activeTradingMode === 'spot' ? t('spot') : t('perps')})
                            </div>
                            <div className="settings-section-subtitle">
                              {t('chooseTradingPanelPosition')}
                            </div>
                            <div className="layout-section">
                              <button
                                className={`layout-option ${getActiveLayoutSettings() === 'alternative' ? 'active' : ''}`}
                                onClick={() => {
                                  if (activeTradingMode === 'perps') {
                                    setPerpsLayoutSettings('alternative');
                                    localStorage.setItem('crystal_perps_layout', 'alternative');
                                  } else {
                                    setSpotLayoutSettings('alternative');
                                    localStorage.setItem('crystal_spot_layout', 'alternative');
                                  }
                                }}
                              >
                                <div className="layout-preview-container">
                                  <div className="preview-trade"></div>
                                  <div className="layout-preview-wrapper">
                                    <div className="layout-preview alternative-layout">
                                      <div className="preview-chart"></div>
                                      <div className="preview-orderbook"></div>
                                    </div>
                                    <div className="layout-preview-bottom">
                                      <div className="preview-ordercenter"></div>
                                    </div>
                                  </div>
                                </div>
                                <div className="layout-label">
                                  <span className="layout-name">
                                    {t('left')} {t('panel')}
                                  </span>
                                </div>
                              </button>

                              <button
                                className={`layout-option ${getActiveLayoutSettings() === 'default' ? 'active' : ''}`}
                                onClick={() => {
                                  if (activeTradingMode === 'perps') {
                                    setPerpsLayoutSettings('default');
                                    localStorage.setItem('crystal_perps_layout', 'default');
                                  } else {
                                    setSpotLayoutSettings('default');
                                    localStorage.setItem('crystal_spot_layout', 'default');
                                  }
                                }}
                              >
                                <div className="layout-preview-container">
                                  <div className="layout-preview-wrapper">
                                    <div className="layout-preview alternative-layout">
                                      <div className="preview-chart" />
                                      <div className="preview-orderbook" />
                                    </div>
                                    <div className="layout-preview-bottom">
                                      <div className="preview-ordercenter" />
                                    </div>
                                  </div>
                                  <div className="preview-trade" />
                                </div>

                                <div className="layout-label">
                                  <span className="layout-name">
                                    {t('right')} {t('panel')}
                                  </span>
                                </div>
                              </button>
                            </div>
                          </div>

                          {/* Orderbook Position */}
                          <div>
                            <div className="layout-section-title">
                              {t('orderbookPosition')} ({activeTradingMode === 'spot' ? t('spot') : t('perps')})
                            </div>
                            <div className="settings-section-subtitle">
                              {t('positionOrderbookSide')}
                            </div>
                            <div className="layout-section">
                              <button
                                className={`layout-option ${getActiveOrderbookPosition() === 'left' ? 'active' : ''}`}
                                onClick={() => {
                                  if (activeTradingMode === 'perps') {
                                    setPerpsOrderbookPosition('left');
                                    localStorage.setItem('crystal_perps_orderbook', 'left');
                                  } else {
                                    setSpotOrderbookPosition('left');
                                    localStorage.setItem('crystal_spot_orderbook', 'left');
                                  }
                                }}
                              >
                                <div className="ob-layout-preview-container">
                                  <div className="ob-layout-preview alternative-layout">
                                    <div className="ob-preview-orderbook">
                                      <div className="ob-preview-sell"></div>
                                      <div className="ob-preview-buy"></div>
                                    </div>
                                    <div className="ob-preview-chart"></div>
                                  </div>
                                </div>
                                <div className="layout-label">
                                  <span className="layout-name">
                                    {t('left')} {t('side')}
                                  </span>
                                </div>
                              </button>

                              <button
                                className={`layout-option ${getActiveOrderbookPosition() === 'right' ? 'active' : ''}`}
                                onClick={() => {
                                  if (activeTradingMode === 'perps') {
                                    setPerpsOrderbookPosition('right');
                                    localStorage.setItem('crystal_perps_orderbook', 'right');
                                  } else {
                                    setSpotOrderbookPosition('right');
                                    localStorage.setItem('crystal_spot_orderbook', 'right');
                                  }
                                }}
                              >
                                <div className="ob-layout-preview-container">
                                  <div className="ob-layout-preview alternative-layout">
                                    <div className="ob-preview-chart"></div>
                                    <div className="ob-preview-orderbook">
                                      <div className="ob-preview-sell"></div>
                                      <div className="ob-preview-buy"></div>
                                    </div>
                                  </div>
                                </div>
                                <div className="layout-label">
                                  <span className="layout-name">
                                    {t('right')} {t('side')}
                                  </span>
                                </div>
                              </button>
                            </div>
                          </div>
                        </div>
                      )}

                      {/* For Spectra, show message that it uses fixed layout */}
                      {activeTradingMode === 'spectra' && (
                        <div className="layout-options">
                          <div className="settings-section-subtitle" style={{ textAlign: 'center', padding: '40px 20px', opacity: 0.7 }}>
                            {t('spectraUsesFixedLayout')}
                          </div>
                        </div>
                      )}

                      {/* Notification Position - show for all modes */}
                      <div>
                        <div className="layout-section-title">
                          {t('notificationPosition')}
                        </div>
                        <div className="settings-section-subtitle">
                          {t('chooseNotificationPopupPosition')}
                        </div>
                        <div className="notification-position-grid">
                          <button
                            className={`notification-position-option ${notificationPosition === 'top-left' ? 'active' : ''}`}
                            onClick={() => updateNotificationPosition('top-left')}
                          >
                            <div className="position-preview-container">
                              <div className="preview-popup top-left"></div>
                            </div>
                          </button>

                          <button
                            className={`notification-position-option ${notificationPosition === 'top-right' ? 'active' : ''}`}
                            onClick={() => updateNotificationPosition('top-right')}
                          >
                            <div className="position-preview-container">
                              <div className="preview-popup top-right"></div>
                            </div>
                          </button>

                          <button
                            className={`notification-position-option ${notificationPosition === 'bottom-left' ? 'active' : ''}`}
                            onClick={() => updateNotificationPosition('bottom-left')}
                          >
                            <div className="position-preview-container">
                              <div className="preview-popup bottom-left"></div>
                            </div>
                          </button>

                          <button
                            className={`notification-position-option ${notificationPosition === 'bottom-right' ? 'active' : ''}`}
                            onClick={() => updateNotificationPosition('bottom-right')}
                          >
                            <div className="position-preview-container">
                              <div className="preview-popup bottom-right"></div>
                            </div>
                          </button>
                        </div>
                      </div>
                    </div>
                  )}

                  {activeSettingsSection === 'display' && (
                    <div className="settings-section-content">
                      <div className="trade-markers-toggle-row">
                        <div className="settings-option-info">
                          <span className="trade-markers-toggle-label">
                            {t('showChartOrders')}
                          </span>
                          <span className="settings-option-subtitle">
                            {t('showActiveOrdersOnChart')}
                          </span>
                        </div>
                        <ToggleSwitch
                          checked={isOrdersVisible}
                          onChange={() => {
                            setIsOrdersVisible(!isOrdersVisible);
                            localStorage.setItem(
                              'crystal_orders_visible',
                              JSON.stringify(!isOrdersVisible),
                            );
                          }}
                        />
                      </div>
                      <div className="orderbook-toggle-row">
                        <div className="settings-option-info">
                          <span className="orderbook-toggle-label">
                            {t('showOB')}
                          </span>
                          <span className="settings-option-subtitle">
                            {t('displayOrderbookPanel')}
                          </span>
                        </div>
                        <ToggleSwitch
                          checked={isOrderbookVisible}
                          onChange={() => {
                            setIsOrderbookVisible(!isOrderbookVisible);
                            localStorage.setItem(
                              'crystal_orderbook_visible',
                              JSON.stringify(!isOrderbookVisible),
                            );
                          }}
                        />
                      </div>

                      <div className="ordercenter-toggle-row">
                        <div className="settings-option-info">
                          <span className="ordercenter-toggle-label">
                            {t('showOC')}
                          </span>
                          <span className="settings-option-subtitle">
                            {t('showOrderCenterAtBottom')}
                          </span>
                        </div>
                        <ToggleSwitch
                          checked={isOrderCenterVisible}
                          onChange={() => {
                            setIsOrderCenterVisible(!isOrderCenterVisible);
                            localStorage.setItem(
                              'crystal_ordercenter_visible',
                              JSON.stringify(!isOrderCenterVisible),
                            );
                          }}
                        />
                      </div>
                    </div>
                  )}

                  {activeSettingsSection === 'audio' && (
                    <div className="settings-section-content">
                      <div className="audio-toggle-row">
                        <div className="settings-option-info">
                          <span className="audio-toggle-label">{t('audioNotifications')}</span>
                          <span className="settings-option-subtitle">
                            {t('playSoundsForTrades')}
                          </span>
                        </div>
                        <ToggleSwitch
                          checked={isAudioEnabled}
                          onChange={() => {
                            setIsAudioEnabled(!isAudioEnabled);
                            localStorage.setItem('crystal_audio_notifications', JSON.stringify(!isAudioEnabled));
                          }}
                        />
                      </div>
                      {isAudioEnabled && (
                        <div className="popup-type-settings">
                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('playSwapSounds')}</span>
                              <span className="settings-option-subtitle">
                                {t('playSoundsForSwaps')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={audioGroups.swap}
                              onChange={() => toggleAudioGroup('swap')}
                            />
                          </div>

                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('playOrderSounds')}</span>
                              <span className="settings-option-subtitle">
                                {t('playSoundsForOrders')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={audioGroups.order}
                              onChange={() => toggleAudioGroup('order')}
                            />
                          </div>

                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('playTransferSounds')}</span>
                              <span className="settings-option-subtitle">
                                {t('playSoundsForTransfers')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={audioGroups.transfer}
                              onChange={() => toggleAudioGroup('transfer')}
                            />
                          </div>

                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('playApprovalSounds')}</span>
                              <span className="settings-option-subtitle">
                                {t('playSoundsForApprovals')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={audioGroups.approve}
                              onChange={() => toggleAudioGroup('approve')}
                            />
                          </div>
                        </div>
                      )}

                      <div className="audio-toggle-row">
                        <div className="settings-option-info">
                          <span className="audio-toggle-label">{t('notificationControls')}</span>
                          <span className="settings-option-subtitle">
                            {t('showAdvancedNotificationOptions')}
                          </span>
                        </div>
                        <ToggleSwitch
                          checked={hideNotificationPopups}
                          onChange={() => {
                            const newValue = !hideNotificationPopups;
                            setHideNotificationPopups(newValue);
                            localStorage.setItem('crystal_hide_notification_popups', JSON.stringify(newValue));
                          }}
                        />
                      </div>

                      {hideNotificationPopups && (
                        <div className="popup-type-settings">
                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('hideSwapNotifications')}</span>
                              <span className="settings-option-subtitle">
                                {t('hideSwapNotificationsDesc')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={hiddenPopupTypes.swap === true && hiddenPopupTypes.swapFailed === true}
                              onChange={() => {
                                const shouldHide = !(hiddenPopupTypes.swap === true && hiddenPopupTypes.swapFailed === true);
                                updateMultipleHiddenPopupTypes(['swap', 'swapFailed'], shouldHide);
                              }}
                            />
                          </div>

                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('hideOrderNotifications')}</span>
                              <span className="settings-option-subtitle">
                                {t('hideOrderNotificationsDesc')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={hiddenPopupTypes.limit === true && hiddenPopupTypes.fill === true && hiddenPopupTypes.cancel === true && hiddenPopupTypes.limitFailed === true}
                              onChange={() => {
                                const shouldHide = !(hiddenPopupTypes.limit === true && hiddenPopupTypes.fill === true && hiddenPopupTypes.cancel === true && hiddenPopupTypes.limitFailed === true);
                                updateMultipleHiddenPopupTypes(['limit', 'fill', 'cancel', 'limitFailed'], shouldHide);
                              }}
                            />
                          </div>

                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('hideTransferNotifications')}</span>
                              <span className="settings-option-subtitle">
                                {t('hideTransferNotificationsDesc')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={hiddenPopupTypes.send === true && hiddenPopupTypes.sendFailed === true && hiddenPopupTypes.wrap === true && hiddenPopupTypes.unwrap === true && hiddenPopupTypes.stake === true}
                              onChange={() => {
                                const shouldHide = !(hiddenPopupTypes.send === true && hiddenPopupTypes.sendFailed === true && hiddenPopupTypes.wrap === true && hiddenPopupTypes.unwrap === true && hiddenPopupTypes.stake === true);
                                updateMultipleHiddenPopupTypes(['send', 'sendFailed', 'wrap', 'unwrap', 'stake'], shouldHide);
                              }}
                            />
                          </div>

                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('hideApprovalNotifications')}</span>
                              <span className="settings-option-subtitle">
                                {t('hideApprovalNotificationsDesc')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={hiddenPopupTypes.approve === true}
                              onChange={() => {
                                updateHiddenPopupType('approve', !hiddenPopupTypes.approve);
                              }}
                            />
                          </div>
                        </div>
                      )}
                    </div>
                  )}

                  {activeSettingsSection === 'keybinds' && (
                    <div className="settings-section-content">
                      <div className="keybinds-section">
                        <div className="settings-subsection">
                          <div className="layout-section-title">{t('tradingShortcuts')}</div>
                          <div className="settings-section-subtitle">
                            {t('keyboardShortcutsForTrading')}
                          </div>
                          {renderKeybindButton('submitTransaction', t('submitTransaction'), t('executeTradesPlaceOrders'))}
                          {renderKeybindButton('switchTokens', t('switchTokens'), t('swapInputOutputTokens'))}
                          {renderKeybindButton('maxAmount', t('maxAmount'), t('setInputToMaxBalance'))}
                          {renderKeybindButton('focusInput', t('focusInput'), t('focusMainAmountInput'))}
                        </div>
                        <div className="settings-subsection">
                          <div className="layout-section-title">{t('tokenSelection')}</div>
                          <div className="settings-section-subtitle">
                            {t('quickAccessTokenSelection')}
                          </div>
                          {renderKeybindButton('openTokenInSelect', t('selectInputToken'), t('openTokenSelectionForInput'))}
                          {renderKeybindButton('openTokenOutSelect', t('selectOutputToken'), t('openTokenSelectionForOutput'))}
                        </div>
                        <div className="settings-subsection">
                          <div className="layout-section-title">{t('orderManagement')}</div>
                          <div className="settings-section-subtitle">
                            {t('manageActiveOrdersQuickly')}
                          </div>
                          {renderKeybindButton('cancelAllOrders', t('cancelAllOrders'), t('cancelAllActiveOrders'))}
                          {renderKeybindButton('cancelTopOrder', t('cancelTopOrder'), t('cancelMostRecentOrder'))}
                        </div>
                        <div className="settings-subsection">
                          <div className="layout-section-title">{t('interfaceShortcuts')}</div>
                          <div className="settings-section-subtitle">
                            {t('navigateInterfaceQuickly')}
                          </div>
                          {renderKeybindButton('openSettings', t('openSettings'), t('openSettingsPanel'))}
                          {renderKeybindButton('openWallet', t('openWallet'), t('openWalletConnectionPortfolio'))}
                          {renderKeybindButton('toggleSimpleView', t('toggleSimpleView'), t('switchBetweenSimpleAdvanced'))}
                          {renderKeybindButton('refreshQuote', t('refreshQuote'), t('refreshCurrentPriceQuote'))}
                        </div>
                        <div className="settings-subsection">
                          <div className="layout-section-title">{t('marketShortcuts')}</div>
                          <div className="settings-section-subtitle">
                            {t('interactWithMarketDataQuickly')}
                          </div>
                          {renderKeybindButton('toggleFavorite', t('toggleFavorite'), t('addRemoveCurrentMarketFavorites'))}
                        </div>
                      </div>
                    </div>
                  )}
                </div>

                <button
                  className="reset-tab-button"
                  onClick={() => {
                    switch (activeSettingsSection) {
                      case 'general':
                        setLanguage('EN');
                        localStorage.setItem('crystal_language', 'EN');
                        setSpotSliderMode('slider');
                        localStorage.setItem('crystal_spot_slider_mode', 'slider');
                        setSpotSliderPresets([25, 50, 75]);
                        localStorage.setItem('crystal_spot_slider_presets', JSON.stringify([25, 50, 75]));
                        setSpotSliderIncrement(10);
                        localStorage.setItem('crystal_spot_slider_increment', '10');
                        setRpcUrl('');
                        localStorage.setItem('crystal_rpc_url', '');
                        setGraphUrl('');
                        localStorage.setItem('crystal_graph_url', '');
                        break;

                      case 'layout':
                        setSpotLayoutSettings('default');
                        localStorage.setItem('crystal_layout', 'default');
                        setSpotOrderbookPosition('right');
                        localStorage.setItem('crystal_orderbook', 'right');
                        setNotificationPosition('bottom-right');
                        localStorage.setItem('crystal_notification_position', 'bottom-right');
                        break;

                      case 'display':
                        setIsMarksVisible(true);
                        localStorage.setItem('crystal_marks_visible', 'true');
                        setIsOrdersVisible(true);
                        localStorage.setItem('crystal_orders_visible', 'true');
                        setIsOrderbookVisible(true);
                        localStorage.setItem('crystal_orderbook_visible', 'true');
                        setIsOrderCenterVisible(true);
                        localStorage.setItem('crystal_ordercenter_visible', 'true');
                        setShowChartOutliers(false);
                        localStorage.setItem('crystal_show_chart_outliers', 'false');
                        break;

                      case 'audio':
                        setIsAudioEnabled(false);
                        localStorage.setItem('crystal_audio_notifications', 'false');
                        setAudioGroups({ swap: true, order: true, transfer: true, approve: true });
                        localStorage.setItem('crystal_audio_groups', JSON.stringify({ swap: true, order: true, transfer: true, approve: true }));
                        setHideNotificationPopups(false);
                        localStorage.setItem('crystal_hide_notification_popups', 'false');
                        setHiddenPopupTypes({});
                        localStorage.setItem('crystal_hidden_popup_types', JSON.stringify({}));
                        break;

                      case 'keybinds':
                        const defaultKeybinds = {
                          submitTransaction: 'Enter',
                          switchTokens: 'KeyZ',
                          maxAmount: 'KeyA',
                          focusInput: 'KeyF',
                          openSettings: 'KeyP',
                          openWallet: 'KeyW',
                          openTokenInSelect: 'KeyQ',
                          openTokenOutSelect: 'KeyE',
                          cancelAllOrders: 'KeyC',
                          cancelTopOrder: 'KeyX',
                          toggleFavorite: 'KeyM',
                          toggleSimpleView: 'KeyV',
                          refreshQuote: 'KeyR',
                        };
                        setKeybinds(defaultKeybinds);
                        localStorage.setItem('crystal_keybinds', JSON.stringify(defaultKeybinds));
                        setEditingKeybind(null);
                        setIsListeningForKey(false);
                        break;
                    }
                  }}
                >
                  {t('resetTab')}
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 6 && selectedConnector ? (
          <div ref={popupref} className="connecting-popup">
            <div className="connecting-content">
              <div className="connecting-header">
                <button
                  className="connecting-back-button"
                  onClick={() => {
                    setpopup(4);
                    setSelectedConnector(null);
                  }}
                >
                  <svg
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                  >
                    <path d="M19 12H5M12 19l-7-7 7-7" />
                  </svg>
                </button>
                <button
                  className="disconnected-wallet-close-button"
                  onClick={() => {
                    setpopup(0);
                    setSelectedConnector(null);
                  }}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div className="logo-container">
                <div className="logo-spinner" />
                <img
                  src={
                    selectedConnector.name === 'MetaMask'
                      ? walletmetamask
                      : selectedConnector.name === 'Coinbase Wallet'
                        ? walletcoinbase
                        : selectedConnector.name === 'WalletConnect'
                          ? walletconnect
                          : selectedConnector.name === 'Safe'
                            ? walletsafe
                            : selectedConnector.name === 'Rabby Wallet'
                              ? walletrabby
                              : selectedConnector.name === 'Backpack'
                                ? walletbackpack
                                : selectedConnector.name === 'Phantom'
                                  ? walletphantom
                                  : selectedConnector.name === 'Tomo' ? wallettomo : selectedConnector.name === 'HaHa Wallet' ? wallethaha : walletinjected
                  }
                  className="wallet-logo"
                />
              </div>

              <h2 className="connecting-title">{selectedConnector.name}</h2>
              <p className="connecting-text">{t('requestingConnection')}</p>
              <p className="connecting-subtext">
                {t('confirmConnection1')} {selectedConnector.name}{' '}
                {t('confirmConnection2')}.
              </p>
            </div>
          </div>
        ) : null}
        {popup === 7 ? (
          <TokenInfoPopupContent
            symbol={activeMarket.baseAsset}
            setpopup={setpopup}
            ref={popupref}
          />
        ) : null}
        {popup === 8 ? (
          <div className="search-markets-dropdown-popup" ref={popupref}>
            <div className="search-markets-dropdown-header">
              <div className="search-container">
                <div className="search-wrapper">
                  <SearchIcon className="search-icon" size={12} />
                  <input
                    ref={searchInputRef}
                    type="text"
                    placeholder={t('searchMarkets')}
                    className="search-input"
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    onKeyDown={handleSearchKeyDown}
                    autoFocus={!(windowWidth <= 1020)}
                  />
                  {searchQuery && (
                    <button
                      type="button"
                      className="cancel-search"
                      onClick={() => setSearchQuery('')}
                    >
                      {t('clear')}
                    </button>
                  )}
                </div>
              </div>
            </div>

            <div className="search-markets-list-header">
              <div className="favorites-header">
                <button
                  onClick={() => handleSort('favorites')}
                  className="favorite-sort-button"
                >
                  <svg
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="1.5"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className="favorites-sort-icon"
                  >
                    <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z" />
                  </svg>
                </button>
              </div>
              <div
                className="search-header-item"
                onClick={() => handleSort('volume')}
              >
                {t('market')} / {t('volume')}
                <SortArrow
                  sortDirection={
                    sortField === 'volume' ? sortDirection : undefined
                  }
                  onClick={(e) => {
                    e.stopPropagation();
                    handleSort('volume');
                  }}
                />
              </div>
              <div
                className="search-header-item"
                onClick={() => handleSort('change')}
              >
                {t('last') + ' ' + t('day')}
                <SortArrow
                  sortDirection={
                    sortField === 'change' ? sortDirection : undefined
                  }
                  onClick={(e) => {
                    e.stopPropagation();
                    handleSort('change');
                  }}
                />
              </div>
              <div
                className="search-header-item"
                onClick={() => handleSort('price')}
              >
                {t('price')}
                <SortArrow
                  sortDirection={
                    sortField === 'price' ? sortDirection : undefined
                  }
                  onClick={(e) => {
                    e.stopPropagation();
                    handleSort('price');
                  }}
                />
              </div>
            </div>
            <div
              className="search-markets-list"
              id="search-markets-list-container"
            >
              {sortedMarkets.filter((market) => {
                const matchesSearch = market?.pair
                  .toLowerCase()
                  .includes(searchQuery.toLowerCase());
                const notWeth =
                  market?.baseAddress !== settings.chainConfig[activechain].weth;
                return matchesSearch && notWeth;
              }).length > 0 ? (
                sortedMarkets.filter((market) => {
                  const matchesSearch = market?.pair
                    .toLowerCase()
                    .includes(searchQuery.toLowerCase());
                  const notWeth =
                    market?.baseAddress !== settings.chainConfig[activechain].weth;
                  return matchesSearch && notWeth;
                }).map((market, index) => (
                  <div
                    key={market.pair}
                    className={`search-market-item ${index === selectedIndex ? 'selected' : ''}`}
                    onClick={() => {
                      setSearchQuery('');
                      setpopup(0);
                      onMarketSelect(market)
                    }}
                    onMouseEnter={() => setSelectedIndex(index)}
                    role="button"
                    tabIndex={-1}
                    id={`search-market-item-${index}`}
                  >
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        toggleFavorite(market.baseAddress?.toLowerCase() ?? '');
                        refocusSearchInput();
                      }}
                      onMouseDown={(e) => e.preventDefault()}
                      tabIndex={-1}
                      className={`dropdown-market-favorite-button 
                            ${favorites.includes(market.baseAddress?.toLowerCase() ?? '') ? 'active' : ''}`}
                    >
                      <svg
                        width="16"
                        height="16"
                        viewBox="0 0 24 24"
                        fill={
                          favorites.includes(
                            market.baseAddress?.toLowerCase() ?? '',
                          )
                            ? 'currentColor'
                            : 'none'
                        }
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z" />
                      </svg>
                    </button>

                    <div className="search-market-pair-section">
                      <img src={market.image} className="market-icon" />
                      <div className="market-info">
                        <span className="market-pair">{market.pair}</span>
                        <span className="market-volume">
                          ${formatCommas(market.volume)}
                        </span>
                      </div>
                    </div>
                    <div className="search-market-chart-section">
                      <MiniChart
                        market={market}
                        series={market.series}
                        priceChange={market.priceChange}
                        isVisible={true}
                      />
                    </div>
                    <div className="search-market-price-section">
                      <div className="search-market-price">
                        {formatSubscript(market.currentPrice)}
                      </div>
                      <div
                        className={`search-market-change ${market.priceChange.startsWith('-') ? 'negative' : 'positive'}`}
                      >
                        {market.priceChange}
                      </div>
                    </div>
                  </div>
                ))
              ) : (
                <div className="no-markets-message">{t('noMarkets')}</div>
              )}
            </div>

            <div className="keyboard-shortcuts-container">
              <div className="keyboard-shortcut">
                <span className="arrow-key"></span>
                <span className="arrow-key"></span>
                <span>{t('toNavigate')}</span>
              </div>
              <div className="keyboard-shortcut">
                <span className="key">Enter</span>
                <span>{t('toSelect')}</span>
              </div>
              <div className="keyboard-shortcut">
                <span className="key">Esc</span>
                <span>{t('toClose')}</span>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 9 ? (
          <div ref={popupref} className="connect-wallet-background unconnected">
            <div className="social-content-container">
              <div className="social-content">
                <h1 className="social-heading">Join our growing community!</h1>
                <p className="social-description">
                  Crystal Exchange is being released in phases. Be the first to know when new features arrive by joining our vibrant community!
                </p>

                <div className="social-buttons">
                  <button
                    className="wallet-option"
                    onClick={() =>
                      window.open('https://discord.gg/CrystalExch', '_blank')
                    }
                  >
                    <img
                      className="connect-wallet-icon"
                      src="https://assets-global.website-files.com/6257adef93867e50d84d30e2/636e0a69f118df70ad7828d4_icon_clyde_blurple_RGB.svg"
                    />
                    <span className="wallet-name">Join Crystal's Discord</span>
                  </button>

                  <button
                    className="wallet-option"
                    onClick={() =>
                      window.open('https://x.com/CrystalExch', '_blank')
                    }
                  >
                    <img
                      className="connect-wallet-icon"
                      src={Xicon}
                    />
                    <span className="wallet-name">Follow us on X (Twitter)</span>
                  </button>
                </div>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 10 ? ( // send token search popup
          <div ref={popupref} className="sendselectbg">
            <div className="send-top-row">
              <input
                className="sendselect"
                onChange={(e) => {
                  settokenString(e.target.value);
                }}
                placeholder={t('searchToken')}
                autoFocus={!(windowWidth <= 1020)}
              />
              {tokenString && (
                <button
                  className="sendselect-clear visible"
                  onClick={() => {
                    settokenString('');
                    const input = document.querySelector('.sendselect') as HTMLInputElement;
                    if (input) {
                      input.value = '';
                      input.focus();
                    }
                  }}
                >
                  {t('clear')}
                </button>
              )}
              <button
                className="sendselect-back"
                onClick={() => {
                  setpopup(3);
                }}
              >
                <img src={closebutton} className="send-close-button-icon" />
              </button>
            </div>

            <ul className="sendtokenlist">
              {Object.values(tokendict)
                .filter(
                  (token) =>
                    token.ticker.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                    token.name.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                    token.address.toLowerCase().includes(tokenString.trim().toLowerCase())
                ).length === 0 ? (
                <div className="empty-token-list">
                  <div className="empty-token-list-content">
                    <svg
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="empty-token-list-icon"
                    >
                      <circle cx="11" cy="11" r="8" />
                      <path d="M21 21l-4.35-4.35" />
                    </svg>
                    <div className="empty-token-list-text">{t('noTokens')}</div>
                  </div>
                </div>
              ) : (
                Object.values(tokendict)
                  .filter(
                    (token) =>
                      token.ticker.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                      token.name.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                      token.address.toLowerCase().includes(tokenString.trim().toLowerCase())
                  )
                  .map((token) => (
                    <button
                      className="sendtokenbutton"
                      key={token.address}
                      onClick={() => {
                        setSendTokenIn(token.address);
                        setSendUsdValue('');
                        setSendInputAmount('');
                        setSendAmountIn(BigInt(0));
                        settokenString('');
                        setpopup(3);
                      }}
                    >
                      <img className="tokenlistimage" src={token.image} />
                      <div className="tokenlisttext">
                        <div className="tokenlistname">{token.ticker}</div>
                        <div className="tokenlistticker">{token.name}</div>
                      </div>
                      <div className="token-right-content">
                        <div className="tokenlistbalance">
                          {formatDisplayValue(walletTokenBalances[address]?.[token.address], Number(token.decimals))}
                        </div>
                        <div className="token-address-container">
                          <span className="token-address">
                            {`${token.address.slice(0, 6)}...${token.address.slice(-4)}`}
                          </span>
                          <div
                            className="copy-address-button"
                            onClick={(e) => {
                              e.stopPropagation();
                              navigator.clipboard.writeText(token.address);
                              const copyIcon =
                                e.currentTarget.querySelector('.copy-icon');
                              const checkIcon =
                                e.currentTarget.querySelector('.check-icon');
                              if (copyIcon && checkIcon) {
                                copyIcon.classList.add('hidden');
                                checkIcon.classList.add('visible');
                                setTimeout(() => {
                                  copyIcon.classList.remove('hidden');
                                  checkIcon.classList.remove('visible');
                                }, 2000);
                              }
                            }}
                          >
                            <svg
                              className="copy-icon"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                            >
                              <rect
                                x="9"
                                y="9"
                                width="13"
                                height="13"
                                rx="2"
                                ry="2"
                              ></rect>
                              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                            <svg
                              className="check-icon"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                            >
                              <circle cx="12" cy="12" r="10" />
                              <path d="M8 12l3 3 6-6" />
                            </svg>
                          </div>
                        </div>
                      </div>
                    </button>
                  ))
              )}
            </ul>
          </div>
        ) : null}
        {popup === 11 ? (
          <div ref={popupref} className="generating-address-popup">
            <span className="loader"></span>
            <h2 className="generating-address-title">Fetching Your Smart Wallet</h2>
            <p className="generating-address-text">
              Please wait while your smart wallet address is being loaded...
            </p>
          </div>
        ) : null}
        {popup === 12 ? (
          <div ref={popupref} className="deposit-page-container" onClick={(e) => e.stopPropagation()}>
            <div className="deposit-page-header">
              <h2>{t("deposit")}</h2>
              <div className="deposit-right-header">
                {!client && validOneCT && (<button
                  className={`deposit-right-header-btn`}
                  onClick={() => {
                    setOneCTDepositAddress(address);
                    setpopup(25)
                  }}
                >
                  Deposit from EOA
                </button>)}
                <button className="deposit-close-button" onClick={() => { setpopup(0) }}>
                  <img src={closebutton} className="deposit-close-icon" />
                </button>
              </div>
            </div>
            <div className={`token-dropdown-container ${dropdownOpen ? 'open' : ''}`}>
              <div
                className="selected-token-display"
                onClick={() => setDropdownOpen(!dropdownOpen)}
              >
                <div className="selected-token-info">
                  <img className="deposit-token-icon" src={tokendict[selectedDepositToken].image} />
                  <span className="deposit-token-name">{tokendict[selectedDepositToken].name}</span>
                  <span className="deposit-token-ticker">({tokendict[selectedDepositToken].ticker})</span>
                  <CopyButton textToCopy={selectedDepositToken} />
                </div>
                <div className="selected-token-balance">
                  {formatDisplayValue(
                    walletTokenBalances[address]?.[selectedDepositToken] || 0,
                    Number(tokendict[selectedDepositToken].decimals || 18)
                  )}

                  <svg
                    className="deposit-button-arrow"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24"
                    width="24"
                    height="24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  >
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </div>

              </div>
              {dropdownOpen && (
                <div className="token-dropdown-list">
                  {Object.entries(tokendict).slice(0, 3).concat(Object.entries(tokendict).slice(9, 15)).map(([tokenaddress, token]) => (
                    <div
                      key={tokenaddress}
                      className={`token-dropdown-item ${selectedDepositToken === tokenaddress ? 'selected' : ''}`}
                      onClick={() => {
                        setSelectedDepositToken(tokenaddress);
                        setDropdownOpen(false);
                      }}
                    >
                      <div className="dropdown-token-info">
                        <img className="deposit-token-icon" src={token.image} />
                        <span className="deposit-token-name">{token.name}</span>
                        <span className="deposit-token-ticker">({token.ticker})</span>
                        <CopyButton textToCopy={tokenaddress} />
                      </div>
                      <span className="deposit-token-balance">
                        {formatDisplayValue(
                          walletTokenBalances[address]?.[tokenaddress] || 0,
                          Number(token.decimals || 18)
                        )}
                      </span>
                    </div>
                  ))}
                </div>
              )}
            </div>
            <span className="deposit-subtitle">{t('sendTo')}</span>
            <div className="deposit-address-container">
              <div className="deposit-address-box">
                <span className="deposit-address">{address}</span>
                <button
                  className={`deposit-copy-button ${copyTooltipVisible ? 'success' : ''}`}
                  onClick={(e) => {
                    e.stopPropagation()
                    navigator.clipboard.writeText(address || '');
                    setCopyTooltipVisible(true);
                    setTimeout(() => setCopyTooltipVisible(false), 2000);
                  }}
                >
                  {copyTooltipVisible ?
                    <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" strokeWidth="2" fill="none">
                      <polyline points="20 6 9 17 4 12"></polyline>
                    </svg> :
                    <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" strokeWidth="2" fill="none">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
                    </svg>
                  }
                </button>
              </div>
            </div>

            <div className="deposit-warning">
              {t("depositWarning")}
            </div>
            <div className="deposit-qr-container">
              <QRCodeSVG
                value={address || ''}
                size={170}
                level="H"
                includeMargin={true}
                bgColor="#000000"
                fgColor="#ffffff"
              />
            </div>

            <button
              className="deposit-done-button"
              onClick={() => { setpopup(4) }}
            >
              {t('done')}
            </button>
          </div>
        ) : null}
        {popup === 13 ? (
          <div ref={popupref} className="high-impact-confirmation-popup">
            <div className="high-impact-confirmation-header">
              <button
                className="high-impact-close-button"
                onClick={() => {
                  setpopup(0);
                  window.dispatchEvent(new Event('high-impact-cancel'));
                }}
              >
                <img src={closebutton} className="close-button-icon" />
              </button>
            </div>
            <div className="high-impact-content">
              <img className="warning-image" src={warningicon} />

              <p className="high-impact-message">
                {t('Warning')}
              </p>

              <div className="high-impact-details">
                <div className="high-impact-detail-row">
                  <span className="high-impact-value-title">{t('priceImpact')}</span>
                  <span className="high-impact-value">{priceImpact}</span>
                </div>

                <div className="high-impact-detail-row">
                  <span className="high-impact-value-title">{t('pay')}</span>
                  <span className="high-impact-value">
                    {formatDisplayValue(
                      amountIn,
                      Number(tokendict[tokenIn].decimals)
                    )} {tokendict[tokenIn].ticker}
                  </span>
                </div>

                <div className="high-impact-detail-row">
                  <span className="high-impact-value-title">{t('receive')}</span>
                  <span className="high-impact-value">
                    {formatDisplayValue(
                      amountOutSwap,
                      Number(tokendict[tokenOut].decimals)
                    )} {tokendict[tokenOut].ticker}
                  </span>
                </div>
              </div>
            </div>

            <div className="high-impact-actions">
              <button
                className="high-impact-cancel-button"
                onClick={() => {
                  setpopup(0);
                  window.dispatchEvent(new Event('high-impact-cancel'));
                }}
              >
                {t('cancel')}
              </button>

              <button
                className="high-impact-confirm-button"
                onClick={async () => {
                  setpopup(0);
                  window.dispatchEvent(new Event('high-impact-confirm'));
                }}
              >
                {t('confirmSwap')}
              </button>
            </div>
          </div>
        ) : null}
        {(popup === 17) ? (
          <div ref={popupref} className={`ref-address-popup`}>
            <div className="onboarding-header">
              <h2 className="use-ref-title">Add a referral code (optional)</h2>
              <div className="form-group">
                {error && <span className="error-message">{error}</span>}

                <input
                  className="ref-username-input"
                  placeholder="Enter a code"
                  value={typedRefCode}
                  onChange={e => {
                    const value = e.target.value.trim();
                    if (new RegExp(/^[a-zA-Z0-9-]{0,20}$/).test(value) || value === "") {
                      setTypedRefCode(value);
                      setError('')
                    }
                  }}
                />
              </div>

              <div className="onboarding-actions">
                <button
                  className={`create-username-button ${isRefSigning ? 'signing' : !typedRefCode ? 'disabled' : ''}`}
                  disabled={!typedRefCode || isRefSigning}
                  onClick={async () => {
                    const ok = await handleSetRef(typedRefCode);
                    if (ok) {
                      audio.currentTime = 0;
                      audio.play();
                      if (subWallets.length == 0) {
                        setpopup(28);
                      }
                      else {
                        setpopup(0);
                      }
                    }
                  }}
                >
                  {isRefSigning ? (
                    <div className="button-content">
                      <div className="loading-spinner" />
                      {t('signTransaction')}
                    </div>
                  ) : t('setReferral')}
                </button>

                <button
                  className="skip-button"
                  onClick={() => {
                    audio.currentTime = 0;
                    audio.play();
                    setpopup(0);
                  }}
                >
                  Skip
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 19 ? (
          <div className="edit-limit-price-popup-bg" ref={popupref}>
            <div className="edit-limit-price-header">
              <span className="edit-limit-price-title">Edit Limit Price</span>
              <span className="edit-limit-price-subtitle">Adjust the price at which your limit order will trigger</span>
            </div>
            <div className="edit-limit-price-content">
              <input
                className="edit-limit-price-input"
                type="text"
                inputMode="decimal"
                value={currentLimitPriceString}
                placeholder="0.00"
                onChange={e => {
                  const val = e.target.value;
                  if (
                    new RegExp(
                      `^\\d*\\.?\\d{0,${Math.floor(Math.log10(Number(activeMarket.priceFactor)))}}$`
                    ).test(val) && (activeMarket?.marketType != 0 ? val.replace(/^0+|\.|e.*$/gi, '').replace(/^0+/, '').replace(/0+$/, match => '').length <= 5 : true)
                  ) {
                    setCurrentLimitPriceString(val);
                    setHasEditedPrice(true);

                    const num = parseFloat(val);
                    if (!isNaN(num)) setCurrentLimitPrice(num);
                  }
                }}
              />

              {(() => {
                const isBuyOrder = editingOrder[3] === 1;
                const market = markets[editingOrder[4]];
                let midPriceRaw = 0;
                if (mids?.[editingOrder[4]]?.[0]) {
                  const m = mids[editingOrder[4]];
                  midPriceRaw = isBuyOrder
                    ? (m[0] === m[1] ? m[2] : m[0])
                    : (m[0] === m[2] ? m[1] : m[0]);
                }
                const midPrice = market.priceFactor
                  ? Number(midPriceRaw) / Number(market.priceFactor)
                  : 0;
                const showWarning =
                  midPrice > 0 &&
                  ((isBuyOrder && currentLimitPrice > midPrice) ||
                    (!isBuyOrder && currentLimitPrice < midPrice));

                return showWarning ? (
                  <div className="edit-limit-price-warning">
                    <span>
                      {isBuyOrder
                        ? t('priceOutOfRangeWarningBuy')
                        : t('priceOutOfRangeWarningSell')}
                    </span>
                  </div>
                ) : null;
              })()}

              <div className="edit-limit-price-button-container">
                {[0.995, 0.99, 0.975, 0.95].map(factor => {
                  const label = `${((factor - 1) * 100).toFixed(2)}%`;
                  return (
                    <button
                      key={factor}
                      className="edit-limit-price-level-button"
                      onClick={() => {
                        const isBuyOrder = editingOrder[3] === 1;
                        const raw =
                          currentLimitPrice *
                          (isBuyOrder ? factor : 1 / factor);
                        const decimals = Math.floor(
                          Math.log10(Number(markets[editingOrder[4]].priceFactor))
                        );
                        const newPrice = parseFloat(raw.toFixed(decimals));
                        setCurrentLimitPrice(newPrice);
                        setCurrentLimitPriceString(newPrice.toFixed(decimals));
                        setHasEditedPrice(true);
                      }}
                    >
                      {editingOrder[3] === 1 ? label : `+${label.slice(1)}`}
                    </button>
                  );
                })}
              </div>

              <div className="edit-limit-price-actions">
                <div className="edit-limit-price-actions">
                  <button
                    className="edit-limit-price-confirm-button"
                    onClick={handleEditLimitPriceConfirm}
                    disabled={isEditingSigning || !hasEditedPrice}
                    style={{
                      opacity: isEditingSigning || !hasEditedPrice ? 0.5 : 1,
                      cursor: isEditingSigning || !hasEditedPrice
                        ? 'not-allowed'
                        : 'pointer',
                    }}
                  >
                    {isEditingSigning ? (
                      <div className="signing-indicator">
                        <div className="loading-spinner" />
                        {validOneCT ? null : <span>{t('signTransaction')}</span>}
                      </div>
                    ) : (
                      'Confirm'
                    )}
                  </button>
                </div>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 20 ? (
          <div className="edit-order-size-popup-bg" ref={popupref}>
            <div className="edit-order-size-header">
              <span className="edit-order-size-title">Edit Order Size</span>
              <span className="edit-order-size-subtitle">Adjust the size of your limit order</span>
            </div>
            <div className="edit-order-size-content">
              {(() => {
                if (!editingOrderSize) return null;

                const tokenAddress = editingOrderSize[3] === 1 ? markets[editingOrderSize[4]].quoteAddress : markets[editingOrderSize[4]].baseAddress;
                const tokenBalance = tokenBalances[tokenAddress] || BigInt(0);
                const tokenDecimals = Number(tokendict[tokenAddress]?.decimals || 18);
                const availableBalance = Number(tokenBalance) / (10 ** tokenDecimals);

                return (
                  <div className="edit-order-size-balance-display">
                    <img src={walleticon} className="balance-wallet-icon" />{' '}
                    <span className="balance-value">{availableBalance.toFixed(2)}</span>
                  </div>
                );
              })()}

              <div className="edit-order-size-input-container">
                <input
                  className="edit-order-size-input"
                  type="text"
                  inputMode="decimal"
                  value={displayValue}
                  placeholder="0.00"
                  onChange={e => {
                    const val = e.target.value;
                    if (!/^\d*(?:\.\d{0,8})?$/.test(val)) return;
                    setOrderSizeString(val);
                    setHasEditedSize(true);

                    if (val === '' || val === '.') {
                      setCurrentOrderSize(0);
                      setOrderSizePercent(0);
                    } else {
                      const num = parseFloat(val);
                      setCurrentOrderSize(num);
                      const pct = originalOrderSize > 0
                        ? Math.round((num / originalOrderSize) * 100)
                        : 100;
                      setOrderSizePercent(Math.min(200, Math.max(0, pct)));
                    }
                  }}
                />
                <span className="edit-order-size-token-label">
                  {editingOrderSize
                    ? tokendict[
                      editingOrderSize[3] === 1
                        ? markets[editingOrderSize[4]].quoteAddress
                        : markets[editingOrderSize[4]].baseAddress
                    ]?.ticker
                    : ''}
                </span>
              </div>

              <div className="order-size-balance-slider-wrapper">
                <div className="order-size-slider-container">
                  <input
                    type="range"
                    className="order-size-balance-amount-slider"
                    min="0"
                    max="200"
                    step="1"
                    value={orderSizePercent}
                    onChange={e => {
                      const pct = parseInt(e.target.value, 10)
                      const newSize = (originalOrderSize * pct) / 100

                      setOrderSizePercent(pct)
                      setCurrentOrderSize(newSize)
                      setOrderSizeString(newSize === 0 ? '' : newSize.toFixed(2))
                      setHasEditedSize(true)

                      const rect = e.target.getBoundingClientRect()
                      const thumb = (pct / 200) * (rect.width - 15) + 15 / 2
                      const popup = document.querySelector('.order-size-slider-percentage-popup')
                      if (popup) (popup as HTMLElement).style.left = `${thumb}px`
                    }}
                    onMouseDown={() => {
                      const popup = document.querySelector('.order-size-slider-percentage-popup')
                      if (popup) popup.classList.add('visible')
                    }}
                    onMouseUp={() => {
                      const popup = document.querySelector('.order-size-slider-percentage-popup')
                      if (popup) popup.classList.remove('visible')
                    }}
                    style={{
                      background: `linear-gradient(to right, rgb(171, 176, 224) ${(orderSizePercent / 200) * 100}%, rgb(21 21 27) ${(orderSizePercent / 200) * 100}%)`,
                    }}
                  />
                  <div className="order-size-slider-percentage-popup">{orderSizePercent}%</div>
                  <div className="order-size-balance-slider-marks">
                    {[0, 50, 100, 150, 200].map((markPercent) => (
                      <span
                        key={markPercent}
                        className="order-size-balance-slider-mark"
                        data-active={orderSizePercent >= markPercent}
                        data-percentage={markPercent}
                        onClick={() => {
                          const newSize = (originalOrderSize * markPercent) / 100;
                          setOrderSizePercent(markPercent);
                          setCurrentOrderSize(parseFloat(newSize.toFixed(8)));
                          setHasEditedSize(true);

                          const slider = document.querySelector('.order-size-balance-amount-slider');
                          const popup = document.querySelector('.order-size-slider-percentage-popup');
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left = `${(rect.width - 15) * (markPercent / 200) + 15 / 2}px`;
                          }
                        }}
                      >
                        {markPercent}%
                      </span>
                    ))}
                  </div>
                </div>
              </div>

              <div className="edit-order-size-actions">
                <button
                  className="edit-order-size-confirm-button"
                  onClick={handleEditOrderSizeConfirm}
                  disabled={(() => {
                    if (!editingOrderSize) return true;

                    const tokenAddress = editingOrderSize[3] === 1 ? markets[editingOrderSize[4]].quoteAddress : markets[editingOrderSize[4]].baseAddress;
                    const tokenBalance = tokenBalances[tokenAddress] || BigInt(0);
                    const tokenDecimals = Number(tokendict[tokenAddress]?.decimals || 18);
                    const availableBalance = Number(tokenBalance) / (10 ** tokenDecimals);
                    const market = markets[editingOrderSize[4]];
                    const baseDecimals = Number(market.baseDecimals);
                    const currentUnfilledAmount = (editingOrderSize[2] - editingOrderSize[7]) / (10 ** baseDecimals);
                    const additionalAmountNeeded = Math.max(0, currentOrderSize - currentUnfilledAmount);
                    const hasInsufficientBalance = additionalAmountNeeded > availableBalance;
                    const isUsdcBacked = market.quoteAsset === 'USDC';
                    const minSize = isUsdcBacked ? 1 : 0.1;
                    const isBelowMinSize = currentOrderSize > 0 && (editingOrderSize[3] === 1 ? currentOrderSize : currentOrderSize * editingOrderSize[0] / Number(market.priceFactor)) < minSize;

                    return isEditingSizeSigning || !hasEditedSize || currentOrderSize <= 0 || hasInsufficientBalance || isBelowMinSize;
                  })()}
                  style={{
                    opacity: (() => {
                      if (!editingOrderSize) return 0.5;

                      const tokenAddress = editingOrderSize[3] === 1 ? markets[editingOrderSize[4]].quoteAddress : markets[editingOrderSize[4]].baseAddress;
                      const tokenBalance = tokenBalances[tokenAddress] || BigInt(0);
                      const tokenDecimals = Number(tokendict[tokenAddress]?.decimals || 18);
                      const availableBalance = Number(tokenBalance) / (10 ** tokenDecimals);

                      const market = markets[editingOrderSize[4]];
                      const baseDecimals = Number(market.baseDecimals);
                      const currentUnfilledAmount = (editingOrderSize[2] - editingOrderSize[7]) / (10 ** baseDecimals);
                      const additionalAmountNeeded = Math.max(0, currentOrderSize - currentUnfilledAmount);
                      const hasInsufficientBalance = additionalAmountNeeded > availableBalance;
                      const isUsdcBacked = market.quoteAsset === 'USDC';
                      const minSize = isUsdcBacked ? 1 : 0.1;
                      const isBelowMinSize = currentOrderSize > 0 && (editingOrderSize[3] === 1 ? currentOrderSize : currentOrderSize * editingOrderSize[0] / Number(market.priceFactor)) < minSize;

                      return (isEditingSizeSigning || !hasEditedSize || currentOrderSize <= 0 || hasInsufficientBalance || isBelowMinSize) ? 0.5 : 1;
                    })(),
                    cursor: (() => {
                      if (!editingOrderSize) return 'not-allowed';

                      const tokenAddress = editingOrderSize[3] === 1 ? markets[editingOrderSize[4]].quoteAddress : markets[editingOrderSize[4]].baseAddress;
                      const tokenBalance = tokenBalances[tokenAddress] || BigInt(0);
                      const tokenDecimals = Number(tokendict[tokenAddress]?.decimals || 18);
                      const availableBalance = Number(tokenBalance) / (10 ** tokenDecimals);

                      const market = markets[editingOrderSize[4]];
                      const baseDecimals = Number(market.baseDecimals);
                      const currentUnfilledAmount = (editingOrderSize[2] - editingOrderSize[7]) / (10 ** baseDecimals);
                      const additionalAmountNeeded = Math.max(0, currentOrderSize - currentUnfilledAmount);
                      const hasInsufficientBalance = additionalAmountNeeded > availableBalance;

                      const isUsdcBacked = market.quoteAsset === 'USDC';
                      const minSize = isUsdcBacked ? 1 : 0.1;
                      const isBelowMinSize = currentOrderSize > 0 && (editingOrderSize[3] === 1 ? currentOrderSize : currentOrderSize * editingOrderSize[0] / Number(market.priceFactor)) < minSize;

                      return (isEditingSizeSigning || !hasEditedSize || currentOrderSize <= 0 || hasInsufficientBalance || isBelowMinSize) ? 'not-allowed' : 'pointer';
                    })()
                  }}
                >
                  {(() => {
                    if (!editingOrderSize) return null;
                    const isBuy = editingOrderSize[3] === 1;
                    const market = markets[editingOrderSize[4]];

                    let quotePrice = 1;
                    if (market.quoteAsset !== 'USDC') {
                      const cfg = settings.chainConfig[activechain];
                      const key = `${market.quoteAsset === cfg.wethticker
                        ? cfg.ethticker
                        : market.quoteAsset}USDC`;

                      const tradesMap = trades as any as Record<string, any[]>;
                      const marketsMap = markets as any as Record<string, any>;

                      const lastTrade = tradesMap[key]?.[0]?.[3] ?? 0;
                      const priceFactor = Number(marketsMap[key]?.priceFactor ?? 1);
                      quotePrice = lastTrade / priceFactor;
                    }
                    const baseFilled =
                      editingOrderSize[7] / 10 ** Number(market.baseDecimals);

                    const unfilledInput = isBuy
                      ? originalOrderSize - baseFilled * quotePrice
                      : (editingOrderSize[2] - editingOrderSize[7]) /
                      10 ** Number(market.baseDecimals);

                    const needed = Math.max(0, currentOrderSize - unfilledInput);

                    const inputAddr = isBuy ? market.quoteAddress : market.baseAddress;
                    const available =
                      Number((tokenBalances as any)[inputAddr] ?? BigInt(0)) /
                      10 ** Number((tokendict as any)[inputAddr]?.decimals ?? 18);
                    const isUsdcBacked = market.quoteAsset === 'USDC';
                    const minSize = isUsdcBacked ? 1 : 0.1;
                    const minSizeToken = isUsdcBacked ? 'USDC' : 'MON';
                    const isBelowMinSize = currentOrderSize > 0 && (isBuy ? currentOrderSize : currentOrderSize * editingOrderSize[0] / Number(market.priceFactor)) < minSize;

                    if (needed > available) {
                      return (
                        `Insufficient ${(tokendict as any)[inputAddr]?.ticker} Balance`
                      );
                    }
                    else if (isBelowMinSize) {
                      return (
                        `Minimum order size is ${minSize} ${minSizeToken}`
                      );
                    }

                    return null;
                  })() ?? (isEditingSizeSigning ? (
                    <div className="signing-indicator">
                      <div className="loading-spinner"></div>
                      <span>{t('signTransaction')}</span>
                    </div>
                  ) : (
                    'Confirm'
                  ))}
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 21 ? (<></>) : null}
        {popup === 22 ? (
          <div className="modal-overlay">
            <div className="modal-content vault-action-modal" ref={popupref}>
              <div className="modal-header">
                <h2>Deposit to {selectedVault?.name}</h2>
                <button
                  className="modal-close"
                  onClick={() => {
                    setpopup(0);
                    setselectedVault(null);
                    setVaultDepositAmounts({ shares: 0n, quote: 0n, base: 0n });
                    setVaultInputStrings({ quote: '', base: '' });
                    setVaultQuoteExceedsBalance(false);
                    setVaultBaseExceedsBalance(false);
                    setDepositVaultStep('idle');
                    setDepositVaultError('');
                  }}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div className="modal-body">
                {depositVaultStep === 'idle' && (
                  <div className="vault-deposit-form">
                    <div className="deposit-amounts-section">
                      <div className={`deposit-input-group ${vaultQuoteExceedsBalance ? 'lp-input-container-balance-error' : ''}`}>
                        <div className="deposit-input-wrapper">
                          <input
                            type="text"
                            placeholder="0.0"
                            className={`deposit-amount-input ${vaultQuoteExceedsBalance ? 'lp-input-balance-error' : ''}`}
                            value={vaultInputStrings.quote}
                            onChange={(e) => handleVaultDepositAmountChange('quote', e.target.value)}
                          />
                          <div className="deposit-token-badge">
                            <img
                              src={tokendict[selectedVault?.quoteAsset]?.image}
                              className="deposit-token-icon"
                            />
                            <span>{tokendict[selectedVault?.quoteAsset]?.ticker}</span>
                          </div>
                        </div>

                        <div className="lp-deposit-balance-wrapper">
                          <div className={`lp-deposit-usd-value ${vaultQuoteExceedsBalance ? 'lp-usd-value-balance-error' : ''}`}>
                            {vaultDepositAmounts.quote == 0n
                              ? '$0.00'
                              : formatUSDDisplay(
                                calculateUSDValue(
                                  vaultDepositAmounts.quote,
                                  tradesByMarket[
                                  (({ baseAsset, quoteAsset }) =>
                                    (baseAsset === wethticker ? ethticker : baseAsset) +
                                    (quoteAsset === wethticker ? ethticker : quoteAsset)
                                  )(getMarket(selectedVault?.quoteAsset, selectedVault?.baseAsset))
                                  ],
                                  selectedVault?.quoteAsset,
                                  getMarket(
                                    selectedVault?.quoteAsset,
                                    selectedVault?.baseAsset,
                                  ),
                                ),
                              )}
                          </div>
                          <div className="deposit-balance">
                            <div className="deposit-balance-value">
                              <img src={walleticon} className="balance-wallet-icon" />
                              {selectedVault?.quoteAsset ? formatDisplayValue(
                                tokenBalances[selectedVault?.quoteAsset],
                                Number(tokendict[selectedVault?.quoteAsset]?.decimals || 18)
                              ) : '0.00'}
                            </div>
                            <button
                              className="vault-max-button"
                              onClick={() => {
                                if (selectedVault?.quoteAsset) {
                                  const maxAmount = formatDisplayValue(
                                    tokenBalances[selectedVault?.quoteAsset],
                                    Number(tokendict[selectedVault?.quoteAsset]?.decimals || 18)
                                  ).replace(/,/g, '');
                                  handleVaultDepositAmountChange('quote', maxAmount);
                                }
                              }}
                            >
                              Max
                            </button>
                          </div>
                        </div>
                      </div>
                      <div className={`deposit-input-group ${vaultBaseExceedsBalance ? 'lp-input-container-balance-error' : ''}`}>
                        <div className="deposit-input-wrapper">
                          <input
                            type="text"
                            placeholder="0.0"
                            className={`deposit-amount-input ${vaultBaseExceedsBalance ? 'lp-input-balance-error' : ''}`}
                            value={vaultInputStrings.base}
                            onChange={(e) => handleVaultDepositAmountChange('base', e.target.value)}
                          />
                          <div className="deposit-token-badge">
                            <img
                              src={tokendict[selectedVault?.baseAsset]?.image}
                              className="deposit-token-icon"
                            />
                            <span>{tokendict[selectedVault?.baseAsset]?.ticker}</span>
                          </div>
                        </div>

                        <div className="lp-deposit-balance-wrapper">
                          <div className={`lp-deposit-usd-value ${vaultBaseExceedsBalance ? 'lp-usd-value-balance-error' : ''}`}>
                            {vaultDepositAmounts.base == 0n
                              ? '$0.00'
                              : formatUSDDisplay(
                                calculateUSDValue(
                                  vaultDepositAmounts.base,
                                  tradesByMarket[
                                  (({ baseAsset, quoteAsset }) =>
                                    (baseAsset === wethticker ? ethticker : baseAsset) +
                                    (quoteAsset === wethticker ? ethticker : quoteAsset)
                                  )(getMarket(selectedVault?.quoteAsset, selectedVault?.baseAsset))
                                  ],
                                  selectedVault?.baseAsset,
                                  getMarket(
                                    selectedVault?.quoteAsset,
                                    selectedVault?.baseAsset,
                                  ),
                                ),
                              )}
                          </div>
                          <div className="deposit-balance">
                            <div className="deposit-balance-value">
                              <img src={walleticon} className="balance-wallet-icon" />
                              {selectedVault?.baseAsset ? formatDisplayValue(
                                tokenBalances[selectedVault?.baseAsset],
                                Number(tokendict[selectedVault?.baseAsset]?.decimals || 18)
                              ) : '0.00'}
                            </div>
                            <button
                              className="vault-max-button"
                              onClick={() => {
                                if (selectedVault?.baseAsset) {
                                  const maxAmount = formatDisplayValue(
                                    tokenBalances[selectedVault?.baseAsset],
                                    Number(tokendict[selectedVault?.baseAsset]?.decimals || 18)
                                  ).replace(/,/g, '');
                                  handleVaultDepositAmountChange('base', maxAmount);
                                }
                              }}
                            >
                              Max
                            </button>
                          </div>
                        </div>
                      </div>
                    </div>

                    {vaultDepositAmounts && (
                      <div className="withdraw-preview">
                        <div className="preview-title">Your position:</div>
                        <div className="withdraw-token-preview">
                          <div className="withdraw-token-item">
                            <div className="deposit-token-info">
                              <img
                                src={tokendict[selectedVault?.quoteAsset]?.image}
                                className="withdraw-token-icon"
                              />
                              <span className="token-symbol">
                                {tokendict[selectedVault?.quoteAsset]?.ticker}
                              </span>
                            </div>
                            <span className="token-amount">
                              <span className="deposit-token-amount-before">
                                {formatDisplayValue(BigInt(selectedVault?.quoteBalance * selectedVault?.userShares / selectedVault?.totalShares), Number(tokendict[selectedVault?.quoteAsset]?.decimals || 18))}
                              </span>
                              {vaultDepositAmounts.quote > 0n && (
                                <>
                                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-arrow-right-icon lucide-arrow-right" style={{ margin: '0 4px', opacity: 0.7 }}>
                                    <path d="M5 12h14" />
                                    <path d="m12 5 7 7-7 7" />
                                  </svg>
                                  {formatDisplayValue(BigInt(selectedVault?.quoteBalance * selectedVault?.userShares / selectedVault?.totalShares) + vaultDepositAmounts.quote, Number(tokendict[selectedVault?.quoteAsset]?.decimals || 18))}
                                </>
                              )}
                            </span>
                          </div>
                          <div className="withdraw-token-item">
                            <div className="deposit-token-info">
                              <img
                                src={tokendict[selectedVault?.baseAsset]?.image}
                                className="withdraw-token-icon"
                              />
                              <span className="token-symbol">
                                {tokendict[selectedVault?.baseAsset]?.ticker}
                              </span>
                            </div>
                            <span className="token-amount">
                              <span className="deposit-token-amount-before">
                                {formatDisplayValue(BigInt(selectedVault?.baseBalance * selectedVault?.userShares / selectedVault?.totalShares), Number(tokendict[selectedVault?.baseAsset]?.decimals || 18))}
                              </span>
                              {vaultDepositAmounts.base > 0n && (
                                <>
                                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-arrow-right-icon lucide-arrow-right" style={{ margin: '0 4px', opacity: 0.7 }}>
                                    <path d="M5 12h14" />
                                    <path d="m12 5 7 7-7 7" />
                                  </svg>
                                  {formatDisplayValue(BigInt(selectedVault?.baseBalance * selectedVault?.userShares / selectedVault?.totalShares) + vaultDepositAmounts.base, Number(tokendict[selectedVault?.baseAsset]?.decimals || 18))}
                                </>
                              )}
                            </span>
                          </div>
                        </div>
                      </div>
                    )}

                    <div className="deposit-summary">
                      <div className="deposit-summary-row">
                        <span className="preview-title">Share of vault:</span>
                        <span className="token-amount">
                          <span className="deposit-token-amount-before">
                            {formatDisplayValue(Number(selectedVault?.userShares) / Number(selectedVault?.totalShares), -2)}%
                          </span>
                          {vaultDepositAmounts.shares > 0n && (
                            <>
                              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-arrow-right-icon lucide-arrow-right" style={{ margin: '0 4px', opacity: 0.7 }}>
                                <path d="M5 12h14" />
                                <path d="m12 5 7 7-7 7" />
                              </svg>
                              {formatDisplayValue((Number(selectedVault?.userShares) + Number(vaultDepositAmounts?.shares)) / (Number(selectedVault?.totalShares) + Number(vaultDepositAmounts?.shares)), -2)}%
                            </>
                          )}
                        </span>
                      </div>
                    </div>
                  </div>
                )}

                {depositVaultStep !== 'idle' && (
                  <div className="create-vault-progress-container">
                    <div className="create-vault-progress-steps">
                      {/* Step 1: Validating */}
                      <div className={`create-vault-progress-step ${depositVaultStep === 'validating' ? 'active' :
                        ['approve-quote', 'approve-base', 'depositing', 'success'].includes(depositVaultStep) ? 'completed' : ''
                        }`}>
                        <div className="step-progress-indicator">
                          {['approve-quote', 'approve-base', 'depositing', 'success'].includes(depositVaultStep) ? (
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                              <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <span>1</span>
                          )}
                        </div>
                        <div className="step-progress-content">
                          <div className="step-progress-title">Validating</div>
                          <div className="step-progress-description">Checking balances and amounts</div>
                        </div>
                      </div>

                      {selectedVault?.quoteAsset && selectedVault.quoteAsset.toLowerCase() !== eth.toLowerCase() && vaultDepositAmounts.quote > 0n && (
                        <div className={`create-vault-progress-step ${depositVaultStep === 'approve-quote' ? 'active' :
                          ['approve-base', 'depositing', 'success'].includes(depositVaultStep) ? 'completed' : ''
                          }`}>
                          <div className="step-progress-indicator">
                            {['approve-base', 'depositing', 'success'].includes(depositVaultStep) ? (
                              <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                              </svg>
                            ) : (
                              <span>2</span>
                            )}
                          </div>
                          <div className="step-progress-content">
                            <div className="step-progress-title">
                              Approve {tokendict[selectedVault.quoteAsset]?.ticker || 'Quote Token'}
                            </div>
                            <div className="step-progress-description">Grant vault contract permission</div>
                          </div>
                        </div>
                      )}

                      {selectedVault?.baseAsset && selectedVault.baseAsset.toLowerCase() !== eth.toLowerCase() && vaultDepositAmounts.base > 0n && (
                        <div className={`create-vault-progress-step ${depositVaultStep === 'approve-base' ? 'active' :
                          ['depositing', 'success'].includes(depositVaultStep) ? 'completed' : ''
                          }`}>
                          <div className="step-progress-indicator">
                            {['depositing', 'success'].includes(depositVaultStep) ? (
                              <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                              </svg>
                            ) : (
                              <span>
                                {selectedVault.quoteAsset.toLowerCase() !== eth.toLowerCase() && vaultDepositAmounts.quote > 0n ? '3' : '2'}
                              </span>
                            )}
                          </div>
                          <div className="step-progress-content">
                            <div className="step-progress-title">
                              Approve {tokendict[selectedVault.baseAsset]?.ticker || 'Base Token'}
                            </div>
                            <div className="step-progress-description">Grant vault contract permission</div>
                          </div>
                        </div>
                      )}

                      <div className={`create-vault-progress-step ${depositVaultStep === 'depositing' ? 'active' :
                        depositVaultStep === 'success' ? 'completed' : ''
                        }`}>
                        <div className="step-progress-indicator">
                          {depositVaultStep === 'success' ? (
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                              <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <span>
                              {(() => {
                                let stepNum = 2;
                                if (selectedVault?.quoteAsset?.toLowerCase() !== eth.toLowerCase() && vaultDepositAmounts.quote > 0n) stepNum++;
                                if (selectedVault?.baseAsset?.toLowerCase() !== eth.toLowerCase() && vaultDepositAmounts.base > 0n) stepNum++;
                                return stepNum;
                              })()}
                            </span>
                          )}
                        </div>
                        <div className="step-progress-content">
                          <div className="step-progress-title">Depositing</div>
                          <div className="step-progress-description">Sending tokens to vault</div>
                        </div>
                      </div>
                    </div>

                  </div>
                )}
              </div>

              <div className="modal-footer">
                <button
                  className={`vault-confirm-button ${(depositVaultStep === 'idle' && (!isVaultDepositEnabled() || isVaultDepositSigning)) ? 'disabled' : ''
                    } ${depositVaultStep === 'success' ? 'success' : ''}`}
                  disabled={(!isVaultDepositEnabled() || isVaultDepositSigning || depositVaultStep === 'success')}
                  onClick={handleVaultDeposit}
                >
                  {depositVaultStep === 'success' ? (
                    <div className="button-content">
                      <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                      </svg>
                      Deposit Complete!
                    </div>
                  ) : depositVaultStep !== 'idle' ? (
                    <div className="button-content">
                      <div className="loading-spinner" />

                    </div>
                  ) : (
                    getVaultDepositButtonText()
                  )}
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 23 ? (
          <div className="modal-overlay">
            <div className="modal-content vault-action-modal" ref={popupref}>
              <div className="modal-header">
                <h2>Withdraw from {selectedVault?.name}</h2>
                <button
                  className="modal-close"
                  onClick={() => {
                    setpopup(0);
                    setselectedVault(null);
                    setWithdrawPercentage('');
                    setWithdrawExceedsBalance(false);
                    setWithdrawPreview(null);
                    setWithdrawVaultStep('idle');
                    setWithdrawVaultError('');
                  }}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div className="modal-body">
                {withdrawVaultStep === 'idle' && (
                  <div className="vault-withdraw-form">
                    <div className="withdraw-section">
                      <div className="withdraw-amount-section">
                        <div className="withdraw-percentage-input-container">
                          <div className="withdraw-percentage-display">
                            <input
                              type="text"
                              inputMode="numeric"
                              placeholder="0"
                              value={withdrawPercentage}
                              onChange={(e) => handleWithdrawPercentageChange(e.target.value.replace(/[^\d]/g, ''))}
                              size={Math.max((withdrawPercentage || '0').length, 1)}
                              style={{ width: `${Math.max((withdrawPercentage || '0').length, 1)}ch` }}
                              className="withdraw-percentage-input"
                            />
                            <span style={{ color: `${withdrawPercentage ? '#FFF' : '#ededf571'}` }} className="withdraw-percentage-symbol">%</span>
                          </div>
                        </div>
                        <div className="percentage-buttons">
                          <button
                            className={`percentage-btn ${withdrawPercentage === '25' ? 'active' : ''}`}
                            onClick={() => handleWithdrawPercentageChange('25')}
                          >
                            25%
                          </button>
                          <button
                            className={`percentage-btn ${withdrawPercentage === '50' ? 'active' : ''}`}
                            onClick={() => handleWithdrawPercentageChange('50')}
                          >
                            50%
                          </button>
                          <button
                            className={`percentage-btn ${withdrawPercentage === '75' ? 'active' : ''}`}
                            onClick={() => handleWithdrawPercentageChange('75')}
                          >
                            75%
                          </button>
                          <button
                            className={`percentage-btn ${withdrawPercentage === '100' ? 'active' : ''}`}
                            onClick={() => handleWithdrawPercentageChange('100')}
                          >
                            Max
                          </button>
                        </div>
                      </div>
                      <div className="withdraw-preview">
                        <div className="preview-title">Your position:</div>
                        <div className="withdraw-token-preview">
                          <div className="withdraw-token-item">
                            <div className="deposit-token-info">
                              <img
                                src={tokendict[selectedVault?.quoteAsset]?.image}
                                className="withdraw-token-icon"
                              />
                              <span className="token-symbol">
                                {tokendict[selectedVault?.quoteAsset]?.ticker}
                              </span>
                            </div>
                            <span className="token-amount">
                              <span className="deposit-token-amount-before">
                                {formatDisplayValue(BigInt(selectedVault?.quoteBalance * selectedVault?.userShares / selectedVault?.totalShares), Number(tokendict[selectedVault?.quoteAsset]?.decimals || 18))}
                              </span>
                              {withdrawPreview?.amountQuote != undefined && (
                                <>
                                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-arrow-right-icon lucide-arrow-right" style={{ margin: '0 4px', opacity: 0.7 }}>
                                    <path d="M5 12h14" />
                                    <path d="m12 5 7 7-7 7" />
                                  </svg>
                                  {formatDisplayValue(BigInt(selectedVault?.quoteBalance * selectedVault?.userShares / selectedVault?.totalShares) - withdrawPreview?.amountQuote, Number(tokendict[selectedVault?.quoteAsset]?.decimals || 18))}
                                </>
                              )}
                            </span>
                          </div>
                          <div className="withdraw-token-item">
                            <div className="deposit-token-info">
                              <img
                                src={tokendict[selectedVault?.baseAsset]?.image}
                                className="withdraw-token-icon"
                              />
                              <span className="token-symbol">
                                {tokendict[selectedVault?.baseAsset]?.ticker}
                              </span>
                            </div>
                            <span className="token-amount">
                              <span className="deposit-token-amount-before">
                                {formatDisplayValue(BigInt(selectedVault?.baseBalance * selectedVault?.userShares / selectedVault?.totalShares), Number(tokendict[selectedVault?.baseAsset]?.decimals || 18))}
                              </span>
                              {withdrawPreview?.amountBase != undefined && (
                                <>
                                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-arrow-right-icon lucide-arrow-right" style={{ margin: '0 4px', opacity: 0.7 }}>
                                    <path d="M5 12h14" />
                                    <path d="m12 5 7 7-7 7" />
                                  </svg>
                                  {formatDisplayValue(BigInt(selectedVault?.baseBalance * selectedVault?.userShares / selectedVault?.totalShares) - withdrawPreview?.amountBase, Number(tokendict[selectedVault?.baseAsset]?.decimals || 18))}
                                </>
                              )}
                            </span>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                {withdrawVaultStep !== 'idle' && (
                  <div className="create-vault-progress-container">
                    <div className="create-vault-progress-steps">
                      {/* Step 1: Validating */}
                      <div className={`create-vault-progress-step ${withdrawVaultStep === 'validating' ? 'active' :
                        ['withdrawing', 'success'].includes(withdrawVaultStep) ? 'completed' : ''
                        }`}>
                        <div className="step-progress-indicator">
                          {['withdrawing', 'success'].includes(withdrawVaultStep) ? (
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                              <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <span>1</span>
                          )}
                        </div>
                        <div className="step-progress-content">
                          <div className="step-progress-title">Validating</div>
                          <div className="step-progress-description">Checking withdrawal amount</div>
                        </div>
                      </div>

                      <div className={`create-vault-progress-step ${withdrawVaultStep === 'withdrawing' ? 'active' :
                        withdrawVaultStep === 'success' ? 'completed' : ''
                        }`}>
                        <div className="step-progress-indicator">
                          {withdrawVaultStep === 'success' ? (
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                              <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <span>2</span>
                          )}
                        </div>
                        <div className="step-progress-content">
                          <div className="step-progress-title">Withdrawing</div>
                          <div className="step-progress-description">Processing withdrawal from vault</div>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
              </div>

              <div className="modal-footer">
                <button
                  className={`vault-confirm-button withdraw ${(withdrawVaultStep === 'idle' && (withdrawShares == '' || parseFloat(withdrawShares) == 0 ||
                    withdrawExceedsBalance || !withdrawPreview || isVaultWithdrawSigning)) ? 'disabled' : ''
                    } ${withdrawVaultStep === 'success' ? 'success' : ''}`}
                  disabled={withdrawVaultStep == 'success' || (withdrawShares == '' || parseFloat(withdrawShares) == 0 ||
                    withdrawExceedsBalance || !withdrawPreview || isVaultWithdrawSigning)}
                  onClick={handleVaultWithdraw}
                >
                  {withdrawVaultStep === 'success' ? (
                    <div className="button-content">
                      <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                      </svg>
                      Withdrawal Complete!
                    </div>
                  ) : withdrawVaultStep !== 'idle' ? (
                    <div className="button-content">
                      <div className="loading-spinner" />
                    </div>
                  ) : (
                    getWithdrawButtonText()
                  )}
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 24 ? (
          <div className="explorer-filters-popup" ref={popupref}>
            <div className="explorer-filters-header">
              <h2 className="filters-title">Filters</h2>
              <button className="filters-close-button" onClick={() => setpopup(0)}>
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>
            </div>
            <div className="status-tabs">
              <button
                className={`status-tab ${explorerFiltersActiveTab === 'new' ? 'active' : ''}`}
                onClick={() => handleExplorerTabSwitch('new')}
              >
                New Pairs
              </button>
              <button
                className={`status-tab ${explorerFiltersActiveTab === 'graduating' ? 'active' : ''}`}
                onClick={() => handleExplorerTabSwitch('graduating')}
              >
                Graduating
              </button>
              <button
                className={`status-tab ${explorerFiltersActiveTab === 'graduated' ? 'active' : ''}`}
                onClick={() => handleExplorerTabSwitch('graduated')}
              >
                Graduated
              </button>
              <button className="explorer-revert-button" onClick={handleExplorerFiltersReset}>
                <img className="filters-reset-icon" src={reset} />
              </button>
            </div>
            <div className="protocols-section">
              <span className="keyword-label">Protocols</span>
              <div className="protocols-content">
                {/* <div className="protocol-crystal-container">
                  <img className="protocol-crystal" src={crystal} />
                  <span className="protocol-crystal">crystal.fun</span>
                </div> */}
                <div className="protocol-nadfun-container">
                  <svg width="15" height="15" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                      <linearGradient id="nadfun" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" stopColor="#7C55FF" stopOpacity="1" />
                        <stop offset="100%" stopColor="#AD5FFB" stopOpacity="1" />
                      </linearGradient>
                    </defs>
                    <path fill="url(#nadfun)" d="m29.202 10.664-4.655-3.206-3.206-4.653A6.48 6.48 0 0 0 16.004 0a6.48 6.48 0 0 0-5.337 2.805L7.46 7.458l-4.654 3.206a6.474 6.474 0 0 0 0 10.672l4.654 3.206 3.207 4.653A6.48 6.48 0 0 0 16.004 32a6.5 6.5 0 0 0 5.337-2.805l3.177-4.616 4.684-3.236A6.49 6.49 0 0 0 32 16.007a6.47 6.47 0 0 0-2.806-5.335zm-6.377 5.47c-.467 1.009-1.655.838-2.605 1.06-2.264.528-2.502 6.813-3.05 8.35-.424 1.484-1.916 1.269-2.272 0-.631-1.53-.794-6.961-2.212-7.993-.743-.542-2.502-.267-3.177-.95-.668-.675-.698-1.729-.023-2.412l5.3-5.298a1.734 1.734 0 0 1 2.45 0l5.3 5.298c.505.505.586 1.306.297 1.937z" />
                  </svg>
                  <span className="protocol-nadfun">nad.fun</span>
                </div>
                <div className="protocol-printr-container">
                  <img className="protocol-printr" src={printr} />
                  <span className="protocol-printr-text">Printr</span>
                </div>
                <div className="protocol-flapsh-container">
                  <img className="protocol-flapsh" src={flapsh} />
                  <span className="protocol-flapsh-text">Flap</span>
                </div>
              </div>
            </div>
            <div className="keywords-section">
              <div className="keyword-group">
                <div className="keyword-label">Search Keywords</div>
                <input
                  type="text"
                  placeholder="keyword1, keyword2..."
                  value={explorerFilters[explorerFiltersActiveTab]?.searchKeywords || ''}
                  onChange={(e) => handleExplorerFilterInputChange('searchKeywords', e.target.value)}
                  className="keyword-input"
                />
              </div>
              <div className="keyword-group">
                <div className="keyword-label">Exclude Keywords</div>
                <input
                  type="text"
                  placeholder="keyword1, keyword2..."
                  value={explorerFilters[explorerFiltersActiveTab]?.excludeKeywords || ''}
                  onChange={(e) => handleExplorerFilterInputChange('excludeKeywords', e.target.value)}
                  className="keyword-input"
                />
              </div>
            </div>

            <div className="section-tabs">
              <button
                className={`section-tab ${explorerFiltersActiveSection === 'audit' ? 'active' : ''}`}
                onClick={() => {
                  setExplorerFiltersActiveSection('audit')
                  localStorage.setItem('crystal_explorer_active_section', 'audit');
                }}
              >
                Audit
              </button>
              <button
                className={`section-tab ${explorerFiltersActiveSection === 'metrics' ? 'active' : ''}`}
                onClick={() => {
                  setExplorerFiltersActiveSection('metrics')
                  localStorage.setItem('crystal_explorer_active_section', 'metrics');
                }}
              >
                Metrics
              </button>
              <button
                className={`section-tab ${explorerFiltersActiveSection === 'socials' ? 'active' : ''}`}
                onClick={() => {
                  setExplorerFiltersActiveSection('socials')
                  localStorage.setItem('crystal_explorer_active_section', 'socials');
                }}
              >
                Socials
              </button>
            </div>

            <div className="filters-content">
              {explorerFiltersActiveSection === 'audit' && (
                <div className="audit-filters">
                  <div className="filter-row">
                    <span className="filter-label">Age (hours)</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.ageMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('ageMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.ageMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('ageMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Holders</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.holdersMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('holdersMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.holdersMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('holdersMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Pro Traders</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.proTradersMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('proTradersMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.proTradersMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('proTradersMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>


                  <div className="filter-row">
                    <span className="filter-label">Top 10 Holders %</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.top10HoldingMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('top10HoldingMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.top10HoldingMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('top10HoldingMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Dev Holding %</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.devHoldingMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('devHoldingMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.devHoldingMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('devHoldingMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Snipers %</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.sniperHoldingMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('sniperHoldingMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.sniperHoldingMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('sniperHoldingMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>



                  <div className="filter-row">
                    <span className="filter-label">Insider Holding %</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.insiderHoldingMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('insiderHoldingMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.insiderHoldingMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('insiderHoldingMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>
                </div>
              )}

              {explorerFiltersActiveSection === 'metrics' && (
                <div className="metrics-filters">
                  <div className="filter-row">
                    <span className="filter-label">Market Cap</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.marketCapMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('marketCapMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.marketCapMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('marketCapMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Volume 24h</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.volume24hMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('volume24hMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.volume24hMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('volume24hMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Global Fees Paid</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.globalFeesMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('globalFeesMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.globalFeesMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('globalFeesMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Buy Transactions</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.buyTransactionsMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('buyTransactionsMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.buyTransactionsMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('buyTransactionsMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Sell Transactions</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.sellTransactionsMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('sellTransactionsMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.sellTransactionsMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('sellTransactionsMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Price</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.priceMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('priceMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.priceMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('priceMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>
                </div>
              )}

              {explorerFiltersActiveSection === 'socials' && (
                <div className="socials-filters">
                  <div className="social-checkboxes">
                    <div className="checkbox-row">
                      <input
                        type="checkbox"
                        id="hasWebsite"
                        checked={explorerFilters[explorerFiltersActiveTab]?.hasWebsite || false}
                        onChange={(e) => handleExplorerFilterInputChange('hasWebsite', e.target.checked)}
                        className="filter-checkbox"
                      />
                      <label htmlFor="hasWebsite" className="checkbox-label">Has Website</label>
                    </div>

                    <div className="checkbox-row">
                      <input
                        type="checkbox"
                        id="hasTwitter"
                        checked={explorerFilters[explorerFiltersActiveTab]?.hasTwitter || false}
                        onChange={(e) => handleExplorerFilterInputChange('hasTwitter', e.target.checked)}
                        className="filter-checkbox"
                      />
                      <label htmlFor="hasTwitter" className="checkbox-label">Has Twitter</label>
                    </div>

                    <div className="checkbox-row">
                      <input
                        type="checkbox"
                        id="hasTelegram"
                        checked={explorerFilters[explorerFiltersActiveTab]?.hasTelegram || false}
                        onChange={(e) => handleExplorerFilterInputChange('hasTelegram', e.target.checked)}
                        className="filter-checkbox"
                      />
                      <label htmlFor="hasTelegram" className="checkbox-label">Has Telegram</label>
                    </div>
                  </div>
                </div>
              )}
            </div>

            <div className="filters-actions">
              <div className="action-buttons-left">
                <button className="import-button" onClick={handleExplorerFiltersImport}>
                  Import
                </button>
                <button className="export-button" onClick={handleExplorerFiltersExport}>
                  Export
                </button>
              </div>
              <div className="action-buttons-right">
                <button className="apply-button" onClick={handleExplorerFiltersApply}>
                  Apply All
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 25 ? ( // deposit popup
          <div ref={popupref} className="send-popup-container">
            <div className="send-popup-background">
              <div className={`sendbg ${connected && sendAmountIn > walletTokenBalances[scaAddress]?.[sendTokenIn] && !txPending.current ? 'exceed-balance' : ''}`}>

                <div className="sendbutton1container">
                  <div className="send-Send">{t('deposit')}</div>
                  <button
                    className="send-button1"
                    onClick={() => {
                      setpopup(26);
                    }}
                  >
                    <img className="send-button1pic" src={tokendict[sendTokenIn].image} />
                    <span>{tokendict[sendTokenIn].ticker || '?'}</span>
                  </button>

                </div>
                <div className="sendinputcontainer">
                  <input
                    inputMode="decimal"
                    className={`send-input ${connected && sendAmountIn > walletTokenBalances[scaAddress]?.[sendTokenIn] && !txPending.current ? 'exceed-balance' : ''}`}
                    onCompositionStart={() => {
                      setIsComposing(true);
                    }}
                    onCompositionEnd={(
                      e: React.CompositionEvent<HTMLInputElement>,
                    ) => {
                      setIsComposing(false);
                      if (/^\$?\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                        if (displayMode == 'usd') {
                          if (e.currentTarget.value == '$') {
                            setSendUsdValue('');
                            setSendInputAmount('');
                            setSendAmountIn(BigInt(0));
                          } else {
                            setSendUsdValue(`$${e.currentTarget.value.replace(/^\$/, '')}`);
                            const calculatedAmount = calculateTokenAmount(
                              e.currentTarget.value.replace(/^\$/, ''),
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            );
                            setSendAmountIn(calculatedAmount);
                            setSendInputAmount(
                              customRound(
                                Number(calculatedAmount) / 10 ** Number(tokendict[sendTokenIn].decimals),
                                3,
                              ).toString()
                            );
                          }
                        } else {
                          const inputValue = BigInt(
                            Math.round((parseFloat(e.currentTarget.value || '0') || 0) * 10 ** Number(tokendict[sendTokenIn].decimals))
                          );
                          setSendAmountIn(inputValue);
                          setSendInputAmount(e.currentTarget.value);
                          setSendUsdValue(
                            `$${calculateUSDValue(
                              inputValue,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            ).toFixed(2)}`
                          );
                        }
                      }
                    }}
                    onChange={(e) => {
                      if (isComposing) {
                        setSendInputAmount(e.target.value);
                        return;
                      }
                      if (/^\$?\d*\.?\d{0,18}$/.test(e.target.value)) {
                        if (displayMode == 'usd') {
                          if (e.target.value == '$') {
                            setSendUsdValue('');
                            setSendInputAmount('');
                            setSendAmountIn(BigInt(0));
                          } else {
                            setSendUsdValue(`$${e.target.value.replace(/^\$/, '')}`);
                            const calculatedAmount = calculateTokenAmount(
                              e.target.value.replace(/^\$/, ''),
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            );
                            setSendAmountIn(calculatedAmount);
                            setSendInputAmount(
                              customRound(
                                Number(calculatedAmount) / 10 ** Number(tokendict[sendTokenIn].decimals),
                                3,
                              ).toString()
                            );
                          }
                        } else {
                          const inputValue = BigInt(
                            Math.round((parseFloat(e.target.value || '0') || 0) * 10 ** Number(tokendict[sendTokenIn].decimals))
                          );
                          setSendAmountIn(inputValue);
                          setSendInputAmount(e.target.value);
                          setSendUsdValue(
                            `$${calculateUSDValue(
                              inputValue,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            ).toFixed(2)}`
                          );
                        }
                      }
                    }}
                    placeholder={displayMode == 'usd' ? '$0.00' : '0.00'}
                    value={displayMode == 'usd' ? sendUsdValue : sendInputAmount}
                    autoFocus={!(windowWidth <= 1020)}
                  />
                </div>
                <div className="send-balance-wrapper">
                  <div className="send-balance-max-container">
                    <div className="send-balance1">
                      <img src={walleticon} className="send-balance-wallet-icon" />{' '}
                      {formatDisplayValue(walletTokenBalances[scaAddress]?.[sendTokenIn] || 0, Number(tokendict[sendTokenIn].decimals))}
                    </div>
                    <div
                      className="send-max-button"
                      onClick={() => {
                        if (walletTokenBalances[scaAddress]?.[sendTokenIn] != BigInt(0)) {
                          let amount =
                            (sendTokenIn == eth && !client)
                              ? walletTokenBalances[scaAddress]?.[sendTokenIn] - settings.chainConfig[activechain].gasamount > BigInt(0)
                                ? walletTokenBalances[scaAddress]?.[sendTokenIn] - settings.chainConfig[activechain].gasamount
                                : BigInt(0)
                              : walletTokenBalances[scaAddress]?.[sendTokenIn];
                          setSendAmountIn(amount);
                          setSendInputAmount(
                            customRound(Number(amount) / 10 ** Number(tokendict[sendTokenIn].decimals), 3).toString()
                          );
                          setSendUsdValue(
                            `$${calculateUSDValue(
                              amount,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            ).toFixed(2)}`
                          );
                        }
                      }}
                    >
                      {t('max')}
                    </div>
                  </div>
                  <div
                    className="send-usd-switch-wrapper"
                    onClick={() => {
                      if (displayMode === 'usd') {
                        setDisplayMode('token');
                        if (parseFloat(sendUsdValue.replace(/^\$|,/g, '')) == 0) {
                          setSendInputAmount('');
                        }
                      } else {
                        setDisplayMode('usd');
                        if (parseFloat(sendInputAmount) == 0) {
                          setSendUsdValue('');
                        }
                      }
                    }}
                  >
                    <div className="send-usd-value">
                      {displayMode === 'usd'
                        ? `${customRound(Number(sendAmountIn) / 10 ** Number(tokendict[sendTokenIn].decimals), 3)} ${tokendict[sendTokenIn].ticker}`
                        : sendAmountIn === BigInt(0)
                          ? '$0.00'
                          : formatUSDDisplay(
                            calculateUSDValue(
                              sendAmountIn,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            )
                          )}
                    </div>
                    <img src={sendSwitch} className="send-arrow" />
                  </div>
                </div>
              </div>
              <div className="sendaddressbg">
                <div className="send-To">{t('to')}</div>
                <div className="send-address-input-container">
                  <input
                    className="send-output"
                    onChange={(e) => {
                      if (e.target.value === '' || /^(0x[0-9a-fA-F]{0,40}|0)$/.test(e.target.value)) {
                        setrecipient(e.target.value);
                      }
                    }}
                    value={oneCTDepositAddress}
                    placeholder={t('enterWalletAddress')}
                    disabled
                  />
                  <button
                    className="address-paste-button"
                    onClick={async () => {
                      try {
                        const text = await navigator.clipboard.readText();
                        if (/^(0x[0-9a-fA-F]{40})$/.test(text)) {
                          setrecipient(text);
                        }
                      } catch (err) {
                      }
                    }}
                  >
                    <svg
                      width="16"
                      height="16"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    >
                      <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                      <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                    </svg>
                  </button>
                </div>
              </div>
              <button
                className={`send-swap-button ${isSigning ? 'signing' : ''}`}
                onClick={async () => {
                  if (
                    connected &&
                    userchain === activechain
                  ) {
                    let hash: any;
                    setIsSigning(true)
                    if (client) {
                      txPending.current = true
                    }
                    try {
                      if (sendTokenIn == eth) {
                        hash = await sendUserOperationAsync({
                          uo: sendeth(
                            oneCTDepositAddress as `0x${string}`,
                            sendAmountIn,
                          )
                        }, 0n, 0n, true, '', 0);
                        if (!client) {
                          txPending.current = true
                        }
                        newTxPopup(
                          (hash),
                          'send',
                          eth,
                          '',
                          customRound(
                            Number(sendAmountIn) / 10 ** Number(tokendict[eth].decimals),
                            3,
                          ),
                          0,
                          '',
                          oneCTDepositAddress,
                        );
                      } else {
                        hash = await sendUserOperationAsync({
                          uo: sendtokens(
                            sendTokenIn as `0x${string}`,
                            oneCTDepositAddress as `0x${string}`,
                            sendAmountIn,
                          )
                        }, 0n, 0n, true, '', 0);
                        if (!client) {
                          txPending.current = true
                        }
                        newTxPopup(
                          (hash),
                          'send',
                          sendTokenIn,
                          '',
                          customRound(
                            Number(sendAmountIn) /
                            10 ** Number(tokendict[sendTokenIn].decimals),
                            3,
                          ),
                          0,
                          '',
                          oneCTDepositAddress,
                        );
                      }
                      setpopup(4)
                      setSendUsdValue('')
                      setSendInputAmount('');
                      setSendAmountIn(BigInt(0));
                      setSendPopupButton(0);
                      setSendPopupButtonDisabled(true);
                      setIsSigning(false)
                      await refetch()
                      txPending.current = false
                    } catch (error) {
                      if (!(error instanceof TransactionExecutionError)) {
                        newTxPopup(
                          hash,
                          "sendFailed",
                          sendTokenIn === eth ? eth : sendTokenIn,
                          "",
                          customRound(
                            Number(sendAmountIn) / 10 ** Number(tokendict[sendTokenIn === eth ? eth : sendTokenIn].decimals),
                            3,
                          ),
                          0,
                          "",
                          oneCTDepositAddress,
                        );
                      }
                    } finally {
                      txPending.current = false
                      setIsSigning(false)
                    }
                  } else {
                    !connected
                      ? setpopup(4)
                      : handleSetChain()
                  }
                }}
                disabled={(sendAmountIn === BigInt(0) ||
                  sendAmountIn > walletTokenBalances[scaAddress]?.[sendTokenIn] ||
                  !/^(0x[0-9a-fA-F]{40})$/.test(oneCTDepositAddress)) &&
                  connected &&
                  userchain == activechain || isSigning}
              >
                {isSigning ? (
                  <div className="button-content">
                    <div className="loading-spinner" />
                    {validOneCT ? t('') : t('signTransaction')}
                  </div>
                ) : sendAmountIn === BigInt(0) ? (
                  t('enterAmount')
                ) : sendAmountIn > walletTokenBalances[scaAddress]?.[sendTokenIn] ? (
                  t('insufficient') +
                  (tokendict[sendTokenIn].ticker || '?') +
                  ' ' +
                  t('bal')
                ) : connected && userchain == activechain ? (
                  t('deposit')
                ) : connected ? (
                  `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
                ) : (
                  t('connectWallet')
                )}
              </button>
            </div>
          </div>
        ) : null}
        {popup === 26 ? (
          <div ref={popupref} className="sendselectbg">
            <div className="send-top-row">
              <input
                className="sendselect"
                onChange={(e) => {
                  settokenString(e.target.value);
                }}
                placeholder={t('searchToken')}
                autoFocus={!(windowWidth <= 1020)}
              />
              {tokenString && (
                <button
                  className="sendselect-clear visible"
                  onClick={() => {
                    settokenString('');
                    const input = document.querySelector('.sendselect') as HTMLInputElement;
                    if (input) {
                      input.value = '';
                      input.focus();
                    }
                  }}
                >
                  {t('clear')}
                </button>
              )}
              <button
                className="sendselect-back"
                onClick={() => {
                  setpopup(25);
                }}
              >
                <img src={closebutton} className="send-close-button-icon" />
              </button>
            </div>

            <ul className="sendtokenlist">
              {Object.values(tokendict)
                .filter(
                  (token) =>
                    token.ticker.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                    token.name.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                    token.address.toLowerCase().includes(tokenString.trim().toLowerCase())
                ).length === 0 ? (
                <div className="empty-token-list">
                  <div className="empty-token-list-content">
                    <svg
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="empty-token-list-icon"
                    >
                      <circle cx="11" cy="11" r="8" />
                      <path d="M21 21l-4.35-4.35" />
                    </svg>
                    <div className="empty-token-list-text">{t('noTokens')}</div>
                  </div>
                </div>
              ) : (
                Object.values(tokendict)
                  .filter(
                    (token) =>
                      token.ticker.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                      token.name.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                      token.address.toLowerCase().includes(tokenString.trim().toLowerCase())
                  )
                  .map((token) => (
                    <button
                      className="sendtokenbutton"
                      key={token.address}
                      onClick={() => {
                        setSendTokenIn(token.address);
                        setSendUsdValue('');
                        setSendInputAmount('');
                        setSendAmountIn(BigInt(0));
                        settokenString('');
                        setpopup(25);
                      }}
                    >
                      <img className="tokenlistimage" src={token.image} />
                      <div className="tokenlisttext">
                        <div className="tokenlistname">{token.ticker}</div>
                        <div className="tokenlistticker">{token.name}</div>
                      </div>
                      <div className="token-right-content">
                        <div className="tokenlistbalance">
                          {formatDisplayValue(walletTokenBalances[scaAddress]?.[token.address] ?? 0, Number(token.decimals))}
                        </div>
                        <div className="token-address-container">
                          <span className="token-address">
                            {`${token.address.slice(0, 6)}...${token.address.slice(-4)}`}
                          </span>
                          <div
                            className="copy-address-button"
                            onClick={(e) => {
                              e.stopPropagation();
                              navigator.clipboard.writeText(token.address);
                              const copyIcon =
                                e.currentTarget.querySelector('.copy-icon');
                              const checkIcon =
                                e.currentTarget.querySelector('.check-icon');
                              if (copyIcon && checkIcon) {
                                copyIcon.classList.add('hidden');
                                checkIcon.classList.add('visible');
                                setTimeout(() => {
                                  copyIcon.classList.remove('hidden');
                                  checkIcon.classList.remove('visible');
                                }, 2000);
                              }
                            }}
                          >
                            <svg
                              className="copy-icon"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                            >
                              <rect
                                x="9"
                                y="9"
                                width="13"
                                height="13"
                                rx="2"
                                ry="2"
                              ></rect>
                              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                            <svg
                              className="check-icon"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                            >
                              <circle cx="12" cy="12" r="10" />
                              <path d="M8 12l3 3 6-6" />
                            </svg>
                          </div>
                        </div>
                      </div>
                    </button>
                  ))
              )}
            </ul>
          </div>
        ) : null}
        {popup === 27 ? (
          <div ref={popupref}>
            <PNLComponent
              windowWidth={window.innerWidth}
              tokenAddress={pnlShareData?.tokenAddress || currentTokenData.address}
              userAddress={pnlShareData?.userAddress || address}
              tokenSymbol={pnlShareData?.tokenSymbol || currentTokenData.symbol}
              tokenName={pnlShareData?.tokenName || currentTokenData.name}
              monUsdPrice={monUsdPrice}
              externalUserStats={pnlShareData?.externalUserStats || memeUserStats}
              currentPrice={pnlShareData?.currentPrice || currentTokenData.price}
              refLink={refLink}
            />
          </div>
        ) : null}
        {popup === 28 ? (
          <div className="onect-trading-selection-bg">
            <div ref={popupref} className="onect-trading-selection-container">
              <div className="onect-trading-header">
                <h2 className="onect-trading-title">Choose Trading Mode</h2>
                <button
                  className="onect-trading-close-button"
                  onClick={() => setpopup(0)}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div className="onect-trading-content">
                <div className="trading-mode-options">
                  <div className="trading-mode-option selected">
                    <div className="trading-mode-icon">
                      <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                        <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
                        <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>
                        <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
                      </svg>
                    </div>
                    <div className="trading-mode-info">
                      <h3>Classic Trading</h3>
                      <p>Trade and sign transactions with your self-custodial wallet</p>
                    </div>
                  </div>

                  <div className="trading-mode-option">
                    <div className="trading-mode-icon">
                      <svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" ><path d="M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z" /></svg>
                    </div>
                    <div className="trading-mode-info">
                      <h3>One-Click Trading</h3>
                      <p>Approve transactions instantly from an embedded wallet</p>
                    </div>
                    <div className="trading-mode-status">
                      <button
                        className="enable-onect-btn"
                        onClick={async () => {
                          try {
                            setIsUsernameSigning(true);
                            let isSuccess = await createSubWallet(true);
                            if (isSuccess) {
                              setOneCTDepositAddress(isSuccess);
                              setpopup(25);
                            }
                          } catch (error) {
                            console.error('Failed to enable 1CT:', error);
                          } finally {
                            setIsUsernameSigning(false);
                          }
                        }}
                        disabled={isUsernameSigning}
                      >
                        {isUsernameSigning ? (
                          <div className="button-content">
                            <div style={{ position: 'absolute' }} className="loading-spinner" />
                            <span style={{ opacity: 0 }}>Enable 1CT</span>
                          </div>
                        ) : (
                          'Enable 1CT'
                        )}
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 29 ? (
          <div ref={popupref} className="modal-overlay">
            <div className="modal-content">
              <div className="modal-header">
                <h2>Create New Vault</h2>
                <button
                  className="modal-close"
                  onClick={() => {
                    setCreateVaultForm({
                      name: '',
                      description: '',
                      selectedMarket: '',
                      quoteAsset: '',
                      baseAsset: '',
                      amountQuote: '',
                      amountBase: '',
                      social1: '',
                      social2: '',
                      showMarketDropdown: false,
                      marketSearchTerm: ''
                    });
                    setCreateVaultStep('idle');
                    setCreateVaultError('');
                    setpopup(0);
                  }}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div
                className="modal-body"
                onClick={(e) => {
                  if (!(e.target as Element)?.closest?.('.market-selector-container')) {
                    setCreateVaultForm(prev => ({
                      ...prev,
                      showMarketDropdown: false
                    }));
                  }
                }}
              >
                {/* Show form only when not in progress */}
                {createVaultStep === 'idle' && (
                  <>
                    <div className="form-group">
                      <label>Vault Name</label>
                      <input
                        type="text"
                        value={createVaultForm.name}
                        onChange={(e) => setCreateVaultForm(prev => ({ ...prev, name: e.target.value }))}
                        className="form-input"
                        placeholder="Enter vault name"
                      />
                    </div>

                    <div className="form-group">
                      <label>Description</label>
                      <textarea
                        value={createVaultForm.description}
                        onChange={(e) => setCreateVaultForm(prev => ({ ...prev, description: e.target.value }))}
                        className="form-textarea"
                        rows={4}
                        placeholder="Describe your vault strategy"
                      />
                    </div>

                    <div className="form-group">
                      <label className="market-selector-label">Trading Market</label>
                      <div className="market-selector-container">
                        {(() => {
                          const selectedMarket = Object.values(markets).find((market) =>
                            `${market.baseAsset}${market.quoteAsset}` === createVaultForm.selectedMarket
                          );
                          return selectedMarket ? (
                            <div className="selected-token-indicator">
                              <img src={selectedMarket.image || tokendict[selectedMarket.baseAddress]?.image} alt={selectedMarket.baseAsset} className="token-icon-small" />
                              <span className="token-symbol">{selectedMarket.baseAsset}/{selectedMarket.quoteAsset}</span>
                            </div>
                          ) : null;
                        })()}
                        <div className="market-selector-input-wrapper">
                          <input
                            type="text"
                            value=""
                            onFocus={() => setCreateVaultForm(prev => ({ ...prev, showMarketDropdown: true }))}
                            className="form-input market-selector-input"
                            placeholder={createVaultForm.selectedMarket ? "" : "Select trading market..."}
                            readOnly
                          />
                          <button
                            type="button"
                            className="token-dropdown-button"
                            onClick={() => setCreateVaultForm(prev => ({ ...prev, showMarketDropdown: !prev.showMarketDropdown }))}
                          >
                            <ChevronDown size={16} />
                          </button>
                        </div>
                        {createVaultForm.showMarketDropdown && (
                          <div className="create-vault-token-dropdown">
                            <div className="create-vault-token-list">
                              {Object.values(markets).filter((market) => {
                                const searchTerm = createVaultForm.marketSearchTerm || '';
                                const marketPair = `${market.baseAsset}/${market.quoteAsset}`;
                                if (!searchTerm) return true;
                                return marketPair.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                  market.baseAsset.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                  market.quoteAsset.toLowerCase().includes(searchTerm.toLowerCase());
                              }).slice(0, 100).map((market) => {
                                const marketKey = `${market.baseAsset}${market.quoteAsset}`;
                                return (
                                  <div
                                    key={marketKey}
                                    className="create-vault-token-option"
                                    onClick={() => {
                                      setCreateVaultForm(prev => ({
                                        ...prev,
                                        selectedMarket: marketKey,
                                        quoteAsset: market.quoteAddress,
                                        baseAsset: market.baseAddress,
                                        showMarketDropdown: false,
                                        marketSearchTerm: ''
                                      }));
                                    }}
                                  >
                                    <img src={market.image || tokendict[market.baseAddress]?.image} alt={market.baseAsset} className="create-vault-token-icon" />
                                    <div className="create-vault-token-info">
                                      <div className="token-symbol">{market.baseAsset}/{market.quoteAsset}</div>
                                    </div>
                                  </div>
                                );
                              })}

                              {Object.values(markets).filter((market) => {
                                const searchTerm = createVaultForm.marketSearchTerm || '';
                                const marketPair = `${market.baseAsset}/${market.quoteAsset}`;
                                if (!searchTerm) return false;
                                return marketPair.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                  market.baseAsset.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                  market.quoteAsset.toLowerCase().includes(searchTerm.toLowerCase());
                              }).length === 0 && createVaultForm.marketSearchTerm && (
                                  <div className="no-tokens-found">No markets found</div>
                                )}
                            </div>
                          </div>
                        )}
                      </div>
                    </div>

                    <div className="form-row">
                      <div className="form-group">
                        <label>Initial Quote Amount</label>
                        <input
                          type="number"
                          value={createVaultForm.amountQuote}
                          onChange={(e) => setCreateVaultForm(prev => ({ ...prev, amountQuote: e.target.value }))}
                          className="form-input"
                          placeholder="0.0"
                        />
                        {/* {createVaultForm.quoteAsset && tokendict[createVaultForm.quoteAsset] && (
                  <small className="token-label">
                    {tokendict[createVaultForm.quoteAsset].ticker} ({tokendict[createVaultForm.quoteAsset].name})
                  </small>
                )} */}
                      </div>
                      <div className="form-group">
                        <label>Initial Base Amount</label>
                        <input
                          type="number"
                          value={createVaultForm.amountBase}
                          onChange={(e) => setCreateVaultForm(prev => ({ ...prev, amountBase: e.target.value }))}
                          className="form-input"
                          placeholder="0.0"
                        />
                        {/* {createVaultForm.baseAsset && tokendict[createVaultForm.baseAsset] && (
                  <small className="token-label">
                    {tokendict[createVaultForm.baseAsset].ticker} ({tokendict[createVaultForm.baseAsset].name})
                  </small>
                )} */}
                      </div>
                    </div>

                    <div className="form-row">
                      <div className="form-group">
                        <label>Social Link 1 (Optional)</label>
                        <input
                          type="text"
                          value={createVaultForm.social1}
                          onChange={(e) => setCreateVaultForm(prev => ({ ...prev, social1: e.target.value }))}
                          className="form-input"
                          placeholder="https://twitter.com/..."
                        />
                      </div>
                      <div className="form-group">
                        <label>Social Link 2 (Optional)</label>
                        <input
                          type="text"
                          value={createVaultForm.social2}
                          onChange={(e) => setCreateVaultForm(prev => ({ ...prev, social2: e.target.value }))}
                          className="form-input"
                          placeholder="https://telegram.me/..."
                        />
                      </div>
                    </div>
                  </>
                )}

                {createVaultStep !== 'idle' && (
                  <div className="create-vault-progress-container">
                    <div className="create-vault-progress-steps">
                      <div className={`create-vault-progress-step ${createVaultStep === 'validating' ? 'active' :
                        ['approve-quote', 'approve-base', 'creating', 'success'].includes(createVaultStep) ? 'completed' : ''
                        }`}>
                        <div className="step-progress-indicator">
                          {['approve-quote', 'approve-base', 'creating', 'success'].includes(createVaultStep) ? (
                            <svg width="14" height="14" viewBox="0 0 16 16" fill="none">
                              <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <span>1</span>
                          )}
                        </div>
                        <div className="step-progress-content">
                          <div className="step-progress-title">Validating</div>
                          <div className="step-progress-description">Checking balances and permissions</div>
                        </div>

                      </div>

                      {createVaultForm.quoteAsset && createVaultForm.quoteAsset.toLowerCase() !== eth.toLowerCase() && (
                        <div className={`create-vault-progress-step ${createVaultStep === 'approve-quote' ? 'active' :
                          ['approve-base', 'creating', 'success'].includes(createVaultStep) ? 'completed' : ''
                          }`}>
                          <div className="step-progress-indicator">
                            {['approve-base', 'creating', 'success'].includes(createVaultStep) ? (
                              <svg width="14" height="14" viewBox="0 0 16 16" fill="none">
                                <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                              </svg>
                            ) : (
                              <span>2</span>
                            )}
                          </div>
                          <div className="step-progress-content">
                            <div className="step-progress-title">
                              Approve {tokendict[createVaultForm.quoteAsset]?.ticker || 'Quote Token'}
                            </div>
                            <div className="step-progress-description">Grant vault contract permission</div>
                          </div>
                        </div>
                      )}

                      {createVaultForm.baseAsset && createVaultForm.baseAsset.toLowerCase() !== eth.toLowerCase() && (
                        <div className={`create-vault-progress-step ${createVaultStep === 'approve-base' ? 'active' :
                          ['creating', 'success'].includes(createVaultStep) ? 'completed' : ''
                          }`}>
                          <div className="step-progress-indicator">
                            {['creating', 'success'].includes(createVaultStep) ? (
                              <svg width="14" height="14" viewBox="0 0 16 16" fill="none">
                                <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                              </svg>
                            ) : (
                              <span>
                                {createVaultForm.quoteAsset.toLowerCase() !== eth.toLowerCase() ? '3' : '2'}
                              </span>
                            )}
                          </div>
                          <div className="step-progress-content">
                            <div className="step-progress-title">
                              Approve {tokendict[createVaultForm.baseAsset]?.ticker || 'Base Token'}
                            </div>
                            <div className="step-progress-description">Grant vault contract permission</div>
                          </div>
                        </div>
                      )}

                      <div className={`create-vault-progress-step ${createVaultStep === 'creating' ? 'active' :
                        createVaultStep === 'success' ? 'completed' : ''
                        }`}>
                        <div className="step-progress-indicator">
                          {createVaultStep === 'success' ? (
                            <svg width="14" height="14" viewBox="0 0 16 16" fill="none">
                              <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <span>
                              {(() => {
                                let stepNum = 2;
                                if (createVaultForm.quoteAsset.toLowerCase() !== eth.toLowerCase()) stepNum++;
                                if (createVaultForm.baseAsset.toLowerCase() !== eth.toLowerCase()) stepNum++;
                                return stepNum;
                              })()}
                            </span>
                          )}
                        </div>
                        <div className="step-progress-content">
                          <div className="step-progress-title">Creating Vault</div>
                          <div className="step-progress-description">Deploying your vault contract</div>
                        </div>
                      </div>
                    </div>

                  </div>
                )}
              </div>

              <div className="modal-footer">
                <button
                  className={`save-button ${(!createVaultForm.name || !createVaultForm.selectedMarket || !createVaultForm.amountQuote || !createVaultForm.amountBase) && createVaultStep === 'idle' ? 'disabled' : ''
                    } ${createVaultStep === 'success' ? 'success' : ''}`}
                  disabled={
                    (createVaultStep === 'success' || (!createVaultForm.name || !createVaultForm.selectedMarket || !createVaultForm.amountQuote || !createVaultForm.amountBase)) ||
                    isVaultDepositSigning
                  }
                  onClick={async () => {
                    if (!connected || !createVaultForm.name || !createVaultForm.selectedMarket ||
                      !createVaultForm.amountQuote || !createVaultForm.amountBase) {
                      return;
                    }

                    await handleSetChain();

                    try {
                      setIsVaultDepositSigning(true);
                      setCreateVaultError('');

                      // Step 1: Validating
                      setCreateVaultStep('validating');
                      await new Promise(resolve => setTimeout(resolve, 500)); // Small delay for UX

                      if (!createVaultForm.quoteAsset.startsWith('0x') || !createVaultForm.baseAsset.startsWith('0x')) {
                        throw new Error('Invalid token addresses. Please provide valid contract addresses.');
                      }

                      const quoteAssetData = Object.values(tokendict).find((t) =>
                        t.address.toLowerCase() === createVaultForm.quoteAsset.toLowerCase()
                      );
                      const baseAssetData = Object.values(tokendict).find((t) =>
                        t.address.toLowerCase() === createVaultForm.baseAsset.toLowerCase()
                      );

                      if (!quoteAssetData || !baseAssetData) {
                        throw new Error('One or both tokens not found in token dictionary. Please ensure you\'re using valid token addresses.');
                      }

                      const quoteDecimals = Number(quoteAssetData.decimals || 18);
                      const baseDecimals = Number(baseAssetData.decimals || 18);

                      const amountQuote = BigInt(Math.round(parseFloat(createVaultForm.amountQuote) * 10 ** quoteDecimals));
                      const amountBase = BigInt(Math.round(parseFloat(createVaultForm.amountBase) * 10 ** baseDecimals));

                      const quoteBalance = tokenBalances[createVaultForm.quoteAsset] || 0n;
                      const baseBalance = tokenBalances[createVaultForm.baseAsset] || 0n;

                      if (quoteBalance < amountQuote) {
                        const formatBalance = (amount: bigint, decimals: number) => {
                          const num = Number(amount) / 10 ** decimals;
                          return num.toFixed(2);
                        };
                        throw new Error(`Insufficient ${quoteAssetData.ticker} balance. Required: ${createVaultForm.amountQuote}, Available: ${formatBalance(quoteBalance, quoteDecimals)}`);
                      }

                      if (baseBalance < amountBase) {
                        const formatBalance = (amount: bigint, decimals: number) => {
                          const num = Number(amount) / 10 ** decimals;
                          return num.toFixed(2);
                        };
                        throw new Error(`Insufficient ${baseAssetData.ticker} balance. Required: ${createVaultForm.amountBase}, Available: ${formatBalance(baseBalance, baseDecimals)}`);
                      }

                      // Step 2: Approve Quote Token
                      if (createVaultForm.quoteAsset.toLowerCase() !== eth.toLowerCase()) {
                        setCreateVaultStep('approve-quote');
                        const approveQuoteUo = {
                          target: createVaultForm.quoteAsset,
                          data: encodeFunctionData({
                            abi: [{
                              inputs: [
                                { name: "spender", type: "address" },
                                { name: "amount", type: "uint256" }
                              ],
                              name: "approve",
                              outputs: [{ name: "", type: "bool" }],
                              stateMutability: "nonpayable",
                              type: "function",
                            }],
                            functionName: "approve",
                            args: [crystalVaults, amountQuote],
                          }),
                          value: 0n,
                        };
                        await sendUserOperationAsync({ uo: approveQuoteUo });
                      }

                      // Step 3: Approve Base Token
                      if (createVaultForm.baseAsset.toLowerCase() !== eth.toLowerCase()) {
                        setCreateVaultStep('approve-base');
                        const approveBaseUo = {
                          target: createVaultForm.baseAsset,
                          data: encodeFunctionData({
                            abi: [{
                              inputs: [
                                { name: "spender", type: "address" },
                                { name: "amount", type: "uint256" }
                              ],
                              name: "approve",
                              outputs: [{ name: "", type: "bool" }],
                              stateMutability: "nonpayable",
                              type: "function",
                            }],
                            functionName: "approve",
                            args: [crystalVaults, amountBase],
                          }),
                          value: 0n,
                        };
                        await sendUserOperationAsync({ uo: approveBaseUo });
                      }

                      // Step 4: Creating Vault
                      setCreateVaultStep('creating');

                      const ethValue =
                        createVaultForm.quoteAsset.toLowerCase() === eth.toLowerCase() ? amountQuote :
                          createVaultForm.baseAsset.toLowerCase() === eth.toLowerCase() ? amountBase : 0n;

                      const deployUo = {
                        target: crystalVaults,
                        data: encodeFunctionData({
                          abi: CrystalVaultsAbi,
                          functionName: "deploy",
                          args: [
                            createVaultForm.quoteAsset as `0x${string}`,
                            createVaultForm.baseAsset as `0x${string}`,
                            amountQuote,
                            amountBase,
                            0n,
                            0n,
                            true,
                            {
                              name: createVaultForm.name || 'Unnamed Vault',
                              description: createVaultForm.description || 'No description provided',
                              social1: createVaultForm.social1 || '',
                              social2: createVaultForm.social2 || '',
                              social3: createVaultForm.social2 || ''
                            },
                          ],
                        }),
                        value: ethValue,
                      };

                      await sendUserOperationAsync({ uo: deployUo });

                      // Step 5: Success
                      setCreateVaultStep('success');

                      // Wait a moment to show success state
                      setTimeout(() => {
                        setCreateVaultForm({
                          name: '',
                          description: '',
                          selectedMarket: '',
                          quoteAsset: '',
                          baseAsset: '',
                          amountQuote: '',
                          amountBase: '',
                          social1: '',
                          social2: '',
                          showMarketDropdown: false,
                          marketSearchTerm: ''
                        });
                        setCreateVaultStep('idle');
                        setCreateVaultError('');
                        setpopup(0);
                        refetch?.();
                      }, 2000);

                    } catch (e: any) {
                      console.error('Vault creation error:', e);
                      setCreateVaultError(e?.message || 'An error occurred while creating the vault. Please try again.');
                      setCreateVaultStep('idle');
                    } finally {
                      setIsVaultDepositSigning(false);
                    }
                  }}
                >
                  {createVaultStep === 'success' ? (
                    <div className="button-content">
                      <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                      </svg>
                      Vault Created!
                    </div>
                  ) : createVaultStep !== 'idle' ? (
                    <div className="button-content">
                      <div className="loading-spinner" />
                    </div>
                  ) : (
                    'Create Vault'
                  )}
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 30 ? ( // perps-deposit-popup
          <div className="modal-overlay">
            <div className="modal-content" ref={popupref}>
              <div className="modal-header">
                <h2>Deposit</h2>
                <button
                  className="modal-close"
                  onClick={() => {
                    setpopup(0);
                    setPerpsDepositAmount('');
                  }}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div className="modal-body">
                <div className="perps-deposit-form">
                  <div className="form-group">
                    <div className="perps-deposit-input-wrapper">
                      <div className="perps-deposit-balance">
                        Converting
                        <div className="">
                          <span>Balance: </span>
                          <span>{(Number(arbUSDCBalance) / 1e6).toFixed(2)}</span>
                          <button
                            className="perps-max-button"
                            onClick={() => {
                              const usdcBalance = arbUSDCBalance || 0n;
                              const maxAmount = (Number(usdcBalance) / 1e6).toFixed(2);
                              setPerpsDepositAmount(maxAmount);
                            }}
                          >
                            Max
                          </button>
                        </div>
                      </div>
                      <div className="perps-input-bottom-row">
                        <input
                          type="text"
                          placeholder="0.00"
                          className="perps-deposit-input"
                          value={perpsDepositAmount}
                          onChange={(e) => {
                            const value = e.target.value;
                            if (/^\d*\.?\d{0,2}$/.test(value)) {
                              setPerpsDepositAmount(value);
                            }
                          }}
                        />
                        <div className="perps-deposit-token-badge">
                          <img className="perps-deposit-icon" src={iconusdc} />
                          <span>USDC</span>
                        </div>
                      </div>
                    </div>
                    <div className="perps-switch-icon" onClick={() => {
                      setpopup(31);
                      setPerpsDepositAmount('');
                    }}>
                      <img className="perps-switch-img" src={switchicon} />
                    </div>
                    <div className="perps-deposit-input-wrapper">
                      <div className="perps-deposit-balance">
                        Receiving
                        <div className="">
                          <span>Balance: </span>
                          <span>0.00</span>
                        </div>
                      </div>
                      <div className="perps-input-bottom-row">
                        <input
                          type="text"
                          placeholder="0.00"
                          className="perps-deposit-input"
                          value={perpsDepositAmount}
                          readOnly
                        />
                        <div className="perps-deposit-token-badge">
                          <img className="perps-deposit-icon" src={iconusdc} />
                          <img className="edgeX-icon" src={edgeX} />
                          <span>USDC</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div className="modal-footer">
                <button
                  className={`perps-confirm-button ${isVaultDepositSigning ? 'signing' : ''}`}
                  disabled={perpsDepositDisabled}
                  style={{
                    opacity: perpsDepositDisabled ? 0.5 : 1,
                    cursor: perpsDepositDisabled ? 'not-allowed' : 'pointer'
                  }}
                  onClick={async () => {
                    if (perpsDepositDisabled) return;

                    try {
                      setIsVaultDepositSigning(true);
                      const amount = BigInt(Math.floor(parseFloat(perpsDepositAmount) * 1e6));

                      await alchemyconfig?._internal?.wagmiConfig?.state?.connections?.entries()?.next()?.value?.[1]?.connector?.switchChain({ chainId: 42161 as any });
                      if (arbUSDCAllowance < amount) {
                        await rawSendUserOperationAsync({
                          uo: {
                            target: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831' as `0x${string}`,
                            data: encodeFunctionData({
                              abi: [{
                                inputs: [
                                  { name: "spender", type: "address" },
                                  { name: "amount", type: "uint256" },
                                ],
                                name: "approve",
                                outputs: [],
                                stateMutability: "nonpayable",
                                type: "function",
                              }],
                              functionName: "approve",
                              args: ['0x81144d6E7084928830f9694a201E8c1ce6eD0cb2', amount],
                            }),
                            value: 0n,
                          }
                        });
                      }
                      await rawSendUserOperationAsync({
                        uo: {
                          target: '0x81144d6E7084928830f9694a201E8c1ce6eD0cb2' as `0x${string}`,
                          data: encodeFunctionData({
                            abi: [{
                              inputs: [
                                { name: "token", type: "address" },
                                { name: "amount", type: "uint256" },
                                { name: "starkKey", type: "uint256" },
                                { name: "accountId", type: "uint256" },
                                { name: "exchangeData", type: "bytes" }
                              ],
                              name: "deposit",
                              outputs: [],
                              stateMutability: "nonpayable",
                              type: "function",
                            }],
                            functionName: "deposit",
                            args: ['0xaf88d065e77c8cC2239327C5EDb3A432268e5831', amount, perpsKeystore.publicKey, BigInt(perpsKeystore.accountId), '0x00'],
                          }),
                          value: 0n,
                        }
                      });
                      setPerpsDepositAmount('');
                      setpopup(0);
                    } catch (error) {
                      console.error('Perps deposit error:', error);
                    } finally {
                      handleSetChain();
                      setIsVaultDepositSigning(false);
                    }
                  }}
                >
                  {isVaultDepositSigning ? (
                    <div className="button-content">
                      <div className="loading-spinner" />
                      {validOneCT ? '' : t('signTransaction')}
                    </div>
                  ) : !perpsDepositAmount || parseFloat(perpsDepositAmount) < 1 ? (
                    'Minimum deposit: 1 USDC'
                  ) : parseFloat(perpsDepositAmount) > (Number(arbUSDCBalance) / 1e6) ? (
                    'Insufficient Balance'
                  ) : (
                    'Deposit'
                  )}
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 31 ? ( // perps-withdraw-popup
          <div className="modal-overlay">
            <div className="modal-content" ref={popupref}>
              <div className="modal-header">
                <h2>Withdraw</h2>
                <button
                  className="modal-close"
                  onClick={() => setpopup(0)}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div className="modal-body">
                <div className="perps-deposit-form">
                  <div className="form-group">
                    <div className="perps-deposit-input-wrapper">
                      <div className="perps-deposit-balance">
                        Withdrawing
                        <div className="">
                          <span>Balance: </span>
                          <span>0.00</span>
                          <button className="perps-max-button">Max</button>
                        </div>
                      </div>
                      <div className="perps-input-bottom-row">
                        <input
                          type="text"
                          placeholder="0.0"
                          className="perps-deposit-input"
                        />
                        <div className="perps-deposit-token-badge">
                          <img className="perps-deposit-icon" src={iconusdc} />
                          <img className="edgeX-icon" src={edgeX} />
                          <span>USDC</span>
                        </div>
                      </div>
                    </div>
                    <div className="perps-switch-icon" onClick={() => setpopup(30)}
                    >                      <img className="perps-switch-img" src={switchicon} />
                    </div>
                    <div className="perps-deposit-input-wrapper">
                      <div className="perps-deposit-balance">
                        Receiving
                        <div className="">
                          <span>Balance: </span>
                          <span>{(Number(arbUSDCBalance) / 1e6).toFixed(2)}</span>
                        </div>
                      </div>
                      <div className="perps-input-bottom-row">
                        <input
                          type="text"
                          placeholder="0.0"
                          className="perps-deposit-input"
                        />
                        <div className="perps-deposit-token-badge">
                          <img className="perps-deposit-icon" src={iconusdc} />
                          <span>USDC</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div className="modal-footer">
                <button className="perps-confirm-button">
                  Withdraw
                </button>
              </div>
            </div>
          </div>
        ) : null}

        {popup === 32 ? (
          <div ref={popupref}>
            <ImportWalletsPopup
              onClose={() => setpopup(0)}
              onImport={handleImportWallets}
            />
          </div>
        ) : null}

        {popup === 33 ? (
          <div ref={popupref} style={{ zIndex: 10001 }}>
            <LiveTradesSettingsPopup
              onClose={() => setpopup(0)}
            />
          </div>
        ) : null}

        {popup === 34 ? (
          <div ref={popupref} style={{ zIndex: 10001 }}>
            <TradingPresetsPopup
              onClose={() => setpopup(0)}
              buyPresets={buyPresets}
              onSavePresets={handleSavePresets}
            />
          </div>
        ) : null}


        {popup === 35 ? (
          <div className="leverage-modal-content" ref={popupref}>
            <div className="leverage-modal-header">
              <h2 className="leverage-modal-title">Adjust Leverage</h2>
              <button
                className="close-button"
                onClick={() => setpopup(0)}
              >
                
              </button>
            </div>

            <div className="leverage-modal-body">
              <p className="leverage-description">
                Adjust your leverage to manage your exposure. Higher leverage increases
                both potential profits and risks.
              </p>

              <div className="leverage-slider-section">
                <div className="leverage-slider-container">
                  <input
                    ref={(el) => {
                      if (el && popup === 35) {
                        const leverageValue = parseFloat(perpsLeverage) || 10;
                        const percent = ((leverageValue - 1) / (Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage) - 1)) * 100;
                        const thumbW = 16;
                        const container = el.parentElement;
                        if (container) {
                          const popup = container.querySelector('.leverage-value-popup') as HTMLElement;
                          if (popup) {
                            const containerRect = container.getBoundingClientRect();
                            const inputRect = el.getBoundingClientRect();
                            const inputLeft = inputRect.left - containerRect.left;
                            const x = inputLeft + (percent / 100) * (inputRect.width - thumbW) + thumbW / 2;
                            popup.style.left = `${x}px`;
                            popup.style.transform = 'translateX(-50%)';
                          }
                        }
                      }
                    }}
                    type="range"
                    min="1"
                    max={perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage}
                    step="1"
                    value={(parseFloat(perpsLeverage) || 10)}
                    onChange={(e) => {
                      const value = e.target.value;
                      setPerpsLeverage(value);

                      const container = e.target.parentElement;
                      if (container) {
                        const popup = container.querySelector('.leverage-value-popup') as HTMLElement;
                        if (popup) {
                          const percent = ((parseInt(value) - 1) / (Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage) - 1)) * 100;
                          const thumbW = 16;
                          const containerRect = container.getBoundingClientRect();
                          const inputRect = e.target.getBoundingClientRect();
                          const inputLeft = inputRect.left - containerRect.left;
                          const x = inputLeft + (percent / 100) * (inputRect.width - thumbW) + thumbW / 2;
                          popup.style.left = `${x}px`;
                          popup.style.transform = 'translateX(-50%)';
                        }
                      }
                    }}
                    onMouseDown={(e) => {
                      const container = e.currentTarget.parentElement;
                      if (container) {
                        const popup = container.querySelector('.leverage-value-popup') as HTMLElement;
                        if (popup) popup.classList.add('visible');
                      }
                    }}
                    onMouseUp={(e) => {
                      const container = e.currentTarget.parentElement;
                      if (container) {
                        const popup = container.querySelector('.leverage-value-popup') as HTMLElement;
                        if (popup) popup.classList.remove('visible');
                      }
                    }}
                    className="leverage-slider-input"
                    style={{
                      background: `linear-gradient(to right, #aaaecf ${(((parseFloat(perpsLeverage) || 10) - 1) / (Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage) - 1) * 100) || 0}%, #2a2a2f ${(((parseFloat(perpsLeverage) || 10) - 1) / (Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage) - 1) * 100) || 0}%)`
                    }}
                  />
                  <div className="leverage-value-popup">
                    {parseFloat(perpsLeverage) || 10}x
                  </div>
                </div>

                <div className="leverage-display">
                  Leverage: <span className="leverage-value">{parseFloat(perpsLeverage) || 10}x</span>
                </div>
              </div>

              <button
                className="leverage-update-button"
                onClick={async () => {
                  if (Object.keys(perpsMarketsData).length == 0) return;
                  const payload = {
                    accountId: perpsKeystore.accountId,
                    contractId: perpsMarketsData[perpsActiveMarketKey]?.contractId,
                    leverage: perpsLeverage
                  }
                  const ts = Date.now().toString()
                  const path = '/api/v1/private/account/updateLeverageSetting'
                  const qs = Object.keys(payload).sort().map(k => `${k}=${(payload as any)[k]}`).join('&')
                  const signature = computeHmac("sha256", Buffer.from(btoa(encodeURI(perpsKeystore.apiSecret))), toUtf8Bytes(ts + "POST" + path + qs)).slice(2)
                  const [metaRes] = await Promise.all([
                    fetch(`${settings.perpsEndpoint}/api/v1/private/account/updateLeverageSetting`, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        "X-edgeX-Timestamp": ts,
                        "X-edgeX-Signature": signature,
                        "X-edgeX-Passphrase": perpsKeystore.apiPassphrase,
                        "X-edgeX-Api-Key": perpsKeystore.apiKey
                      },
                      body: JSON.stringify(payload)
                    }).then(r => r.json())
                  ])
                  console.log(metaRes)
                  localStorage.setItem('crystal_perps_leverage', perpsLeverage);
                  setpopup(0);
                }}
              >
                Update Leverage
              </button>
            </div>
          </div>
        ) : null}
        {popup === 36 ? (
          <div ref={popupref}>
            <MemeSearch
              setpopup={setpopup}
              monUsdPrice={monUsdPrice}
              onTokenClick={handleTokenClick}
              onQuickBuy={handleQuickBuy}
              sendUserOperationAsync={sendUserOperationAsync}
              quickAmounts={quickAmounts}
              setQuickAmount={setQuickAmount}
              activePresets={activePresets}
              setActivePreset={setActivePreset}
              handleInputFocus={handleInputFocus}
              buyPresets={buyPresetsWithAmount}
              marketsData={marketsData}
              tokendict={tokendict}
              onMarketSelect={onMarketSelect}
              subWallets={subWallets}
              selectedWallets={selectedWallets}
              setSelectedWallets={setSelectedWallets}
              walletTokenBalances={walletTokenBalances}
              address={address}
              createSubWallet={createSubWallet}
              activeWalletPrivateKey={oneCTSigner}
              activechain={activechain}
            />
          </div>
        ) : null}
        {popup === 37 ? ( // presets settings popup
          <div ref={popupref} className="presets-settings-popup-bg" style={{ zIndex: 10001 }}>
            <div className="presets-settings-popup-header">
              <h3 className="presets-settings-popup-title">Trade Settings</h3>
              <button
                className="presets-settings-popup-close"
                onClick={() => {
                  setpopup(0);
                }}
              >
                <img src={closebutton} className="presets-settings-close-icon" alt="Close" />
              </button>
            </div>

            <div className="presets-settings-popup-content">
              <div className="meme-settings-presets">
                <button
                  className={`meme-settings-preset ${(settingsMode === 'buy' ? selectedBuyPreset : selectedSellPreset) === 1
                    ? `active ${settingsMode}`
                    : ''
                    }`}
                  onClick={() => {
                    if (settingsMode === 'buy') {
                      handleBuyPresetSelect(1);
                    } else {
                      handleSellPresetSelect(1);
                    }
                  }}
                >
                  PRESET 1
                </button>
                <button
                  className={`meme-settings-preset ${(settingsMode === 'buy' ? selectedBuyPreset : selectedSellPreset) === 2
                    ? `active ${settingsMode}`
                    : ''
                    }`}
                  onClick={() => {
                    if (settingsMode === 'buy') {
                      handleBuyPresetSelect(2);
                    } else {
                      handleSellPresetSelect(2);
                    }
                  }}
                >
                  PRESET 2
                </button>
                <button
                  className={`meme-settings-preset ${(settingsMode === 'buy' ? selectedBuyPreset : selectedSellPreset) === 3
                    ? `active ${settingsMode}`
                    : ''
                    }`}
                  onClick={() => {
                    if (settingsMode === 'buy') {
                      handleBuyPresetSelect(3);
                    } else {
                      handleSellPresetSelect(3);
                    }
                  }}
                >
                  PRESET 3
                </button>
              </div>
              <div className="meme-settings-mode-toggle">
                <button
                  className={`meme-settings-mode-btn ${settingsMode === 'buy' ? 'active' : ''}`}
                  onClick={() => setSettingsMode('buy')}
                >
                  Buy settings
                </button>
                <button
                  className={`meme-settings-mode-btn ${settingsMode === 'sell' ? 'active' : ''}`}
                  onClick={() => setSettingsMode('sell')}
                >
                  Sell settings
                </button>
              </div>


              <div className="meme-settings-grid">
                <div className="meme-setting-item">
                  <div className="meme-setting-input-wrapper">
                    <input
                      type="number"
                      className="meme-setting-input"
                      value={
                        settingsMode === 'buy'
                          ? buySlippageValue
                          : sellSlippageValue
                      }
                      onChange={(e) =>
                        settingsMode === 'buy'
                          ? setBuySlippageValue(e.target.value)
                          : setSellSlippageValue(e.target.value)
                      }
                      step="0.1"
                      min="0"
                      max="100"
                    />
                    <span className="meme-setting-unit">%</span>
                  </div>
                  <label className="meme-setting-label">
                    <img
                      src={slippageicon}
                      className="meme-setting-label-icon-slippage"
                    />
                    SLIPPAGE
                  </label>
                </div>

                <div className="meme-setting-item">
                  <div className="meme-setting-input-wrapper">
                    <input
                      type="number"
                      className="meme-setting-input"
                      value={
                        settingsMode === 'buy'
                          ? buyPriorityFee
                          : sellPriorityFee
                      }
                      onChange={(e) =>
                        settingsMode === 'buy'
                          ? setBuyPriorityFee(e.target.value)
                          : setSellPriorityFee(e.target.value)
                      }
                      step="0.001"
                      min="0"
                    />
                    <span className="meme-setting-unit">GWEI</span>
                  </div>
                  <label className="meme-setting-label">
                    <img
                      src={gas}
                      alt="Priority Fee"
                      className="meme-setting-label-icon"
                    />
                    PRIORITY
                  </label>
                </div>
              </div>
            </div>
          </div>
        ) : null}

        {popup === 38 ? (
          <div className="alerts-popup-overlay" onClick={() => setpopup(0)}>
            <div className="notification-manager-popup" ref={popupref} onClick={(e) => e.stopPropagation()}>
              <div className="alerts-popup-header">
                <h3 className="alerts-popup-title">Notification Settings</h3>
                <button className="alerts-close-button" onClick={() => setpopup(0)}>
                  <img src={closebutton} className="explorer-close-button" />
                </button>
              </div>

              <div className="notification-manager-content">
                <div className="alerts-section">
                  <div className="alerts-main-toggle">
                    <div>
                      <h4 className="notifications-main-label">Display notifications</h4>
                      <p className="alerts-description">
                        Display wallet tracker toasts, and notification cards
                      </p>
                    </div>
                    <div
                      className={`toggle-switch ${displayNotifications ? 'active' : ''}`}
                      onClick={() => setDisplayNotifications(!displayNotifications)}
                    >
                      <div className="toggle-slider" />
                    </div>
                  </div>
                </div>

                <div className="alerts-section">
                  <h4 className="notifications-main-label">Toast Position</h4>
                  <div className="position-grid">
                    {['top-left', 'top-center', 'top-right', 'bottom-left', 'bottom-center', 'bottom-right'].map((pos) => (
                      <button
                        key={pos}
                        className={`position-option ${toastPosition === pos ? 'active' : ''}`}
                        onClick={() => {
                          setToastPosition(pos);
                          localStorage.setItem('crystal_toast_position', pos);
                          window.dispatchEvent(new Event('toast-position-updated'));
                        }}
                      >
                        <div className="position-preview">
                          <div className="toast-indicator"></div>
                        </div>
                        <span>{pos.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</span>
                      </button>
                    ))}
                  </div>
                </div>

                <div className="alerts-section">
                  <div className="alerts-main-toggle">
                    <div>
                      <h4 className="notifications-main-label">Transaction Sounds</h4>
                    </div>
                    <div
                      className={`toggle-switch ${transactionSounds ? 'active' : ''}`}
                      onClick={() => setTransactionSounds(!transactionSounds)}
                    >
                      <div className="toggle-slider" />
                    </div>
                  </div>
                </div>

                {transactionSounds && (
                  <div>
                    <div className="alerts-volume-slider">
                      <div className="volume-label">
                        <span className="volume-text">Notification Volume</span>
                        <span className="volume-value">{volume}%</span>
                      </div>

                      <div
                        className="meme-slider-container meme-slider-mode"
                        style={{ position: 'relative' }}
                      >
                        <input
                          type="range"
                          className={`meme-balance-amount-slider ${isDragging ? 'dragging' : ''}`}
                          min="0"
                          max="100"
                          step="1"
                          value={volume}
                          onChange={handleVolumeSliderChange}
                          onMouseDown={() => setIsDragging(true)}
                          onMouseUp={handleVolumeChangeEnd}
                          onTouchStart={() => setIsDragging(true)}
                          onTouchEnd={handleVolumeChangeEnd}
                          style={{
                            background: `linear-gradient(to right, rgb(171,176,224) ${volume}%, rgb(28,28,31) ${volume}%)`,
                          }}
                        />

                        <div className="meme-volume-slider-marks">
                          {[0, 25, 50, 75, 100].map((mark) => (
                            <span
                              key={mark}
                              className="meme-volume-slider-mark"
                              data-active={volume >= mark}
                              data-percentage={mark}
                              onClick={() => {
                                setVolume(mark)
                              }}
                            >
                              {mark}%
                            </span>
                          ))}
                        </div>
                      </div>
                    </div>

                    <div className="alerts-section">
                      <div className="sound-options">
                        {(['buy', 'sell'] as const).map((key) => (
                          <div className="sound-option" key={key}>
                            <span className="sound-option-label">
                              {key === 'buy' ? 'Buy Sound' : 'Sell Sound'}
                            </span>
                            <div className="sound-controls">
                              <div className="sound-selector-dropdown">
                                <div
                                  className="sound-selector"
                                  onClick={() => toggleDropdown(key)}
                                  onBlur={(e) => {
                                    if (
                                      !e.currentTarget.parentElement?.contains(
                                        e.relatedTarget as Node,
                                      )
                                    ) {
                                      closeDropdown(key);
                                    }
                                  }}
                                >
                                  <Volume2 size={14} />
                                  <span>
                                    {getSoundDisplayName(
                                      key === 'buy' ? buySound : sellSound
                                    )}
                                  </span>
                                  <div className="sound-action-button-container">
                                    <button
                                      className="sound-action-btn"
                                      onClick={(e) => {
                                        e.stopPropagation();
                                        playSound(key);
                                      }}
                                      title="Play sound"
                                    >
                                      <Play size={14} />
                                    </button>

                                    <button
                                      className="sound-action-btn"
                                      onClick={(e) => {
                                        e.stopPropagation();
                                        if (key === 'buy') {
                                          setBuySound(stepaudio);
                                        } else {
                                          setSellSound(stepaudio);
                                        }
                                      }}
                                      title="Reset to default"
                                    >
                                      <RotateCcw size={14} />
                                    </button>
                                  </div>
                                  {openDropdowns[key] && (
                                    <div className="sound-dropdown-content">
                                      <button
                                        className={`sound-dropdown-item ${(key === 'buy' ? buySound : sellSound) === stepaudio
                                          ? 'active'
                                          : ''
                                          }`}
                                        onMouseDown={(e) => e.preventDefault()}
                                        onClick={() => {
                                          selectSound(key, stepaudio);
                                        }}
                                      >
                                        Step Audio
                                      </button>
                                      <button
                                        className={`sound-dropdown-item ${(key === 'buy' ? buySound : sellSound) === kaching
                                          ? 'active'
                                          : ''
                                          }`}
                                        onMouseDown={(e) => e.preventDefault()}
                                        onClick={() => {
                                          selectSound(key, kaching);
                                        }}
                                      >
                                        Ka-ching
                                      </button>
                                      <label className="sound-dropdown-item">
                                        Upload Other
                                        <input
                                          type="file"
                                          accept="audio/*"
                                          style={{ display: 'none' }}
                                          onChange={(e) => {
                                            handleFileUpload(key, e);
                                          }}
                                        />
                                      </label>
                                    </div>
                                  )}
                                </div>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>

                      <p className="alerts-file-info">
                        Maximum 5 seconds and 0.2MB file size
                      </p>
                    </div>
                  </div>
                )}

                <button className="alerts-continue-btn" onClick={() => setpopup(0)}>
                  Done
                </button>
              </div>
            </div>
          </div>
        ) : null}
      </div>
    </>
  );

  const tempswap = (
    <div className="rectangle">
      <div className="navlinkwrapper" onClick={() => {
        if (windowWidth <= 1020 && !simpleView && !showTrade) {
          setShowTrade(true);
          document.querySelector('.trade-mobile-switch')?.classList.add('open');
        }
      }} data-active={location.pathname.slice(1)}>
        <div className="innernavlinkwrapper">
          <Link
            to={simpleView ? "/swap" : "/market"}
            className={`navlink ${location.pathname.slice(1) === 'market' || location.pathname.slice(1) === 'swap' ? 'active' : ''}`}
            onClick={(e) => {
              if ((location.pathname === '/swap' && simpleView) ||
                (location.pathname === '/market' && !simpleView)) {
                e.preventDefault();
              }
            }}
          >
            {simpleView ? t('swap') : t('market')}
          </Link>
          <Link
            to="/send"
            className={`navlink ${location.pathname.slice(1) === 'send' || location.pathname.slice(1) === 'scale' ? 'active' : ''}`}
            onClick={() => {
              setShowSendDropdown(false);
              setCurrentProText('send');
            }}
          >
            {t('send')}
          </Link>
          <button
            className={`refresh-quote-button ${isRefreshing ? 'refreshing' : ''}`}
            onClick={handleRefreshQuote}
            disabled={isRefreshing}
          >
            <img src={reset} className="refresh-quote-icon"></img>
            <svg className="refresh-timer-circle" viewBox="0 0 24 24">
              <circle className="timer-circle-border" cx="12" cy="12" r="9" />
            </svg>
          </button>
          {showSendDropdown && (
            <div className="navlink-dropdown" ref={sendDropdownRef}>
              <Link
                to="/send"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('send');
                }}
              >
                {t('send')}
              </Link>
              <Link
                to="/scale"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('scale');
                }}
              >
                <TooltipLabel
                  label={t('scale')}
                  tooltipText={
                    <div>
                      <div className="tooltip-description">
                        {t('scaleTooltip')}
                      </div>
                    </div>
                  }
                  className="impact-label"
                />
              </Link>

            </div>
          )}
        </div>
        <div className="sliding-tab-indicator" />
      </div>
      <div className="swapmodal">
        <div
          className={`inputbg ${connected && amountIn > walletTokenBalances[address]?.[tokenIn] && !txPending.current
            ? 'exceed-balance'
            : ''
            }`}
        >
          <div className="Pay">{t('pay')}</div>
          <div className="inputbutton1container">
            {displayValuesLoading &&
              switched == true &&
              !(inputString == '' && outputString == '') ? (
              <div className="output-skeleton" />
            ) : (
              <input
                inputMode="decimal"
                className={`input ${connected &&
                  amountIn > walletTokenBalances[address]?.[tokenIn] && !txPending.current
                  ? 'exceed-balance'
                  : ''
                  }`}
                onCompositionStart={() => {
                  setIsComposing(true);
                }}
                onCompositionEnd={(
                  e: React.CompositionEvent<HTMLInputElement>,
                ) => {
                  setIsComposing(false);
                  if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                    setInputString(e.currentTarget.value);
                    if (
                      (inputString.endsWith('.') && e.currentTarget.value === inputString.slice(0, -1)) ||
                      (e.currentTarget.value.endsWith('.') && e.currentTarget.value.slice(0, -1) === inputString)
                    ) {
                      return;
                    }
                    const inputValue = BigInt(
                      Math.round(
                        (parseFloat(e.currentTarget.value || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    );
                    debouncedSetAmount(inputValue);
                    setswitched(false);
                    if (isWrap) {
                      setamountOutSwap(inputValue);
                      setoutputString(e.currentTarget.value);
                    }
                    const percentage = !walletTokenBalances[address]?.[tokenIn]
                      ? 0
                      : Math.min(
                        100,
                        Math.floor(
                          Number(
                            (inputValue * BigInt(100)) /
                            walletTokenBalances[address]?.[tokenIn],
                          ),
                        ),
                      );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                    if (inputValue == 0n) {
                      setoutputString('')
                      setamountOutSwap(0n)
                      setStateIsLoading(false);
                      setstateloading(false);
                      setDisplayValuesLoading(false);
                    }
                  }
                }}
                onChange={(e) => {
                  if (isComposing) {
                    setInputString(e.target.value);
                    return;
                  }
                  if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                    setInputString(e.target.value);
                    if (
                      (inputString.endsWith('.') && e.target.value === inputString.slice(0, -1)) ||
                      (e.target.value.endsWith('.') && e.target.value.slice(0, -1) === inputString)
                    ) {
                      return;
                    }
                    const inputValue = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    );
                    debouncedSetAmount(inputValue);
                    setswitched(false);
                    if (isWrap) {
                      setamountOutSwap(inputValue);
                      setoutputString(e.target.value);
                    }
                    const percentage = !walletTokenBalances[address]?.[tokenIn]
                      ? 0
                      : Math.min(
                        100,
                        Math.floor(
                          Number(
                            (inputValue * BigInt(100)) /
                            walletTokenBalances[address]?.[tokenIn],
                          ),
                        ),
                      );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                    if (inputValue == 0n) {
                      setoutputString('')
                      setamountOutSwap(0n)
                      setStateIsLoading(false);
                      setstateloading(false);
                      setDisplayValuesLoading(false);
                    }
                  }
                }}
                placeholder="0.00"
                value={inputString}
                autoFocus={
                  outputString === '' &&
                  switched === false &&
                  !(windowWidth <= 1020)
                }
              />
            )}
            <button
              className={`button1 ${connected &&
                amountIn > walletTokenBalances[address]?.[tokenIn] && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onClick={() => {
                setpopup(1);
              }}
            >
              <img className="button1pic" src={tokendict[tokenIn].image} />
              <span>{tokendict[tokenIn].ticker || '?'}</span>
              <svg
                className={`button-arrow ${popup == 1 ? 'open' : ''}`}
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="16"
                height="16"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </button>
          </div>
          <div className="balance1maxcontainer">
            {displayValuesLoading &&
              switched == true &&
              !(inputString == '' && outputString == '') ? (
              <div className="output-usd-skeleton" />
            ) : (
              <span className="usd-value">
                {Math.round(
                  (parseFloat(inputString || '0') || 0) *
                  10 ** Number(tokendict[tokenIn].decimals),
                ) == 0
                  ? '$0.00'
                  : formatUSDDisplay(
                    calculateUSDValue(
                      BigInt(
                        Math.round(
                          (parseFloat(inputString || '0') || 0) *
                          10 ** Number(tokendict[tokenIn].decimals),
                        ),
                      ),
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                      ],
                      tokenIn,
                      getMarket(
                        activeMarket.path.at(0),
                        activeMarket.path.at(1),
                      ),
                    ),
                  )}
              </span>
            )}
            <div className="balance1">
              <img src={walleticon} className="balance-wallet-icon" />{' '}
              {formatSubscript(formatDisplayValue(
                walletTokenBalances[address]?.[tokenIn],
                Number(tokendict[tokenIn].decimals),
              ))}
            </div>
            <div
              className="max-button"
              onClick={() => {
                if (walletTokenBalances[address]?.[tokenIn] != BigInt(0)) {
                  let amount =
                    (tokenIn == eth && !client)
                      ? walletTokenBalances[address]?.[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? walletTokenBalances[address]?.[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : walletTokenBalances[address]?.[tokenIn];
                  debouncedSetAmount(BigInt(amount));
                  setswitched(false);
                  setInputString(
                    customRound(
                      Number(amount) /
                      10 ** Number(tokendict[tokenIn].decimals),
                      3,
                    ).toString(),
                  );
                  if (isWrap) {
                    setamountOutSwap(BigInt(amount));
                    setoutputString(
                      customRound(
                        Number(amount) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      ).toString(),
                    );
                  }
                  setSliderPercent(100);
                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    const trackWidth = rect.width - 15;
                    const thumbPosition = trackWidth + 15 / 2;
                    (popup as HTMLElement).style.left = `${thumbPosition}px`;
                  }
                }
              }}
            >
              {t('max')}{' '}
            </div>
          </div>
        </div>
        <div
          className="switch-button"
          onClick={() => {
            setTokenIn(tokenOut);
            setTokenOut(tokenIn);
            if (amountIn != BigInt(0) || amountOutSwap != BigInt(0)) {
              if (!isWrap) {
                setStateIsLoading(true);
                setInputString(outputString);
                setamountIn(amountOutSwap);
                setamountOutSwap(BigInt(0));
                setoutputString('');
              }
            }
          }}
        >
          <img src={tradearrow} className="switch-arrow" />
        </div>
        <div className="swap-container-divider" />
        <div className="outputbg">
          <div className="Recieve">{t('receive')}</div>
          <div className="outputbutton2container">
            {displayValuesLoading &&
              switched == false &&
              !(inputString == '' && outputString == '') ? (
              <div className="output-skeleton" />
            ) : (
              <input
                inputMode="decimal"
                className="output"
                disabled
                onCompositionStart={() => {
                  setIsComposing(true);
                }}
                onCompositionEnd={(
                  e: React.CompositionEvent<HTMLInputElement>,
                ) => {
                  setIsComposing(false);
                  if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                    setoutputString(e.currentTarget.value);
                    if (
                      (outputString.endsWith('.') && e.currentTarget.value === outputString.slice(0, -1)) ||
                      (e.currentTarget.value.endsWith('.') && e.currentTarget.value.slice(0, -1) === outputString)
                    ) {
                      return;
                    }
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.currentTarget.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    );
                    if (isWrap) {
                      setamountIn(outputValue);
                      setInputString(e.currentTarget.value);
                    }
                    debouncedSetAmountOut(outputValue);
                    setswitched(true);
                  }
                }}
                onChange={(e) => {
                  if (isComposing) {
                    setoutputString(e.target.value);
                    return;
                  }
                  if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                    setoutputString(e.target.value);
                    if (
                      (outputString.endsWith('.') && e.target.value === outputString.slice(0, -1)) ||
                      (e.target.value.endsWith('.') && e.target.value.slice(0, -1) === outputString)
                    ) {
                      return;
                    }
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    );
                    if (isWrap) {
                      setamountIn(outputValue);
                      setInputString(e.target.value);
                    }
                    debouncedSetAmountOut(outputValue);
                    setswitched(true);
                  }
                }}
                value={outputString}
                placeholder="0.00"
              />
            )}
            <button
              className="button2"
              onClick={() => {
                setpopup(2);
              }}
            >
              <img className="button2pic" src={tokendict[tokenOut].image} />
              <span>{tokendict[tokenOut].ticker || '?'}</span>
              <svg
                className={`button-arrow ${popup == 2 ? 'open' : ''}`}
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="16"
                height="16"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </button>
          </div>
          <div className="balance1maxcontainer">
            {displayValuesLoading &&
              switched == false &&
              !(inputString == '' && outputString == '') ? (
              <div className="output-usd-skeleton" />
            ) : (
              <div className="output-usd-value">
                {amountOutSwap === BigInt(0)
                  ? '$0.00'
                  : (() => {
                    const outputUSD = calculateUSDValue(
                      BigInt(
                        Math.round(
                          (parseFloat(outputString || '0') || 0) *
                          10 ** Number(tokendict[tokenOut].decimals),
                        ),
                      ),
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(-2), activeMarket.path.at(-1)))
                      ],
                      tokenOut,
                      getMarket(
                        activeMarket.path.at(-2),
                        activeMarket.path.at(-1),
                      ),
                    );

                    const inputUSD = calculateUSDValue(
                      amountIn,
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                      ],
                      tokenIn,
                      getMarket(
                        activeMarket.path.at(0),
                        activeMarket.path.at(1),
                      ),
                    );

                    const percentageDiff =
                      inputUSD > 0
                        ? ((outputUSD - inputUSD) / inputUSD) * 100
                        : 0;

                    return (
                      <div className="output-usd-container">
                        <span>{formatUSDDisplay(outputUSD)}</span>
                        {inputUSD > 0 && !displayValuesLoading && !stateIsLoading && (
                          <span
                            className={`output-percentage ${percentageDiff >= 0 ? 'positive' : 'negative'}`}
                          >
                            ({percentageDiff >= 0 ? '+' : ''}
                            {percentageDiff.toFixed(2)}%)
                          </span>
                        )}
                      </div>
                    );
                  })()}
              </div>
            )}
            <div className="balance2">
              <img src={walleticon} className="balance-wallet-icon" />{' '}
              {formatSubscript(formatDisplayValue(
                walletTokenBalances[address]?.[tokenOut],
                Number(tokendict[tokenOut].decimals),
              ))}
            </div>
          </div>
        </div>
        <div className="balance-slider-wrapper">
          {spotSliderMode === 'presets' ? (
            <div className="slider-container presets-mode">
              <div className="preset-buttons">
                {spotSliderPresets.map((preset: number, index: number) => (
                  <button
                    key={index}
                    className={`preset-button ${sliderPercent === preset ? 'active' : ''}`}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? walletTokenBalances[address]?.[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? walletTokenBalances[address]?.[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : walletTokenBalances[address]?.[tokenIn]) *
                            BigInt(preset)) /
                          100n;
                        setSliderPercent(preset);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left = `${(rect.width - 15) * (preset / 100) + 15 / 2}px`;
                        }
                      }
                    }}
                    disabled={!connected}
                  >
                    {preset}%
                  </button>
                ))}
              </div>
            </div>
          ) : spotSliderMode === 'increment' ? (
            <div className="slider-container increment-mode">
              <button
                className="increment-button minus"
                onClick={() => {
                  if (connected && sliderPercent > 0) {
                    const newPercent = Math.max(0, sliderPercent - spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? walletTokenBalances[address]?.[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? walletTokenBalances[address]?.[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : walletTokenBalances[address]?.[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 0}
              >
                
              </button>
              <div className="increment-display">
                <div className="increment-amount">{spotSliderIncrement}%</div>
              </div>
              <button
                className="increment-button plus"
                onClick={() => {
                  if (connected && sliderPercent < 100) {
                    const newPercent = Math.min(100, sliderPercent + spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? walletTokenBalances[address]?.[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? walletTokenBalances[address]?.[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : walletTokenBalances[address]?.[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 100}
              >
                +
              </button>
            </div>
          ) : (
            <div className="slider-container slider-mode">
              <input
                type="range"
                className={`balance-amount-slider ${isDragging ? 'dragging' : ''}`}
                min="0"
                max="100"
                step="1"
                value={sliderPercent}
                disabled={!connected}
                onChange={(e) => {
                  const percent = parseInt(e.target.value);
                  const newAmount =
                    (((tokenIn == eth && !client)
                      ? walletTokenBalances[address]?.[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? walletTokenBalances[address]?.[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : walletTokenBalances[address]?.[tokenIn]) *
                      BigInt(percent)) /
                    100n;
                  setSliderPercent(percent);
                  setInputString(
                    newAmount == BigInt(0)
                      ? ''
                      : customRound(
                        Number(newAmount) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      ).toString(),
                  );
                  debouncedSetAmount(newAmount);
                  setswitched(false);
                  if (isWrap) {
                    setoutputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    setamountOutSwap(newAmount);
                  }
                  if (location.pathname.slice(1) === 'limit') {
                    setamountOutSwap(
                      limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                          : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                        : BigInt(0),
                    );
                    setoutputString(
                      (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                          : customRound(
                            Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                  }
                  const slider = e.target;
                  const rect = slider.getBoundingClientRect();
                  const trackWidth = rect.width - 15;
                  const thumbPosition = (percent / 100) * trackWidth + 15 / 2;
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) {
                    popup.style.left = `${thumbPosition}px`;
                  }
                }}
                onMouseDown={() => {
                  setIsDragging(true);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.add('visible');
                }}
                onMouseUp={() => {
                  setIsDragging(false);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.remove('visible');
                }}
                style={{
                  background: `linear-gradient(to right,rgb(171, 176, 224) ${sliderPercent}%,rgb(21, 21, 27, 1) ${sliderPercent}%)`,
                }}
              />
              <div className="slider-percentage-popup">{sliderPercent}%</div>
              <div className="balance-slider-marks">
                {[0, 25, 50, 75, 100].map((markPercent) => (
                  <span
                    key={markPercent}
                    className="balance-slider-mark"
                    data-active={sliderPercent >= markPercent}
                    data-percentage={markPercent}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? walletTokenBalances[address]?.[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? walletTokenBalances[address]?.[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : walletTokenBalances[address]?.[tokenIn]) *
                            BigInt(markPercent)) /
                          100n;
                        setSliderPercent(markPercent);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup: HTMLElement | null = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          popup.style.left = `${(rect.width - 15) * (markPercent / 100) + 15 / 2
                            }px`;
                        }
                      }
                    }}
                  >
                    {markPercent}%
                  </span>
                ))}
              </div>
            </div>
          )}
        </div>
        <button
          className={`swap-button ${isSigning ? 'signing' : ''}`}
          onClick={async () => {
            if (connected && userchain === activechain) {
              if (warning == 1) {
                setpopup(13);
                const confirmed = await new Promise((resolve) => {
                  const handleConfirm = () => {
                    cleanup();
                    resolve(true);
                  };

                  const handleCancel = () => {
                    cleanup();
                    resolve(false);
                  };

                  const cleanup = () => {
                    window.removeEventListener('high-impact-confirm', handleConfirm);
                    window.removeEventListener('high-impact-cancel', handleCancel);
                  };

                  window.addEventListener('high-impact-confirm', handleConfirm);
                  window.addEventListener('high-impact-cancel', handleCancel);

                });
                if (!confirmed) return;
              }
              let hash: any;
              setIsSigning(true);
              if (client) {
                txPending.current = true;
              }
              try {
                if (tokenIn == eth && tokenOut == weth) {
                  hash = await sendUserOperationAsync({ uo: wrapeth(amountIn, weth) }, (rpcQueryData?.gasEstimate ?? 0n));
                  newTxPopup(
                    hash,
                    'wrap',
                    eth,
                    weth,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    '',
                    ''
                  );
                } else if (tokenIn == weth && tokenOut == eth) {
                  hash = await sendUserOperationAsync({ uo: unwrapeth(amountIn, weth) }, (rpcQueryData?.gasEstimate ?? 0n));
                  newTxPopup(
                    hash,
                    'unwrap',
                    weth,
                    eth,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    '',
                    ''
                  );
                } else {
                  if (tokenIn == eth) {
                    hash = await sendUserOperationAsync({
                      uo: {
                        target: settings.chainConfig[activechain].madHouseRouter,
                        data: tempQueryData?.aggregatorRes?.tx?.data,
                        value: BigInt(tempQueryData?.aggregatorRes?.tx?.value)
                      }
                    }, tempQueryData?.gasEstimateRes)
                  } else {
                    if (allowance < amountIn) {
                      hash = await sendUserOperationAsync({
                        uo: approve(
                          tokenIn as `0x${string}`,
                          settings.chainConfig[activechain].madHouseRouter,
                          maxUint256
                        )
                      })
                      newTxPopup(
                        hash,
                        'approve',
                        tokenIn,
                        '',
                        customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn].decimals), 3),
                        0,
                        '',
                        settings.chainConfig[activechain].madHouseRouter
                      );
                    }
                    hash = await sendUserOperationAsync({
                      uo: {
                        target: settings.chainConfig[activechain].madHouseRouter,
                        data: tempQueryData?.aggregatorRes?.tx?.data,
                        value: BigInt(tempQueryData?.aggregatorRes?.tx?.value)
                      }
                    }, tempQueryData?.gasEstimateRes)
                  }
                }
                setswitched(false);
                setInputString('');
                setamountIn(BigInt(0));
                setoutputString('')
                setamountOutSwap(BigInt(0));
                setSliderPercent(0);
                setSwapButtonDisabled(true);
                setSwapButton(1);
                setIsSigning(false)
                const slider = document.querySelector('.balance-amount-slider');
                const popup = document.querySelector('.slider-percentage-popup');
                if (slider && popup) {
                  (popup as HTMLElement).style.left = `${15 / 2}px`;
                }
                newTxPopup(
                  hash?.hash,
                  'swap',
                  tokenIn,
                  tokenOut,
                  customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn == eth ? eth : tokenIn].decimals), 3),
                  customRound(Number(amountOutSwap) / 10 ** Number(tokendict[tokenOut == eth ? eth : tokenOut].decimals), 3),
                  '',
                  '',
                );
                await terminalRefetch()
                txPending.current = false
              } catch (error) {
                if (!(error instanceof TransactionExecutionError)) {
                  newTxPopup(
                    hash?.hash,
                    "swapFailed",
                    tokenIn == eth ? eth : tokenIn,
                    tokenOut == eth ? eth : tokenOut,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn == eth ? eth : tokenIn].decimals), 3),
                    customRound(Number(amountOutSwap) / 10 ** Number(tokendict[tokenOut == eth ? eth : tokenOut].decimals), 3),
                    "",
                    "",
                  );
                }
              } finally {
                txPending.current = false
                setIsSigning(false)
              }
            } else {
              !connected ? setpopup(4) : handleSetChain();
            }
          }}
          disabled={swapButtonDisabled || displayValuesLoading || isSigning}
        >
          {isSigning ? (
            <div className="button-content">
              <div className="loading-spinner" />
              {validOneCT ? t('') : t('signTransaction')}
            </div>
          ) : swapButton == 0 ? (
            t('insufficientLiquidity')
          ) : swapButton == 1 ? (
            t('enterAmount')
          ) : swapButton == 2 ? (
            t('swap')
          ) : swapButton == 3 ? (
            t('insufficient') +
            (tokendict[tokenIn].ticker || '?') +
            ' ' +
            t('bal')
          ) : swapButton == 4 ? (
            `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
          ) : swapButton == 5 ? (
            t('connectWallet')
          ) : (
            client ? t('swap') : t('approve')
          )}
        </button>
      </div>
      <div className="trade-info-rectangle">
        {!isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) && (
          <div className="slippage-row">
            <div className="label-container">
              <div className="slippage-group">
                <TooltipLabel
                  label={t('slippage')}
                  tooltipText={
                    <div>
                      <div className="tooltip-description">
                        {t('slippageHelp')}
                      </div>
                    </div>
                  }
                  className="slippage-label"
                />
              </div>
            </div>
            <div className="slippage-input-container">
              <input
                inputMode="decimal"
                className={`slippage-inline-input ${parseFloat(slippageString) > 5 ? 'red' : ''
                  }`}
                type="text"
                value={slippageString}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    (e.target as HTMLInputElement).blur()
                    e.stopPropagation()
                  };
                }}
                onChange={(e) => {
                  const value = e.target.value;

                  if (
                    /^(?!0{2})\d*\.?\d{0,2}$/.test(value) &&
                    !/^\d{2}\.\d{2}$/.test(value)
                  ) {
                    if (value === '') {
                      setSlippageString('');
                      setSlippage(BigInt(9900));
                      localStorage.setItem('crystal_slippage_string', '1');
                      localStorage.setItem('crystal_slippage', '9900');
                    } else if (parseFloat(value) <= 50) {
                      setSlippageString(value);
                      localStorage.setItem('crystal_slippage_string', value);

                      const newSlippage = BigInt(
                        10000 - parseFloat(value) * 100,
                      );
                      setSlippage(newSlippage);
                      localStorage.setItem(
                        'crystal_slippage',
                        newSlippage.toString(),
                      );
                    }
                  }
                }}
                onBlur={() => {
                  if (slippageString === '') {
                    setSlippageString('1');
                    localStorage.setItem('crystal_slippage_string', '1');

                    setSlippage(BigInt(9900));
                    localStorage.setItem('crystal_slippage', '9900');
                  }
                }}
              />
              <span
                className={`slippage-symbol ${parseFloat(slippageString) > 5 ? 'red' : ''
                  }`}
              >
                %
              </span>
            </div>
          </div>
        )}

        {!isWrap && (
          <div className="average-price">
            <div className="label-container">
              <TooltipLabel
                label={t('averagePrice')}
                tooltipText={
                  <div>
                    <div className="tooltip-description">
                      {t('averagePriceHelp')}
                    </div>
                  </div>
                }
                className="impact-label"
              />
            </div>
            <div className="value-container">
              {displayValuesLoading ? (
                <div className="limit-fee-skeleton" style={{ width: 80 }} />
              ) : isWrap ? (
                `1 ${tokendict[tokenOut].ticker}`
              ) : (
                `${formatSubscript(averagePrice)} ${tokendict[tokenIn].ticker}`
              )}
            </div>
          </div>
        )}

        <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={`${t('fee')} (0.${isWrap || ((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) ? '00' : String(Number(BigInt(100000) - activeMarket.fee) / 100).replace(/\./g, "")}%)`}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {isWrap ? t('nofeeforwrap') : t('takerfeeexplanation')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <div className="value-container">
            {displayValuesLoading ? (
              <div className="limit-fee-skeleton" style={{ width: 70 }} />
            ) : isWrap || ((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) ? (
              `0 ${tokendict[tokenIn].ticker}`
            ) : (
              formatCommas(tradeFee)
            )}
          </div>
        </div>

        {(warning == 1 && (
          <div className="price-impact-warning">{t('Warning')}</div>
        )) ||
          (warning == 2 && (
            <div className="price-impact-warning">
              {t('insufficientLiquidityWarning')}
            </div>
          )) ||
          (warning == 3 && (
            <div className="price-impact-warning">
              {t('insufficientLiquidityWarningMultihop')}
            </div>
          ))}
      </div>
    </div>
  );

  // trade ui component
  const swap = (
    <div className="rectangle">
      <div className="navlinkwrapper" onClick={() => {
        if (windowWidth <= 1020 && !simpleView && !showTrade) {
          setShowTrade(true);
          document.querySelector('.trade-mobile-switch')?.classList.add('open');
        }
      }} data-active={location.pathname.slice(1)}>
        <div className="innernavlinkwrapper">
          <Link
            to={simpleView ? "/swap" : "/market"}
            className={`navlink ${location.pathname.slice(1) === 'market' || location.pathname.slice(1) === 'swap' ? 'active' : ''}`}
            onClick={(e) => {
              if ((location.pathname === '/swap' && simpleView) ||
                (location.pathname === '/market' && !simpleView)) {
                e.preventDefault();
              }
            }}
          >
            {simpleView ? t('swap') : t('market')}
          </Link>
          <Link
            to="/limit"
            className={`navlink ${location.pathname.slice(1) === 'limit' ? 'active' : ''}`}
          >
            {t('limit')}
          </Link>
          <span
            ref={(el: HTMLSpanElement | null) => {
              sendButtonRef.current = el;
            }}
            className={`navlink ${location.pathname.slice(1) === 'send' || location.pathname.slice(1) === 'scale' ? 'active' : ''}`}
            onClick={(e: React.MouseEvent) => {
              e.preventDefault();
              setShowSendDropdown(!showSendDropdown);
            }}
          >
            <span className="current-pro-text">{t(currentProText)}</span>
            <svg
              className={`dropdown-arrow ${showSendDropdown ? 'open' : ''}`}
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="12"
              height="12"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            >
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </span>
          <button
            className={`refresh-quote-button ${isRefreshing ? 'refreshing' : ''}`}
            onClick={handleRefreshQuote}
            disabled={isRefreshing}
          >
            <img src={reset} className="refresh-quote-icon"></img>
            <svg className="refresh-timer-circle" viewBox="0 0 24 24">
              <circle className="timer-circle-border" cx="12" cy="12" r="9" />
            </svg>
          </button>
          {showSendDropdown && (
            <div className="navlink-dropdown" ref={sendDropdownRef}>
              <Link
                to="/send"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('send');
                }}
              >
                {t('send')}
              </Link>
              <Link
                to="/scale"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('scale');
                }}
              >
                <TooltipLabel
                  label={t('scale')}
                  tooltipText={
                    <div>
                      <div className="tooltip-description">
                        {t('scaleTooltip')}
                      </div>
                    </div>
                  }
                  className="impact-label"
                />
              </Link>

            </div>
          )}
        </div>
        <div className="sliding-tab-indicator" />
      </div>
      <div className="swapmodal">
        <div
          className={`inputbg ${connected && amountIn > tokenBalances[tokenIn] && !txPending.current
            ? 'exceed-balance'
            : ''
            }`}
        >
          <div className="Pay">{t('pay')}</div>
          <div className="inputbutton1container">
            {displayValuesLoading &&
              switched == true &&
              !(inputString == '' && outputString == '') ? (
              <div className="output-skeleton" />
            ) : (
              <input
                inputMode="decimal"
                className={`input ${connected &&
                  amountIn > tokenBalances[tokenIn] && !txPending.current
                  ? 'exceed-balance'
                  : ''
                  }`}
                onCompositionStart={() => {
                  setIsComposing(true);
                }}
                onCompositionEnd={(
                  e: React.CompositionEvent<HTMLInputElement>,
                ) => {
                  setIsComposing(false);
                  if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                    setInputString(e.currentTarget.value);
                    if (
                      (inputString.endsWith('.') && e.currentTarget.value === inputString.slice(0, -1)) ||
                      (e.currentTarget.value.endsWith('.') && e.currentTarget.value.slice(0, -1) === inputString)
                    ) {
                      return;
                    }
                    const inputValue = BigInt(
                      Math.round(
                        (parseFloat(e.currentTarget.value || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    );
                    debouncedSetAmount(inputValue);
                    setswitched(false);
                    if (isWrap) {
                      setamountOutSwap(inputValue);
                      setoutputString(e.currentTarget.value);
                    }
                    const percentage = !tokenBalances[tokenIn]
                      ? 0
                      : Math.min(
                        100,
                        Math.floor(
                          Number(
                            (inputValue * BigInt(100)) /
                            tokenBalances[tokenIn],
                          ),
                        ),
                      );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                }}
                onChange={(e) => {
                  if (isComposing) {
                    setInputString(e.target.value);
                    return;
                  }
                  if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                    setInputString(e.target.value);
                    if (
                      (inputString.endsWith('.') && e.target.value === inputString.slice(0, -1)) ||
                      (e.target.value.endsWith('.') && e.target.value.slice(0, -1) === inputString)
                    ) {
                      return;
                    }
                    const inputValue = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    );
                    debouncedSetAmount(inputValue);
                    setswitched(false);
                    if (isWrap) {
                      setamountOutSwap(inputValue);
                      setoutputString(e.target.value);
                    }
                    const percentage = !tokenBalances[tokenIn]
                      ? 0
                      : Math.min(
                        100,
                        Math.floor(
                          Number(
                            (inputValue * BigInt(100)) /
                            tokenBalances[tokenIn],
                          ),
                        ),
                      );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                }}
                placeholder="0.00"
                value={inputString}
                autoFocus={
                  outputString === '' &&
                  switched === false &&
                  !(windowWidth <= 1020)
                }
              />
            )}
            <button
              className={`button1 ${connected &&
                amountIn > tokenBalances[tokenIn] && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onClick={() => {
                setpopup(1);
              }}
            >
              <img className="button1pic" src={tokendict[tokenIn].image} />
              <span>{tokendict[tokenIn].ticker || '?'}</span>
              <svg
                className={`button-arrow ${popup == 1 ? 'open' : ''}`}
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="16"
                height="16"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </button>
          </div>
          <div className="balance1maxcontainer">
            {displayValuesLoading &&
              switched == true &&
              !(inputString == '' && outputString == '') ? (
              <div className="output-usd-skeleton" />
            ) : (
              <span className="usd-value">
                {Math.round(
                  (parseFloat(inputString || '0') || 0) *
                  10 ** Number(tokendict[tokenIn].decimals),
                ) == 0
                  ? '$0.00'
                  : formatUSDDisplay(
                    calculateUSDValue(
                      BigInt(
                        Math.round(
                          (parseFloat(inputString || '0') || 0) *
                          10 ** Number(tokendict[tokenIn].decimals),
                        ),
                      ),
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                      ],
                      tokenIn,
                      getMarket(
                        activeMarket.path.at(0),
                        activeMarket.path.at(1),
                      ),
                    ),
                  )}
              </span>
            )}
            <div className="balance1">
              <img src={walleticon} className="balance-wallet-icon" />{' '}
              {formatSubscript(formatDisplayValue(
                tokenBalances[tokenIn],
                Number(tokendict[tokenIn].decimals),
              ))}
            </div>
            <div
              className="max-button"
              onClick={() => {
                if (tokenBalances[tokenIn] != BigInt(0)) {
                  let amount =
                    (tokenIn == eth && !client)
                      ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : tokenBalances[tokenIn];
                  debouncedSetAmount(BigInt(amount));
                  setswitched(false);
                  setInputString(
                    customRound(
                      Number(amount) /
                      10 ** Number(tokendict[tokenIn].decimals),
                      3,
                    ).toString(),
                  );
                  if (isWrap) {
                    setamountOutSwap(BigInt(amount));
                    setoutputString(
                      customRound(
                        Number(amount) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      ).toString(),
                    );
                  }
                  setSliderPercent(100);
                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    const trackWidth = rect.width - 15;
                    const thumbPosition = trackWidth + 15 / 2;
                    (popup as HTMLElement).style.left = `${thumbPosition}px`;
                  }
                }
              }}
            >
              {t('max')}{' '}
            </div>
          </div>
        </div>
        <div
          className="switch-button"
          onClick={() => {
            setTokenIn(tokenOut);
            setTokenOut(tokenIn);
            if (amountIn != BigInt(0) || amountOutSwap != BigInt(0)) {
              if (!isWrap) {
                if (switched == false) {
                  setswitched(true);
                  setStateIsLoading(true);
                  setInputString('');
                  setamountIn(BigInt(0));
                  setamountOutSwap(amountIn);
                  setoutputString(
                    amountIn == BigInt(0)
                      ? ''
                      : String(
                        customRound(
                          Number(amountIn) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ),
                      ),
                  );
                } else {
                  setswitched(false);
                  setStateIsLoading(true);
                  setoutputString('');
                  setamountOutSwap(BigInt(0));
                  setamountIn(amountOutSwap);
                  setInputString(
                    amountOutSwap == BigInt(0)
                      ? ''
                      : String(
                        customRound(
                          Number(amountOutSwap) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        ),
                      ),
                  );
                  const percentage = !tokenBalances[tokenOut]
                    ? 0
                    : Math.min(
                      100,
                      Math.floor(
                        Number(
                          (amountOutSwap * BigInt(100)) /
                          tokenBalances[tokenOut],
                        ),
                      ),
                    );
                  setSliderPercent(percentage);
                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    (popup as HTMLElement).style.left =
                      `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                  }
                }
              }
            }
          }}
        >
          <img src={tradearrow} className="switch-arrow" />
        </div>
        <div className="swap-container-divider" />
        <div className="outputbg">
          <div className="Recieve">{t('receive')}</div>
          <div className="outputbutton2container">
            {displayValuesLoading &&
              switched == false &&
              !(inputString == '' && outputString == '') ? (
              <div className="output-skeleton" />
            ) : (
              <input
                inputMode="decimal"
                className="output"
                onCompositionStart={() => {
                  setIsComposing(true);
                }}
                onCompositionEnd={(
                  e: React.CompositionEvent<HTMLInputElement>,
                ) => {
                  setIsComposing(false);
                  if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                    setoutputString(e.currentTarget.value);
                    if (
                      (outputString.endsWith('.') && e.currentTarget.value === outputString.slice(0, -1)) ||
                      (e.currentTarget.value.endsWith('.') && e.currentTarget.value.slice(0, -1) === outputString)
                    ) {
                      return;
                    }
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.currentTarget.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    );
                    if (isWrap) {
                      setamountIn(outputValue);
                      setInputString(e.currentTarget.value);
                    }
                    debouncedSetAmountOut(outputValue);
                    setswitched(true);
                  }
                }}
                onChange={(e) => {
                  if (isComposing) {
                    setoutputString(e.target.value);
                    return;
                  }
                  if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                    setoutputString(e.target.value);
                    if (
                      (outputString.endsWith('.') && e.target.value === outputString.slice(0, -1)) ||
                      (e.target.value.endsWith('.') && e.target.value.slice(0, -1) === outputString)
                    ) {
                      return;
                    }
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    );
                    if (isWrap) {
                      setamountIn(outputValue);
                      setInputString(e.target.value);
                    }
                    debouncedSetAmountOut(outputValue);
                    setswitched(true);
                  }
                }}
                value={outputString}
                placeholder="0.00"
              />
            )}
            <button
              className="button2"
              onClick={() => {
                setpopup(2);
              }}
            >
              <img className="button2pic" src={tokendict[tokenOut].image} />
              <span>{tokendict[tokenOut].ticker || '?'}</span>
              <svg
                className={`button-arrow ${popup == 2 ? 'open' : ''}`}
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="16"
                height="16"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </button>
          </div>
          <div className="balance1maxcontainer">
            {displayValuesLoading &&
              switched == false &&
              !(inputString == '' && outputString == '') ? (
              <div className="output-usd-skeleton" />
            ) : (
              <div className="output-usd-value">
                {amountOutSwap === BigInt(0)
                  ? '$0.00'
                  : (() => {
                    const outputUSD = calculateUSDValue(
                      BigInt(
                        Math.round(
                          (parseFloat(outputString || '0') || 0) *
                          10 ** Number(tokendict[tokenOut].decimals),
                        ),
                      ),
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(-2), activeMarket.path.at(-1)))
                      ],
                      tokenOut,
                      getMarket(
                        activeMarket.path.at(-2),
                        activeMarket.path.at(-1),
                      ),
                    );

                    const inputUSD = calculateUSDValue(
                      amountIn,
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                      ],
                      tokenIn,
                      getMarket(
                        activeMarket.path.at(0),
                        activeMarket.path.at(1),
                      ),
                    );

                    const percentageDiff =
                      inputUSD > 0
                        ? ((outputUSD - inputUSD) / inputUSD) * 100
                        : 0;

                    return (
                      <div className="output-usd-container">
                        <span>{formatUSDDisplay(outputUSD)}</span>
                        {inputUSD > 0 && !displayValuesLoading && !stateIsLoading && (
                          <span
                            className={`output-percentage ${percentageDiff >= 0 ? 'positive' : 'negative'}`}
                          >
                            ({percentageDiff >= 0 ? '+' : ''}
                            {percentageDiff.toFixed(2)}%)
                          </span>
                        )}
                      </div>
                    );
                  })()}
              </div>
            )}
            <div className="balance2">
              <img src={walleticon} className="balance-wallet-icon" />{' '}
              {formatSubscript(formatDisplayValue(
                tokenBalances[tokenOut],
                Number(tokendict[tokenOut].decimals),
              ))}
            </div>
          </div>
        </div>
        <div className="balance-slider-wrapper">
          {spotSliderMode === 'presets' ? (
            <div className="slider-container presets-mode">
              <div className="preset-buttons">
                {spotSliderPresets.map((preset: number, index: number) => (
                  <button
                    key={index}
                    className={`preset-button ${sliderPercent === preset ? 'active' : ''}`}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : tokenBalances[tokenIn]) *
                            BigInt(preset)) /
                          100n;
                        setSliderPercent(preset);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left = `${(rect.width - 15) * (preset / 100) + 15 / 2}px`;
                        }
                      }
                    }}
                    disabled={!connected}
                  >
                    {preset}%
                  </button>
                ))}
              </div>
            </div>
          ) : spotSliderMode === 'increment' ? (
            <div className="slider-container increment-mode">
              <button
                className="increment-button minus"
                onClick={() => {
                  if (connected && sliderPercent > 0) {
                    const newPercent = Math.max(0, sliderPercent - spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 0}
              >
                
              </button>
              <div className="increment-display">
                <div className="increment-amount">{spotSliderIncrement}%</div>
              </div>
              <button
                className="increment-button plus"
                onClick={() => {
                  if (connected && sliderPercent < 100) {
                    const newPercent = Math.min(100, sliderPercent + spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 100}
              >
                +
              </button>
            </div>
          ) : (
            <div className="slider-container slider-mode">
              <input
                type="range"
                className={`balance-amount-slider ${isDragging ? 'dragging' : ''}`}
                min="0"
                max="100"
                step="1"
                value={sliderPercent}
                disabled={!connected}
                onChange={(e) => {
                  const percent = parseInt(e.target.value);
                  const newAmount =
                    (((tokenIn == eth && !client)
                      ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : tokenBalances[tokenIn]) *
                      BigInt(percent)) /
                    100n;
                  setSliderPercent(percent);
                  setInputString(
                    newAmount == BigInt(0)
                      ? ''
                      : customRound(
                        Number(newAmount) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      ).toString(),
                  );
                  debouncedSetAmount(newAmount);
                  setswitched(false);
                  if (isWrap) {
                    setoutputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    setamountOutSwap(newAmount);
                  }
                  if (location.pathname.slice(1) === 'limit') {
                    setamountOutSwap(
                      limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                          : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                        : BigInt(0),
                    );
                    setoutputString(
                      (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                          : customRound(
                            Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                  }
                  const slider = e.target;
                  const rect = slider.getBoundingClientRect();
                  const trackWidth = rect.width - 15;
                  const thumbPosition = (percent / 100) * trackWidth + 15 / 2;
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) {
                    popup.style.left = `${thumbPosition}px`;
                  }
                }}
                onMouseDown={() => {
                  setIsDragging(true);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.add('visible');
                }}
                onMouseUp={() => {
                  setIsDragging(false);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.remove('visible');
                }}
                style={{
                  background: `linear-gradient(to right,rgb(171, 176, 224) ${sliderPercent}%,rgb(21, 21, 27, 1) ${sliderPercent}%)`,
                }}
              />
              <div className="slider-percentage-popup">{sliderPercent}%</div>
              <div className="balance-slider-marks">
                {[0, 25, 50, 75, 100].map((markPercent) => (
                  <span
                    key={markPercent}
                    className="balance-slider-mark"
                    data-active={sliderPercent >= markPercent}
                    data-percentage={markPercent}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : tokenBalances[tokenIn]) *
                            BigInt(markPercent)) /
                          100n;
                        setSliderPercent(markPercent);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup: HTMLElement | null = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          popup.style.left = `${(rect.width - 15) * (markPercent / 100) + 15 / 2
                            }px`;
                        }
                      }
                    }}
                  >
                    {markPercent}%
                  </span>
                ))}
              </div>
            </div>
          )}
        </div>
        <button
          className={`swap-button ${isSigning ? 'signing' : ''}`}
          onClick={async () => {
            if (connected && userchain === activechain) {
              if (warning == 1) {
                setpopup(13);
                const confirmed = await new Promise((resolve) => {
                  const handleConfirm = () => {
                    cleanup();
                    resolve(true);
                  };

                  const handleCancel = () => {
                    cleanup();
                    resolve(false);
                  };

                  const cleanup = () => {
                    window.removeEventListener('high-impact-confirm', handleConfirm);
                    window.removeEventListener('high-impact-cancel', handleCancel);
                  };

                  window.addEventListener('high-impact-confirm', handleConfirm);
                  window.addEventListener('high-impact-cancel', handleCancel);

                });
                if (!confirmed) return;
              }
              let hash: any;
              setIsSigning(true);
              if (client) {
                txPending.current = true;
              }
              try {
                if (tokenIn == eth && tokenOut == weth) {
                  hash = await sendUserOperationAsync({ uo: wrapeth(amountIn, weth) }, (rpcQueryData?.gasEstimate ?? 0n));
                  newTxPopup(
                    hash,
                    'wrap',
                    eth,
                    weth,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    '',
                    ''
                  );
                } else if (tokenIn == weth && tokenOut == eth) {
                  hash = await sendUserOperationAsync({ uo: unwrapeth(amountIn, weth) }, (rpcQueryData?.gasEstimate ?? 0n));
                  newTxPopup(
                    hash,
                    'unwrap',
                    weth,
                    eth,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    '',
                    ''
                  );
                } else if (tokenIn == eth && tokendict[tokenOut]?.lst == true && isStake) {
                  hash = await sendUserOperationAsync({ uo: stake(tokenOut, address, amountIn) }, (rpcQueryData?.gasEstimate ?? 0n) * 1100n / 1000n);
                  newTxPopup(
                    hash,
                    'stake',
                    eth,
                    tokenOut,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    '',
                    ''
                  );
                } else {
                  if (switched == false) {
                    if (tokenIn == eth) {
                      if (orderType == 1 || multihop) {
                        hash = await sendUserOperationAsync({
                          uo: swapExactETHForTokens(
                            router,
                            amountIn,
                            (amountOutSwap * slippage + 5000n) / 10000n,
                            activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                            address as `0x${string}`,
                            BigInt(Math.floor(Date.now() / 1000) + 900),
                            usedRefAddress as `0x${string}`
                          )
                        }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                      } else {
                        hash = await sendUserOperationAsync({
                          uo: _swap(
                            router,
                            amountIn,
                            activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                            activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                            true,
                            BigInt(0),
                            amountIn,
                            tokenIn == activeMarket.quoteAddress
                              ? (lowestAsk * 10000n + slippage / 2n) / slippage
                              : (highestBid * slippage + 5000n) / 10000n,
                            BigInt(Math.floor(Date.now() / 1000) + 900),
                            usedRefAddress as `0x${string}`
                          )
                        }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                      }
                    } else {
                      if (allowance < amountIn) {
                        if (client) {
                          let uo = []
                          uo.push(approve(
                            tokenIn as `0x${string}`,
                            router,
                            maxUint256
                          ))
                          if (tokenOut == eth) {
                            if (orderType == 1 || multihop) {
                              uo.push(swapExactTokensForETH(
                                router,
                                amountIn,
                                (amountOutSwap * slippage + 5000n) / 10000n,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            } else {
                              uo.push(_swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                true,
                                BigInt(0),
                                amountIn,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            }
                          } else {
                            if (orderType == 1 || multihop) {
                              uo.push(swapExactTokensForTokens(
                                router,
                                amountIn,
                                (amountOutSwap * slippage + 5000n) / 10000n,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            } else {
                              uo.push(_swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                true,
                                BigInt(0),
                                amountIn,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            }
                          }
                          hash = await sendUserOperationAsync({ uo: uo })
                          newTxPopup(
                            hash,
                            'approve',
                            tokenIn,
                            '',
                            customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn].decimals), 3),
                            0,
                            '',
                            router
                          );
                        }
                        else {
                          hash = await sendUserOperationAsync({
                            uo: approve(
                              tokenIn as `0x${string}`,
                              router,
                              maxUint256
                            )
                          })
                          newTxPopup(
                            hash,
                            'approve',
                            tokenIn,
                            '',
                            customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn].decimals), 3),
                            0,
                            '',
                            router
                          );
                        }
                      }
                      if (!client || !(allowance < amountIn)) {
                        if (tokenOut == eth) {
                          if (orderType == 1 || multihop) {
                            hash = await sendUserOperationAsync({
                              uo: swapExactTokensForETH(
                                router,
                                amountIn,
                                (amountOutSwap * slippage + 5000n) / 10000n,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          } else {
                            hash = await sendUserOperationAsync({
                              uo: _swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                true,
                                BigInt(0),
                                amountIn,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          }
                        } else {
                          if (orderType == 1 || multihop) {
                            hash = await sendUserOperationAsync({
                              uo: swapExactTokensForTokens(
                                router,
                                amountIn,
                                (amountOutSwap * slippage + 5000n) / 10000n,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          } else {
                            hash = await sendUserOperationAsync({
                              uo: _swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                true,
                                BigInt(0),
                                amountIn,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          }
                        }
                      }
                    }
                  } else {
                    if (tokenIn == eth) {
                      if (orderType == 1 || multihop) {
                        hash = await sendUserOperationAsync({
                          uo: swapETHForExactTokens(
                            router,
                            amountOutSwap,
                            (amountIn * 10000n + slippage / 2n) / slippage,
                            activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                            address as `0x${string}`,
                            BigInt(Math.floor(Date.now() / 1000) + 900),
                            usedRefAddress as `0x${string}`
                          )
                        }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                      } else {
                        hash = await sendUserOperationAsync({
                          uo: _swap(
                            router,
                            BigInt((amountIn * 10000n + slippage / 2n) / slippage),
                            activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                            activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                            false,
                            BigInt(0),
                            amountOutSwap,
                            tokenIn == activeMarket.quoteAddress
                              ? (lowestAsk * 10000n + slippage / 2n) / slippage
                              : (highestBid * slippage + 5000n) / 10000n,
                            BigInt(Math.floor(Date.now() / 1000) + 900),
                            usedRefAddress as `0x${string}`
                          )
                        }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                      }
                    } else {
                      if (allowance < amountIn) {
                        if (client) {
                          let uo = []
                          uo.push(approve(
                            tokenIn as `0x${string}`,
                            router,
                            maxUint256
                          ))
                          if (tokenOut == eth) {
                            if (orderType == 1 || multihop) {
                              uo.push(swapTokensForExactETH(
                                router,
                                amountOutSwap,
                                (amountIn * 10000n + slippage / 2n) / slippage,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            } else {
                              uo.push(_swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                false,
                                BigInt(0),
                                amountOutSwap,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            }
                          } else {
                            if (orderType == 1 || multihop) {
                              uo.push(swapTokensForExactTokens(
                                router,
                                amountOutSwap,
                                (amountIn * 10000n + slippage / 2n) / slippage,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            } else {
                              uo.push(_swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                false,
                                BigInt(0),
                                amountOutSwap,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            }
                          }
                          hash = await sendUserOperationAsync({ uo: uo })
                          newTxPopup(
                            hash,
                            'approve',
                            tokenIn,
                            '',
                            customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn].decimals), 3),
                            0,
                            '',
                            router
                          );
                        }
                        else {
                          hash = await sendUserOperationAsync({
                            uo: approve(
                              tokenIn as `0x${string}`,
                              router,
                              maxUint256
                            )
                          })
                          newTxPopup(
                            hash,
                            'approve',
                            tokenIn,
                            '',
                            customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn].decimals), 3),
                            0,
                            '',
                            router
                          );
                        }
                      }
                      if (!client || !(allowance < amountIn)) {
                        if (tokenOut == eth) {
                          if (orderType == 1 || multihop) {
                            hash = await sendUserOperationAsync({
                              uo: swapTokensForExactETH(
                                router,
                                amountOutSwap,
                                (amountIn * 10000n + slippage / 2n) / slippage,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          } else {
                            hash = await sendUserOperationAsync({
                              uo: _swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                false,
                                BigInt(0),
                                amountOutSwap,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          }
                        } else {
                          if (orderType == 1 || multihop) {
                            hash = await sendUserOperationAsync({
                              uo: swapTokensForExactTokens(
                                router,
                                amountOutSwap,
                                (amountIn * 10000n + slippage / 2n) / slippage,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          } else {
                            hash = await sendUserOperationAsync({
                              uo: _swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                false,
                                BigInt(0),
                                amountOutSwap,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          }
                        }
                      }
                    }
                  }
                }
                if (!client) {
                  txPending.current = true
                }
                setswitched(false);
                setInputString('');
                setamountIn(BigInt(0));
                setoutputString('')
                setamountOutSwap(BigInt(0));
                setSliderPercent(0);
                setSwapButtonDisabled(true);
                setSwapButton(1);
                setIsSigning(false)
                const slider = document.querySelector('.balance-amount-slider');
                const popup = document.querySelector('.slider-percentage-popup');
                if (slider && popup) {
                  (popup as HTMLElement).style.left = `${15 / 2}px`;
                }
                await refetch()
                txPending.current = false
              } catch (error) {
                if (!(error instanceof TransactionExecutionError)) {
                  newTxPopup(
                    hash,
                    "swapFailed",
                    tokenIn == eth ? eth : tokenIn,
                    tokenOut == eth ? eth : tokenOut,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn == eth ? eth : tokenIn].decimals), 3),
                    customRound(Number(amountOutSwap) / 10 ** Number(tokendict[tokenOut == eth ? eth : tokenOut].decimals), 3),
                    "",
                    "",
                  );
                }
              } finally {
                txPending.current = false
                setIsSigning(false)
              }
            } else {
              !connected ? setpopup(4) : handleSetChain();
            }
          }}
          disabled={swapButtonDisabled || displayValuesLoading || isSigning}
        >
          {isSigning ? (
            <div className="button-content">
              <div className="loading-spinner" />
              {validOneCT ? t('') : t('signTransaction')}
            </div>
          ) : swapButton == 0 ? (
            t('insufficientLiquidity')
          ) : swapButton == 1 ? (
            t('enterAmount')
          ) : swapButton == 2 ? (
            t('swap')
          ) : swapButton == 3 ? (
            t('insufficient') +
            (tokendict[tokenIn].ticker || '?') +
            ' ' +
            t('bal')
          ) : swapButton == 4 ? (
            `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
          ) : swapButton == 5 ? (
            t('connectWallet')
          ) : (
            client ? t('swap') : t('approve')
          )}
        </button>
      </div>
      <div className="trade-info-rectangle">
        {(tokenIn == eth && tokendict[tokenOut]?.lst == true) && <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={t('stake')}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {t('stakeSubtitle')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <ToggleSwitch
            checked={isStake}
            onChange={() => {
              const newValue = isStake == true ? false : true;
              setIsStake(newValue);
            }}
          />
        </div>}
        {!multihop && !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) && (
          <div className="trade-fee">
            <div className="label-container">
              <TooltipLabel
                label={t('partialFill')}
                tooltipText={
                  <div>
                    <div className="tooltip-description">
                      {t('partialFillSubtitle')}
                    </div>
                  </div>
                }
                className="impact-label"
              />
            </div>
            <ToggleSwitch
              checked={orderType === 0}
              onChange={() => {
                const newValue = orderType === 1 ? 0 : 1;
                setorderType(newValue);
                localStorage.setItem(
                  'crystal_order_type',
                  JSON.stringify(newValue),
                );
              }}
            />
          </div>
        )}

        {!isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) && (
          <div className="slippage-row">
            <div className="label-container">
              <div className="slippage-group">
                <TooltipLabel
                  label={t('slippage')}
                  tooltipText={
                    <div>
                      <div className="tooltip-description">
                        {t('slippageHelp')}
                      </div>
                    </div>
                  }
                  className="slippage-label"
                />
              </div>
            </div>
            <div className="slippage-input-container">
              <input
                inputMode="decimal"
                className={`slippage-inline-input ${parseFloat(slippageString) > 5 ? 'red' : ''
                  }`}
                type="text"
                value={slippageString}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    (e.target as HTMLInputElement).blur()
                    e.stopPropagation()
                  };
                }}
                onChange={(e) => {
                  const value = e.target.value;

                  if (
                    /^(?!0{2})\d*\.?\d{0,2}$/.test(value) &&
                    !/^\d{2}\.\d{2}$/.test(value)
                  ) {
                    if (value === '') {
                      setSlippageString('');
                      setSlippage(BigInt(9900));
                      localStorage.setItem('crystal_slippage_string', '1');
                      localStorage.setItem('crystal_slippage', '9900');
                    } else if (parseFloat(value) <= 50) {
                      setSlippageString(value);
                      localStorage.setItem('crystal_slippage_string', value);

                      const newSlippage = BigInt(
                        10000 - parseFloat(value) * 100,
                      );
                      setSlippage(newSlippage);
                      localStorage.setItem(
                        'crystal_slippage',
                        newSlippage.toString(),
                      );
                    }
                  }
                }}
                onBlur={() => {
                  if (slippageString === '') {
                    setSlippageString('1');
                    localStorage.setItem('crystal_slippage_string', '1');

                    setSlippage(BigInt(9900));
                    localStorage.setItem('crystal_slippage', '9900');
                  }
                }}
              />
              <span
                className={`slippage-symbol ${parseFloat(slippageString) > 5 ? 'red' : ''
                  }`}
              >
                %
              </span>
            </div>
          </div>
        )}

        {!isWrap && (
          <div className="average-price">
            <div className="label-container">
              <TooltipLabel
                label={t('averagePrice')}
                tooltipText={
                  <div>
                    <div className="tooltip-description">
                      {t('averagePriceHelp')}
                    </div>
                  </div>
                }
                className="impact-label"
              />
            </div>
            <div className="value-container">
              {displayValuesLoading ? (
                <div className="limit-fee-skeleton" style={{ width: 80 }} />
              ) : isWrap ? (
                `1 ${tokendict[tokenOut].ticker}`
              ) : (
                `${formatSubscript(averagePrice)} ${multihop ? tokendict[tokenIn].ticker : activeMarket.quoteAsset}`
              )}
            </div>
          </div>
        )}

        <div className="price-impact">
          <div className="label-container">
            <TooltipLabel
              label={t('priceImpact')}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {t('priceImpactHelp')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <div className="value-container">
            {displayValuesLoading ? (
              <div className="limit-fee-skeleton" style={{ width: 60 }} />
            ) : isWrap || ((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) ? (
              `0%`
            ) : priceImpact ? (
              formatCommas(priceImpact)
            ) : (
              '0.00%'
            )}
          </div>
        </div>

        <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={`${t('fee')} (0.${isWrap || ((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) ? '00' : String(Number(BigInt(100000) - activeMarket.fee) / 100).replace(/\./g, "")}%)`}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {isWrap ? t('nofeeforwrap') : t('takerfeeexplanation')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <div className="value-container">
            {displayValuesLoading ? (
              <div className="limit-fee-skeleton" style={{ width: 70 }} />
            ) : isWrap || ((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) ? (
              `0 ${tokendict[tokenIn].ticker}`
            ) : (
              formatCommas(tradeFee)
            )}
          </div>
        </div>

        {(warning == 1 && (
          <div className="price-impact-warning">{t('Warning')}</div>
        )) ||
          (warning == 2 && (
            <div className="price-impact-warning">
              {t('insufficientLiquidityWarning')}
            </div>
          )) ||
          (warning == 3 && (
            <div className="price-impact-warning">
              {t('insufficientLiquidityWarningMultihop')}
            </div>
          ))}
      </div>
    </div>
  );

  // limit ui component
  const limit = (
    <div className="rectangle">
      <div className="navlinkwrapper" data-active={location.pathname.slice(1)} onClick={() => {
        if (windowWidth <= 1020 && !simpleView && !showTrade) {
          setShowTrade(true);
          document.querySelector('.trade-mobile-switch')?.classList.add('open');
        }
      }}>
        <div className="innernavlinkwrapper">
          <Link
            to={simpleView ? "/swap" : "/market"}
            className={`navlink ${location.pathname.slice(1) === 'swap' ? 'active' : ''}`}
          >
            {simpleView ? t('swap') : t('market')}
          </Link>
          <Link
            to="/limit"
            className={`navlink ${location.pathname.slice(1) === 'limit' ? 'active' : ''}`}
            onClick={(e) => {
              if (location.pathname === '/limit') {
                e.preventDefault();
              }
            }}
          >
            {t('limit')}
          </Link>
          <span
            ref={(el: HTMLSpanElement | null) => {
              sendButtonRef.current = el;
            }}
            className={`navlink ${location.pathname.slice(1) != 'swap' && location.pathname.slice(1) != 'limit' ? 'active' : ''}`}
            onClick={(e: React.MouseEvent) => {
              e.preventDefault();
              setShowSendDropdown(!showSendDropdown);
            }}
          >
            <span className="current-pro-text">{t(currentProText)}</span>
            <svg
              className={`dropdown-arrow ${showSendDropdown ? 'open' : ''}`}
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="12"
              height="12"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            >
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </span>

          {showSendDropdown && (
            <div className="navlink-dropdown" ref={sendDropdownRef}>
              <Link
                to="/send"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('send');
                }}
              >
                {t('send')}
              </Link>
              <Link
                to="/scale"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('scale');
                }}
              >
                <TooltipLabel
                  label={t('scale')}
                  tooltipText={
                    <div>
                      <div className="tooltip-description">
                        {t('scaleTooltip')}
                      </div>
                    </div>
                  }
                  className="impact-label"
                />
              </Link>

            </div>
          )}
        </div>
        <div className="sliding-tab-indicator" />
      </div>
      <div className="swapmodal">
        <div
          className={`inputbg ${connected &&
            ((amountIn > tokenBalances[tokenIn]) ||
              (amountIn != BigInt(0) &&
                (tokenIn == activeMarket.quoteAddress
                  ? amountIn < activeMarket.minSize
                  : (amountIn * limitPrice) / activeMarket.scaleFactor <
                  activeMarket.minSize))) && !txPending.current
            ? 'exceed-balance'
            : ''
            }`}
        >
          <div className="Pay">{t('pay')}</div>
          <div className="inputbutton1container">
            <input
              inputMode="decimal"
              className={`input ${connected &&
                ((amountIn > tokenBalances[tokenIn]) ||
                  (amountIn !== BigInt(0) &&
                    (tokenIn === activeMarket.quoteAddress
                      ? amountIn < activeMarket.minSize
                      : (amountIn * limitPrice) / activeMarket.scaleFactor <
                      activeMarket.minSize))) && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onCompositionStart={() => {
                setIsComposing(true);
              }}
              onCompositionEnd={(
                e: React.CompositionEvent<HTMLInputElement>,
              ) => {
                setIsComposing(false);
                if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                  setInputString(e.currentTarget.value);
                  if (
                    (inputString.endsWith('.') && e.currentTarget.value === inputString.slice(0, -1)) ||
                    (e.currentTarget.value.endsWith('.') && e.currentTarget.value.slice(0, -1) === inputString)
                  ) {
                    return;
                  }
                  const inputValue = BigInt(
                    Math.round(
                      (parseFloat(e.currentTarget.value || '0') || 0) *
                      10 ** Number(tokendict[tokenIn].decimals),
                    ),
                  );

                  setamountOutSwap(
                    limitPrice !== BigInt(0) && inputValue !== BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? (inputValue * limitPrice) /
                        (activeMarket.scaleFactor || BigInt(1))
                        : (inputValue *
                          (activeMarket.scaleFactor || BigInt(1))) /
                        limitPrice
                      : BigInt(0),
                  );

                  setoutputString(
                    (limitPrice !== BigInt(0) && inputValue !== BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? customRound(
                          Number(
                            (inputValue * limitPrice) /
                            (activeMarket.scaleFactor || BigInt(1)),
                          ) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        )
                        : customRound(
                          Number(
                            (inputValue *
                              (activeMarket.scaleFactor || BigInt(1))) /
                            limitPrice,
                          ) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        )
                      : ''
                    ).toString(),
                  );

                  debouncedSetAmount(inputValue);
                  setswitched(false);

                  const percentage = !tokenBalances[tokenIn]
                    ? 0
                    : Math.min(
                      100,
                      Math.floor(
                        Number(
                          (inputValue * BigInt(100)) / tokenBalances[tokenIn],
                        ),
                      ),
                    );
                  setSliderPercent(percentage);

                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    (popup as HTMLElement).style.left =
                      `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                  }
                }
              }}
              onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                if (isComposing) {
                  setInputString(e.target.value);
                  return;
                }

                if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                  setInputString(e.target.value);
                  if (
                    (inputString.endsWith('.') && e.target.value === inputString.slice(0, -1)) ||
                    (e.target.value.endsWith('.') && e.target.value.slice(0, -1) === inputString)
                  ) {
                    return;
                  }
                  const inputValue = BigInt(
                    Math.round(
                      (parseFloat(e.target.value || '0') || 0) *
                      10 ** Number(tokendict[tokenIn].decimals),
                    ),
                  );

                  setamountOutSwap(
                    limitPrice !== BigInt(0) && inputValue !== BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? (inputValue * limitPrice) /
                        (activeMarket.scaleFactor || BigInt(1))
                        : (inputValue *
                          (activeMarket.scaleFactor || BigInt(1))) /
                        limitPrice
                      : BigInt(0),
                  );

                  setoutputString(
                    (limitPrice !== BigInt(0) && inputValue !== BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? customRound(
                          Number(
                            (inputValue * limitPrice) /
                            (activeMarket.scaleFactor || BigInt(1)),
                          ) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        )
                        : customRound(
                          Number(
                            (inputValue *
                              (activeMarket.scaleFactor || BigInt(1))) /
                            limitPrice,
                          ) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        )
                      : ''
                    ).toString(),
                  );

                  debouncedSetAmount(inputValue);
                  setswitched(false);

                  const percentage = !tokenBalances[tokenIn]
                    ? 0
                    : Math.min(
                      100,
                      Math.floor(
                        Number(
                          (inputValue * BigInt(100)) / tokenBalances[tokenIn],
                        ),
                      ),
                    );
                  setSliderPercent(percentage);

                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    (popup as HTMLElement).style.left =
                      `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                  }
                }
              }}
              placeholder="0.00"
              value={inputString}
              autoFocus={!(windowWidth <= 1020)}
            />
            <button
              className={`button1 ${connected &&
                ((amountIn > tokenBalances[tokenIn]) ||
                  (amountIn != BigInt(0) &&
                    (tokenIn == activeMarket.quoteAddress
                      ? amountIn < activeMarket.minSize
                      : (amountIn * limitPrice) / activeMarket.scaleFactor <
                      activeMarket.minSize))) && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onClick={() => {
                setpopup(1);
              }}
            >
              <img className="button1pic" src={tokendict[tokenIn].image} />
              <span>{tokendict[tokenIn].ticker || '?'}</span>
              <svg
                className={`button-arrow ${popup == 1 ? 'open' : ''}`}
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="16"
                height="16"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </button>
          </div>
          <div className="balance1maxcontainer">
            <span className="usd-value">
              {Math.round(
                (parseFloat(inputString || '0') || 0) *
                10 ** Number(tokendict[tokenIn].decimals),
              ) == 0
                ? '$0.00'
                : formatUSDDisplay(
                  calculateUSDValue(
                    BigInt(
                      Math.round(
                        (parseFloat(inputString || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    ),
                    tradesByMarket[
                    (({ baseAsset, quoteAsset }) =>
                      (baseAsset === wethticker ? ethticker : baseAsset) +
                      (quoteAsset === wethticker ? ethticker : quoteAsset)
                    )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                    ],
                    tokenIn,
                    getMarket(
                      activeMarket.path.at(0),
                      activeMarket.path.at(1),
                    ),
                  ),
                )}
            </span>
            <div className="balance1">
              <img src={walleticon} className="balance-wallet-icon" />{' '}
              {formatSubscript(formatDisplayValue(
                tokenBalances[tokenIn],
                Number(tokendict[tokenIn].decimals),
              ))}
            </div>
            <div
              className="max-button"
              onClick={() => {
                if (tokenBalances[tokenIn] != BigInt(0)) {
                  let amount =
                    (tokenIn == eth && !client)
                      ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : tokenBalances[tokenIn];
                  setamountIn(BigInt(amount));
                  setswitched(false);
                  setInputString(
                    customRound(
                      Number(amount) /
                      10 ** Number(tokendict[tokenIn].decimals),
                      3,
                    ).toString(),
                  );
                  setamountOutSwap(
                    limitPrice != BigInt(0) && amount != BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? (amount * limitPrice) /
                        (activeMarket.scaleFactor || BigInt(1))
                        : (BigInt(amount) *
                          (activeMarket.scaleFactor || BigInt(1))) /
                        limitPrice
                      : BigInt(0),
                  );
                  setoutputString(
                    (limitPrice != BigInt(0) && amount != BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? customRound(
                          Number(
                            (amount * limitPrice) /
                            (activeMarket.scaleFactor || BigInt(1)),
                          ) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        )
                        : customRound(
                          Number(
                            (BigInt(amount) *
                              (activeMarket.scaleFactor || BigInt(1))) /
                            limitPrice,
                          ) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        )
                      : ''
                    ).toString(),
                  );
                  setSliderPercent(100);
                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    const trackWidth = rect.width - 15;
                    const thumbPosition = trackWidth + 15 / 2;
                    (popup as HTMLElement).style.left = `${thumbPosition}px`;
                  }
                }
              }}
            >
              {t('max')}{' '}
            </div>
          </div>
        </div>
        <div
          className="switch-button"
          onClick={() => {
            setTokenIn(tokenOut);
            setTokenOut(tokenIn);
            setswitched((switched) => { return !switched });
            if (amountIn != BigInt(0)) {
              if (limitChase && mids?.[activeMarketKey]?.[0]) {
                const price = tokenOut === activeMarket?.baseAddress ? mids[activeMarketKey][0] == mids[activeMarketKey][1] ? mids[activeMarketKey][2] : mids[activeMarketKey][0] : mids[activeMarketKey][0] == mids[activeMarketKey][2] ? mids[activeMarketKey][1] : mids[activeMarketKey][0]
                setlimitPrice(price);
                setlimitPriceString(
                  (
                    Number(price) / Number(activeMarket.priceFactor)
                  ).toFixed(Math.floor(Math.log10(activeMarket?.marketType != 0 ? Math.min(10 ** Math.max(0, 5 - Math.floor(Math.log10((Number(price) / Number(activeMarket.priceFactor)) || 1)) - 1), Number(activeMarket.priceFactor)) : Number(activeMarket.priceFactor)))),
                );
                setamountOutSwap(
                  price != BigInt(0) && amountIn != BigInt(0)
                    ? tokenOut === activeMarket?.baseAddress
                      ? (amountIn * price) /
                      (activeMarket.scaleFactor || BigInt(1))
                      : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                      price
                    : BigInt(0),
                );
                setoutputString(
                  (price != BigInt(0) && amountIn != BigInt(0)
                    ? tokenOut === activeMarket?.baseAddress
                      ? customRound(
                        Number(
                          (amountIn * price) /
                          (activeMarket.scaleFactor || BigInt(1)),
                        ) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      )
                      : customRound(
                        Number(
                          (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                          price,
                        ) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      )
                    : ''
                  ).toString(),
                );
              }
              setInputString(outputString);
              setoutputString(inputString);
              setamountIn(amountOutSwap);
              setamountOutSwap(amountIn);
              const percentage = !tokenBalances[tokenOut]
                ? 0
                : Math.min(
                  100,
                  Math.floor(
                    Number(
                      (amountOutSwap * BigInt(100)) /
                      tokenBalances[tokenOut],
                    ),
                  ),
                );
              setSliderPercent(percentage);
              const slider = document.querySelector('.balance-amount-slider');
              const popup = document.querySelector('.slider-percentage-popup');
              if (slider && popup) {
                const rect = slider.getBoundingClientRect();
                (popup as HTMLElement).style.left =
                  `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
              }
            }
          }}
        >
          <img src={tradearrow} className="switch-arrow" />
        </div>
        <div className="swap-container-divider" />
        <div className="outputbg">
          <div className="Recieve">{t('receive')}</div>
          <div className="outputbutton2container">
            <>
              <input
                inputMode="decimal"
                className="output"
                onCompositionStart={() => {
                  setIsComposing(true);
                }}
                onCompositionEnd={(
                  e: React.CompositionEvent<HTMLInputElement>,
                ) => {
                  setIsComposing(false);
                  if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                    setoutputString(e.currentTarget.value);
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.currentTarget.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    );
                    setamountOutSwap(outputValue);
                    setswitched(true);
                    setamountIn(
                      limitPrice !== BigInt(0) && outputValue !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (outputValue *
                            (activeMarket.scaleFactor || BigInt(1))) /
                          limitPrice
                          : (outputValue * limitPrice) /
                          (activeMarket.scaleFactor || BigInt(1))
                        : BigInt(0),
                    );
                    setInputString(
                      (limitPrice !== BigInt(0) && outputValue !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number(
                              (outputValue *
                                (activeMarket.scaleFactor || BigInt(1))) /
                              limitPrice,
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                          : customRound(
                            Number(
                              (outputValue * limitPrice) /
                              (activeMarket.scaleFactor || BigInt(1)),
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                    const percentage =
                      tokenBalances[tokenIn] === BigInt(0)
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (limitPrice !== BigInt(0) &&
                                outputValue !== BigInt(0)
                                ? tokenIn === activeMarket?.baseAddress
                                  ? (outputValue *
                                    (activeMarket.scaleFactor ||
                                      BigInt(1))) /
                                  limitPrice
                                  : (outputValue * limitPrice) /
                                  (activeMarket.scaleFactor || BigInt(1))
                                : BigInt(0)) * BigInt(100),
                            ) / tokenBalances[tokenIn],
                          ),
                        );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                }}
                onChange={(e) => {
                  if (isComposing) {
                    setoutputString(e.target.value);
                    return;
                  }
                  if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                    setoutputString(e.target.value);
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    );
                    setamountOutSwap(outputValue);
                    setswitched(true);
                    setamountIn(
                      limitPrice !== BigInt(0) && outputValue !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (outputValue *
                            (activeMarket.scaleFactor || BigInt(1))) /
                          limitPrice
                          : (outputValue * limitPrice) /
                          (activeMarket.scaleFactor || BigInt(1))
                        : BigInt(0),
                    );
                    setInputString(
                      (limitPrice !== BigInt(0) && outputValue !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number(
                              (outputValue *
                                (activeMarket.scaleFactor || BigInt(1))) /
                              limitPrice,
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                          : customRound(
                            Number(
                              (outputValue * limitPrice) /
                              (activeMarket.scaleFactor || BigInt(1)),
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                    const percentage =
                      tokenBalances[tokenIn] === BigInt(0)
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (limitPrice !== BigInt(0) &&
                                outputValue !== BigInt(0)
                                ? tokenIn === activeMarket?.baseAddress
                                  ? (outputValue *
                                    (activeMarket.scaleFactor ||
                                      BigInt(1))) /
                                  limitPrice
                                  : (outputValue * limitPrice) /
                                  (activeMarket.scaleFactor || BigInt(1))
                                : BigInt(0)) * BigInt(100) / tokenBalances[tokenIn]
                            )
                          ),
                        );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                }}
                value={outputString}
                placeholder="0.00"
              />
              <button
                className="button2"
                onClick={() => {
                  setpopup(2);
                }}
              >
                <img className="button2pic" src={tokendict[tokenOut].image} />
                <span>{tokendict[tokenOut].ticker || '?'}</span>
                <svg
                  className={`button-arrow ${popup == 2 ? 'open' : ''}`}
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  width="16"
                  height="16"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
              </button>
            </>
          </div>
          <div className="balance1maxcontainer">
            <div className="output-usd-value">
              {amountOutSwap === BigInt(0)
                ? '$0.00'
                : (() => {
                  const outputUSD = calculateUSDValue(
                    amountOutSwap,
                    tradesByMarket[
                    (({ baseAsset, quoteAsset }) =>
                      (baseAsset === wethticker ? ethticker : baseAsset) +
                      (quoteAsset === wethticker ? ethticker : quoteAsset)
                    )(getMarket(activeMarket.path.at(-2), activeMarket.path.at(-1)))
                    ],
                    tokenOut,
                    getMarket(
                      activeMarket.path.at(-2),
                      activeMarket.path.at(-1),
                    ),
                  );

                  const inputUSD = calculateUSDValue(
                    limitPrice != BigInt(0) && amountOutSwap != BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? (amountOutSwap *
                          (activeMarket.scaleFactor || BigInt(1))) /
                        limitPrice
                        : (amountOutSwap * limitPrice) /
                        (activeMarket.scaleFactor || BigInt(1))
                      : BigInt(0),
                    tradesByMarket[
                    (({ baseAsset, quoteAsset }) =>
                      (baseAsset === wethticker ? ethticker : baseAsset) +
                      (quoteAsset === wethticker ? ethticker : quoteAsset)
                    )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                    ],
                    tokenIn,
                    getMarket(
                      activeMarket.path.at(0),
                      activeMarket.path.at(1),
                    ),
                  );

                  const percentageDiff =
                    inputUSD > 0
                      ? ((outputUSD - inputUSD) / inputUSD) * 100
                      : 0;

                  return (
                    <div className="output-usd-container">
                      <span>{formatUSDDisplay(outputUSD)}</span>
                      {inputUSD > 0 && (
                        <span
                          className={`output-percentage ${percentageDiff >= 0 ? 'positive' : 'negative'}`}
                        >
                          ({percentageDiff >= 0 ? '+' : ''}
                          {percentageDiff.toFixed(2)}%)
                        </span>
                      )}
                    </div>
                  );
                })()}
            </div>
            <div className="balance2">
              <img src={walleticon} className="balance-wallet-icon" />{' '}
              {formatSubscript(formatDisplayValue(
                tokenBalances[tokenOut],
                Number(tokendict[tokenOut].decimals),
              ))}
            </div>
          </div>
        </div>
        <div className="swap-container-divider" />
        <div
          className={`limitbg ${connected &&
            !(
              amountIn > tokenBalances[tokenIn]) &&
            addliquidityonly &&
            amountIn != BigInt(0) &&
            ((limitPrice >= lowestAsk &&
              tokenIn == activeMarket.quoteAddress) ||
              (limitPrice <= highestBid &&
                tokenIn == activeMarket.baseAddress)) &&
            !(tokenIn == activeMarket.quoteAddress
              ? amountIn < activeMarket.minSize
              : (amountIn * limitPrice) / activeMarket.scaleFactor <
              activeMarket.minSize) && !txPending.current
            ? 'exceed-balance'
            : ''
            }`}
        >
          <div className="limit-label">
            <span>{t('When')}</span>
            <button
              className="limit-token-button"
              onClick={() => {
                tokenIn == activeMarket?.quoteAddress
                  ? setpopup(2)
                  : setpopup(1);
              }}
            >
              <img
                className="limit-token-icon"
                src={tokendict[activeMarket?.baseAddress].image}
              />
              <span>{tokendict[activeMarket?.baseAddress].ticker || '?'}</span>
            </button>
            <span>{t('isWorth')}</span>
            <button
              className="use-market-button"
              onClick={() => {
                setlimitChase(true);
              }}
            >
              {t('useMarket')}
            </button>
          </div>
          <div className="limitpricecontainer">
            <input
              inputMode="decimal"
              className={`limit-order ${connected &&
                !(
                  amountIn > tokenBalances[tokenIn]) &&
                addliquidityonly &&
                amountIn != BigInt(0) &&
                ((limitPrice >= lowestAsk &&
                  tokenIn == activeMarket.quoteAddress) ||
                  (limitPrice <= highestBid &&
                    tokenIn == activeMarket.baseAddress)) &&
                !(tokenIn == activeMarket.quoteAddress
                  ? amountIn < activeMarket.minSize
                  : (amountIn * limitPrice) / activeMarket.scaleFactor <
                  activeMarket.minSize) && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onFocus={() => setIsLimitEditing(true)}
              onBlur={() => setIsLimitEditing(false)}
              onCompositionStart={() => {
                setIsComposing(true);
              }}
              onCompositionEnd={(
                e: React.CompositionEvent<HTMLInputElement>,
              ) => {
                setIsComposing(false);
                if (
                  new RegExp(
                    `^\\d*\\.?\\d{0,${Math.floor(Math.log10(Number(activeMarket.priceFactor)))}}$`
                  ).test(e.currentTarget.value) && (activeMarket?.marketType != 0 ? e.currentTarget.value.replace(/^0+|\.|e.*$/gi, '').replace(/^0+/, '').replace(/0+$/, match => '').length <= 5 : true)
                ) {
                  setlimitChase(false);
                  setlimitPriceString(e.currentTarget.value);
                  let price = BigInt(
                    Math.round(
                      (parseFloat(e.currentTarget.value || '0') || 0) *
                      Number(activeMarket.priceFactor)
                    )
                  );
                  setlimitPrice(price);
                  if (switched) {
                    setamountIn(
                      price !== BigInt(0) && amountOutSwap !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (amountOutSwap *
                            (activeMarket.scaleFactor || BigInt(1))) /
                          price
                          : (amountOutSwap * price) /
                          (activeMarket.scaleFactor || BigInt(1))
                        : BigInt(0),
                    );
                    setInputString(
                      (price !== BigInt(0) && amountOutSwap !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number(
                              (amountOutSwap *
                                (activeMarket.scaleFactor || BigInt(1))) /
                              price,
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                          : customRound(
                            Number(
                              (amountOutSwap * price) /
                              (activeMarket.scaleFactor || BigInt(1)),
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                    const percentage =
                      tokenBalances[tokenIn] === BigInt(0)
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (price !== BigInt(0) &&
                                amountOutSwap !== BigInt(0)
                                ? tokenIn === activeMarket?.baseAddress
                                  ? (amountOutSwap *
                                    (activeMarket.scaleFactor ||
                                      BigInt(1))) /
                                  price
                                  : (amountOutSwap * price) /
                                  (activeMarket.scaleFactor || BigInt(1))
                                : BigInt(0)) * BigInt(100) / tokenBalances[tokenIn]
                            )
                          ),
                        );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                  else {
                    setamountOutSwap(
                      price != BigInt(0) && amountIn != BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (amountIn * price) /
                          (activeMarket.scaleFactor || BigInt(1))
                          : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                          price
                        : BigInt(0)
                    );
                    setoutputString(
                      (
                        price != BigInt(0) && amountIn != BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number(
                                (amountIn * price) /
                                (activeMarket.scaleFactor || BigInt(1))
                              ) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3
                            )
                            : customRound(
                              Number(
                                (amountIn *
                                  (activeMarket.scaleFactor || BigInt(1))) /
                                price
                              ) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3
                            )
                          : ''
                      ).toString()
                    );
                  }
                }
              }}
              onChange={(e) => {
                if (isComposing) {
                  setlimitPriceString(e.target.value);
                  return;
                }
                if (
                  new RegExp(
                    `^\\d*\\.?\\d{0,${Math.floor(Math.log10(Number(activeMarket.priceFactor)))}}$`
                  ).test(e.target.value) && (activeMarket?.marketType != 0 ? e.target.value.replace(/^0+|\.|e.*$/gi, '').replace(/^0+/, '').replace(/0+$/, match => '').length <= 5 : true)
                ) {
                  setlimitChase(false);
                  setlimitPriceString(e.target.value);
                  let price = BigInt(
                    Math.round(
                      (parseFloat(e.target.value || '0') || 0) *
                      Number(activeMarket.priceFactor)
                    )
                  );
                  setlimitPrice(price);
                  if (switched) {
                    setamountIn(
                      price !== BigInt(0) && amountOutSwap !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (amountOutSwap *
                            (activeMarket.scaleFactor || BigInt(1))) /
                          price
                          : (amountOutSwap * price) /
                          (activeMarket.scaleFactor || BigInt(1))
                        : BigInt(0),
                    );
                    setInputString(
                      (price !== BigInt(0) && amountOutSwap !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number(
                              (amountOutSwap *
                                (activeMarket.scaleFactor || BigInt(1))) /
                              price,
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                          : customRound(
                            Number(
                              (amountOutSwap * price) /
                              (activeMarket.scaleFactor || BigInt(1)),
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                    const percentage =
                      tokenBalances[tokenIn] === BigInt(0)
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (price !== BigInt(0) &&
                                amountOutSwap !== BigInt(0)
                                ? tokenIn === activeMarket?.baseAddress
                                  ? (amountOutSwap *
                                    (activeMarket.scaleFactor ||
                                      BigInt(1))) /
                                  price
                                  : (amountOutSwap * price) /
                                  (activeMarket.scaleFactor || BigInt(1))
                                : BigInt(0)) * BigInt(100) / tokenBalances[tokenIn]
                            )
                          ),
                        );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                  else {
                    setamountOutSwap(
                      price != BigInt(0) && amountIn != BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (amountIn * price) /
                          (activeMarket.scaleFactor || BigInt(1))
                          : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                          price
                        : BigInt(0)
                    );
                    setoutputString(
                      (
                        price != BigInt(0) && amountIn != BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number(
                                (amountIn * price) /
                                (activeMarket.scaleFactor || BigInt(1))
                              ) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3
                            )
                            : customRound(
                              Number(
                                (amountIn *
                                  (activeMarket.scaleFactor || BigInt(1))) /
                                price
                              ) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3
                            )
                          : ''
                      ).toString()
                    );
                  }
                }
              }}
              placeholder="0.00"
              value={limitPriceString}
              step={1 / Math.pow(10, Math.floor(Math.log10(Number(activeMarket.priceFactor))))}
            />
            <span className="limit-order-usd-label">{activeMarket.quoteAsset}</span>
          </div>
          <div className="limit-price-buttons">
            <button
              className="limit-price-button limit-custom-button"
              onClick={() => {
                const customButton = document.querySelector('.limit-custom-button');
                if (customButton) {
                  customButton.classList.add('editing');
                }

                setTimeout(() => {
                  const input = document.querySelector('.limit-custom-input') as HTMLInputElement | null;
                  if (input) {
                    input.value = '';
                    input.focus();
                  }
                }, 10);
              }}
            >
              <span className="limit-custom-label">
                {(() => {
                  const marketPrice = Number(tokenIn === activeMarket?.baseAddress ? mids[activeMarketKey]?.[0] == mids[activeMarketKey]?.[1] ? mids[activeMarketKey]?.[2] : mids[activeMarketKey]?.[0] : mids[activeMarketKey]?.[0] == mids[activeMarketKey]?.[2] ? mids[activeMarketKey]?.[1] : mids[activeMarketKey]?.[0])

                  if (marketPrice > 0 && limitPrice > 0) {
                    const percentDiff = ((Number(limitPrice) - marketPrice) / marketPrice) * 100;
                    if (Math.abs(percentDiff) < 0.01) {
                      return t('custom');
                    }

                    return (percentDiff >= 0 ? "+" : "") + percentDiff.toFixed(1) + "%";
                  }

                  return t('custom');
                })()}
              </span>
              <div className="custom-input-container">
                <input
                  className="limit-custom-input"
                  type="text"
                  inputMode="decimal"
                  placeholder={tokenIn === activeMarket?.quoteAddress ? "-%" : "+%"}
                  onBlur={(e) => {
                    const customButton = document.querySelector('.limit-custom-button');
                    if (customButton) {
                      customButton.classList.remove('editing');
                    }

                    let value = e.target.value.replace(/[^0-9.]/g, '');

                    let numValue = parseFloat(value);
                    if (isNaN(numValue)) numValue = 0;
                    if (numValue > 100) {
                      value = "100";
                      numValue = 100;
                    }

                    if (value) {
                      const marketPrice = tokenIn === activeMarket?.baseAddress
                        ? Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor)
                        : Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor);

                      let newPrice;
                      if (tokenIn === activeMarket?.quoteAddress) {
                        newPrice = marketPrice * (1 - numValue / 100);
                      } else {
                        newPrice = marketPrice * (1 + numValue / 100);
                      }

                      updateLimitAmount(newPrice, Number(activeMarket.priceFactor), activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(newPrice ?? 1)) - 1) : Number(activeMarket.priceFactor));
                    }
                  }}
                  onFocus={(e) => {
                    const value = e.target.value.replace(/[^0-9.]/g, '');
                    e.target.value = value;
                  }}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                      const input = e.target as HTMLInputElement;
                      input.blur();
                    } else if (e.key === 'Escape') {
                      const customButton = document.querySelector('.limit-custom-button');
                      if (customButton) {
                        customButton.classList.remove('editing');
                      }
                    }
                    if ([46, 8, 9, 27, 13, 110, 190].indexOf(e.keyCode) !== -1 ||
                      (e.keyCode === 65 && e.ctrlKey === true) ||
                      (e.keyCode === 67 && e.ctrlKey === true) ||
                      (e.keyCode === 86 && e.ctrlKey === true) ||
                      (e.keyCode === 88 && e.ctrlKey === true) ||
                      (e.keyCode >= 35 && e.keyCode <= 39)) {
                      return;
                    }

                    if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) &&
                      (e.keyCode < 96 || e.keyCode > 105)) {
                      e.preventDefault();
                    }
                  }}
                  onChange={(e) => {
                    let value = e.target.value.replace(/[^0-9.]/g, '');

                    const numValue = parseFloat(value);
                    if (!isNaN(numValue) && numValue > 100) {
                      value = "100";
                    }

                    const sign = tokenIn === activeMarket?.quoteAddress ? "-" : "+";

                    if (value && value !== "0") {
                      e.target.value = sign + value;
                    } else {
                      e.target.value = value;
                    }
                  }}
                  onClick={(e) => e.stopPropagation()}
                />
              </div>
            </button>
            <button
              className="limit-price-button"
              onClick={() => {
                const marketPrice = tokenIn === activeMarket?.baseAddress
                  ? Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor)
                  : Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor);

                const newPrice = tokenIn === activeMarket?.quoteAddress
                  ? Math.max(0, marketPrice * 0.99)
                  : marketPrice * 1.01;

                updateLimitAmount(newPrice, Number(activeMarket.priceFactor), activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(newPrice ?? 1)) - 1) : Number(activeMarket.priceFactor));
              }}
            >
              {tokenIn === activeMarket?.quoteAddress ? "-1%" : "+1%"}
            </button>
            <button
              className="limit-price-button"
              onClick={() => {
                const marketPrice = tokenIn === activeMarket?.baseAddress
                  ? Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor)
                  : Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor);
                const newPrice = tokenIn === activeMarket?.quoteAddress
                  ? Math.max(0, marketPrice * 0.95)
                  : marketPrice * 1.05;

                updateLimitAmount(newPrice, Number(activeMarket.priceFactor), activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(newPrice ?? 1)) - 1) : Number(activeMarket.priceFactor));
              }}
            >
              {tokenIn === activeMarket?.quoteAddress ? "-5%" : "+5%"}
            </button>
            <button
              className="limit-price-button"
              onClick={() => {
                const marketPrice = tokenIn === activeMarket?.baseAddress
                  ? Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor)
                  : Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor);

                const newPrice = tokenIn === activeMarket?.quoteAddress
                  ? Math.max(0, marketPrice * 0.9)
                  : marketPrice * 1.1;

                updateLimitAmount(newPrice, Number(activeMarket.priceFactor), activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(newPrice ?? 1)) - 1) : Number(activeMarket.priceFactor));
              }}
            >
              {tokenIn === activeMarket?.quoteAddress ? "-10%" : "+10%"}
            </button>
          </div>
        </div>
        <div className="balance-slider-wrapper">
          {spotSliderMode === 'presets' ? (
            <div className="slider-container presets-mode">
              <div className="preset-buttons">
                {spotSliderPresets.map((preset: number, index: number) => (
                  <button
                    key={index}
                    className={`preset-button ${sliderPercent === preset ? 'active' : ''}`}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : tokenBalances[tokenIn]) *
                            BigInt(preset)) /
                          100n;
                        setSliderPercent(preset);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left = `${(rect.width - 15) * (preset / 100) + 15 / 2}px`;
                        }
                      }
                    }}
                    disabled={!connected}
                  >
                    {preset}%
                  </button>
                ))}
              </div>
            </div>
          ) : spotSliderMode === 'increment' ? (
            <div className="slider-container increment-mode">
              <button
                className="increment-button minus"
                onClick={() => {
                  if (connected && sliderPercent > 0) {
                    const newPercent = Math.max(0, sliderPercent - spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 0}
              >
                
              </button>
              <div className="increment-display">
                <div className="increment-amount">{spotSliderIncrement}%</div>
              </div>
              <button
                className="increment-button plus"
                onClick={() => {
                  if (connected && sliderPercent < 100) {
                    const newPercent = Math.min(100, sliderPercent + spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 100}
              >
                +
              </button>
            </div>
          ) : (
            <div className="slider-container slider-mode">
              <input
                type="range"
                className={`balance-amount-slider ${isDragging ? 'dragging' : ''}`}
                min="0"
                max="100"
                step="1"
                value={sliderPercent}
                disabled={!connected}
                onChange={(e) => {
                  const percent = parseInt(e.target.value);
                  const newAmount =
                    (((tokenIn == eth && !client)
                      ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : tokenBalances[tokenIn]) *
                      BigInt(percent)) /
                    100n;
                  setSliderPercent(percent);
                  setInputString(
                    newAmount == BigInt(0)
                      ? ''
                      : customRound(
                        Number(newAmount) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      ).toString(),
                  );
                  debouncedSetAmount(newAmount);
                  setswitched(false);
                  if (isWrap) {
                    setoutputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    setamountOutSwap(newAmount);
                  }
                  if (location.pathname.slice(1) === 'limit') {
                    setamountOutSwap(
                      limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                          : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                        : BigInt(0),
                    );
                    setoutputString(
                      (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                          : customRound(
                            Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                  }
                  const slider = e.target;
                  const rect = slider.getBoundingClientRect();
                  const trackWidth = rect.width - 15;
                  const thumbPosition = (percent / 100) * trackWidth + 15 / 2;
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) {
                    popup.style.left = `${thumbPosition}px`;
                  }
                }}
                onMouseDown={() => {
                  setIsDragging(true);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.add('visible');
                }}
                onMouseUp={() => {
                  setIsDragging(false);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.remove('visible');
                }}
                style={{
                  background: `linear-gradient(to right,rgb(171, 176, 224) ${sliderPercent}%,rgba(21, 21, 27, 1) ${sliderPercent}%)`,
                }}
              />
              <div className="slider-percentage-popup">{sliderPercent}%</div>
              <div className="balance-slider-marks">
                {[0, 25, 50, 75, 100].map((markPercent) => (
                  <span
                    key={markPercent}
                    className="balance-slider-mark"
                    data-active={sliderPercent >= markPercent}
                    data-percentage={markPercent}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : tokenBalances[tokenIn]) *
                            BigInt(markPercent)) /
                          100n;
                        setSliderPercent(markPercent);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup: HTMLElement | null = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          popup.style.left = `${(rect.width - 15) * (markPercent / 100) + 15 / 2
                            }px`;
                        }
                      }
                    }}
                  >
                    {markPercent}%
                  </span>
                ))}
              </div>
            </div>
          )}
        </div>
        <button
          className={`limit-swap-button ${isSigning ? 'signing' : ''}`}
          onClick={async () => {
            if (connected && userchain === activechain) {
              let hash;
              setIsSigning(true)
              if (client) {
                txPending.current = true
              }
              try {
                if (tokenIn == eth) {
                  if (addliquidityonly) {
                    hash = await sendUserOperationAsync({
                      uo: limitOrder(
                        router,
                        amountIn,
                        eth,
                        tokenOut as `0x${string}`,
                        limitPrice,
                        amountIn,
                        BigInt(Math.floor(Date.now() / 1000) + 900),
                      )
                    })
                  } else {
                    hash = await sendUserOperationAsync({
                      uo: _swap(
                        router,
                        amountIn,
                        eth,
                        tokenOut as `0x${string}`,
                        true,
                        BigInt(2),
                        amountIn,
                        limitPrice,
                        BigInt(Math.floor(Date.now() / 1000) + 900),
                        usedRefAddress as `0x${string}`,
                      )
                    })
                  }
                } else {
                  if (allowance < amountIn) {
                    if (client) {
                      let uo = []
                      uo.push(approve(
                        tokenIn as `0x${string}`,
                        router,
                        maxUint256,
                      ))
                      if (addliquidityonly) {
                        uo.push(limitOrder(
                          router,
                          BigInt(0),
                          tokenIn as `0x${string}`,
                          tokenOut as `0x${string}`,
                          limitPrice,
                          amountIn,
                          BigInt(Math.floor(Date.now() / 1000) + 900),
                        ))
                      } else {
                        uo.push(_swap(
                          router,
                          BigInt(0),
                          tokenIn as `0x${string}`,
                          tokenOut as `0x${string}`,
                          true,
                          BigInt(2),
                          amountIn,
                          limitPrice,
                          BigInt(Math.floor(Date.now() / 1000) + 900),
                          usedRefAddress as `0x${string}`,
                        ))
                      }
                      hash = await sendUserOperationAsync({ uo: uo })
                      newTxPopup(
                        hash,
                        'approve',
                        tokenIn,
                        '',
                        customRound(
                          Number(amountIn) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ),
                        0,
                        '',
                        router,
                      );
                    }
                    else {
                      hash = await sendUserOperationAsync({
                        uo: approve(
                          tokenIn as `0x${string}`,
                          router,
                          maxUint256,
                        )
                      })
                      newTxPopup(
                        hash,
                        'approve',
                        tokenIn,
                        '',
                        customRound(
                          Number(amountIn) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ),
                        0,
                        '',
                        router,
                      );
                    }
                  }
                  if (!client || !(allowance < amountIn)) {
                    if (addliquidityonly) {
                      hash = await sendUserOperationAsync({
                        uo: limitOrder(
                          router,
                          BigInt(0),
                          tokenIn as `0x${string}`,
                          tokenOut as `0x${string}`,
                          limitPrice,
                          amountIn,
                          BigInt(Math.floor(Date.now() / 1000) + 900),
                        )
                      })
                    } else {
                      hash = await sendUserOperationAsync({
                        uo: _swap(
                          router,
                          BigInt(0),
                          tokenIn as `0x${string}`,
                          tokenOut as `0x${string}`,
                          true,
                          BigInt(2),
                          amountIn,
                          limitPrice,
                          BigInt(Math.floor(Date.now() / 1000) + 900),
                          usedRefAddress as `0x${string}`,
                        )
                      })
                    }
                  }
                }
                if (!client && hash) {
                  txPending.current = true
                }
                setInputString('');
                setamountIn(BigInt(0));
                setamountOutSwap(BigInt(0));
                setoutputString('');
                setLimitButtonDisabled(true);
                setLimitButton(0);
                setSliderPercent(0);
                setIsSigning(false)
                const slider = document.querySelector('.balance-amount-slider');
                const popup = document.querySelector('.slider-percentage-popup');
                if (slider && popup) {
                  (popup as HTMLElement).style.left = `${15 / 2}px`;
                }
                await refetch()
                txPending.current = false
              } catch (error) {
                console.log(error)
                if (!(error instanceof TransactionExecutionError)) {
                  newTxPopup(
                    hash,
                    "limitFailed",
                    tokenIn == eth ? eth : tokenIn,
                    tokenOut == eth ? eth : tokenOut,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn == eth ? eth : tokenIn].decimals), 3),
                    customRound(Number(amountOutSwap) / 10 ** Number(tokendict[tokenOut == eth ? eth : tokenOut].decimals), 3),
                    `${limitPrice / activeMarket.priceFactor} ${activeMarket.quoteAsset}`,
                    "",
                  );
                }
              } finally {
                txPending.current = false
                setIsSigning(false)
              }
            } else {
              !connected ? setpopup(4) : handleSetChain();
            }
          }}
          disabled={limitButtonDisabled || isSigning}
        >
          {isSigning ? (
            <div className="button-content">
              <div className="loading-spinner" />
              {validOneCT ? t('') : t('signTransaction')}
            </div>
          ) : limitButton == 0 ? (
            t('enterAmount')
          ) : limitButton == 1 ? (
            t('enterLimitPrice')
          ) : limitButton == 2 ? (
            t('priceOutOfRangeBuy')
          ) : limitButton == 3 ? (
            t('priceOutOfRangeSell')
          ) : limitButton == 4 ? (
            t('lessThanMinSize')
          ) : limitButton == 5 ? (
            (tokenIn == activeMarket.quoteAddress ? t('buy') : t('sell')) + ' ' + activeMarket.baseAsset
          ) : limitButton == 6 ? (
            t('insufficient') +
            (tokendict[tokenIn].ticker || '?') +
            ' ' +
            t('bal')
          ) : limitButton == 7 ? (
            `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
          ) : limitButton == 8 ? (
            t('connectWallet')
          ) : (
            client ? (tokenIn == activeMarket.quoteAddress ? t('buy') : t('sell')) + ' ' + activeMarket.baseAsset : t('approve')
          )}
        </button>
      </div>
      <div className="limit-info-rectangle">
        <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={t('addLiquidityOnly')}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {t('addLiquidityOnlySubtitle')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <ToggleSwitch
            checked={addliquidityonly}
            onChange={() => {
              const newValue = !addliquidityonly;
              setAddLiquidityOnly(newValue);
              localStorage.setItem(
                'crystal_add_liquidity_only',
                JSON.stringify(newValue),
              );
            }}
          />
        </div>
        <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={`${t('fee')} (0.00%)`}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {t('makerfeeexplanation')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <div className="value-container">
            {`${0} ${tokendict[tokenIn].ticker}`}
          </div>
        </div>

        {!addliquidityonly && !limitChase &&
          limitPrice != BigInt(0) &&
          ((limitPrice >= lowestAsk && tokenIn == activeMarket.quoteAddress) ||
            (limitPrice <= highestBid &&
              tokenIn == activeMarket.baseAddress)) &&
          amountIn != BigInt(0) && (
            <div className="limit-impact-warning">
              {tokenIn == activeMarket.quoteAddress
                ? t('priceOutOfRangeWarningBuy')
                : t('priceOutOfRangeWarningSell')}
            </div>
          )}
      </div>
      {simpleView && <div className="orders-info-rectangle">
        <SimpleOrdersContainer
          orders={orders}
          router={router}
          address={address}
          refetch={refetch}
          sendUserOperationAsync={sendUserOperationAsync}
          setChain={handleSetChain}
        />
      </div>}
    </div>
  );

  // send ui component
  const send = (
    <div className="rectangle">
      <div className="navlinkwrapper" onClick={() => {
        if (windowWidth <= 1020 && !simpleView && !showTrade) {
          setShowTrade(true);
          document.querySelector('.trade-mobile-switch')?.classList.add('open');
        }
      }} data-active={location.pathname.slice(1)}>
        <div className="innernavlinkwrapper">
          <Link
            to={simpleView ? "/swap" : "/market"}
            className={`navlink ${location.pathname.slice(1) === 'swap' ? 'active' : ''}`}
          >
            {simpleView ? t('swap') : t('market')}
          </Link>
          <Link
            to="/send"
            className={`navlink ${location.pathname.slice(1) === 'send' || location.pathname.slice(1) === 'scale' ? 'active' : ''}`}
            onClick={() => {
              setShowSendDropdown(false);
              setCurrentProText('send');
            }}
          >
            {t('send')}
          </Link>

          {showSendDropdown && (
            <div className="navlink-dropdown" ref={sendDropdownRef}>
              <Link
                to="/send"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('send');
                }}
              >
                {t('send')}
              </Link>
              <Link
                to="/scale"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('scale');
                }}
              >
                <TooltipLabel
                  label={t('scale')}
                  tooltipText={
                    <div>
                      <div className="tooltip-description">
                        {t('scaleTooltip')}
                      </div>
                    </div>
                  }
                  className="impact-label"
                />
              </Link>

            </div>
          )}
        </div>
        <div className="sliding-tab-indicator" />
      </div>
      <div className="swapmodal">
        <div
          className={`sendbg ${connected && amountIn > walletTokenBalances[address]?.[tokenIn] && !txPending.current
            ? 'exceed-balance'
            : ''
            }`}
        >
          <div className="sendbutton1container">
            <div className="send-Send">{t('send')}</div>
            <button
              className="send-button1"
              onClick={() => {
                setpopup(1);
              }}
            >
              <img className="send-button1pic" src={tokendict[tokenIn].image} />
              <span>{tokendict[tokenIn].ticker || '?'}</span>
            </button>
          </div>
          <div className="sendinputcontainer">
            <input
              inputMode="decimal"
              className={`send-input ${connected &&
                amountIn > walletTokenBalances[address]?.[tokenIn] && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onCompositionStart={() => {
                setIsComposing(true);
              }}
              onCompositionEnd={(
                e: React.CompositionEvent<HTMLInputElement>,
              ) => {
                setIsComposing(false);
                const value = e.currentTarget.value;

                if (/^\$?\d*\.?\d{0,18}$/.test(value)) {
                  if (displayMode === 'usd') {
                    if (value === '$') {
                      setsendInputString('');
                      setInputString('');
                      debouncedSetAmount(BigInt(0));
                      setSliderPercent(0);

                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        (popup as HTMLElement).style.left = `${15 / 2}px`;
                      }
                    } else {
                      const numericValue = value.replace(/^\$/, '');
                      setsendInputString(`$${numericValue}`);

                      const tokenBigInt = calculateTokenAmount(
                        numericValue,
                        tradesByMarket[
                        (({ baseAsset, quoteAsset }) =>
                          (baseAsset === wethticker ? ethticker : baseAsset) +
                          (quoteAsset === wethticker ? ethticker : quoteAsset)
                        )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                        ],
                        tokenIn,
                        getMarket(
                          activeMarket.path.at(0),
                          activeMarket.path.at(1),
                        ),
                      );

                      setInputString(
                        customRound(
                          Number(tokenBigInt) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                      );

                      debouncedSetAmount(tokenBigInt);
                      setswitched(false);

                      const percentage = !walletTokenBalances[address]?.[tokenIn]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (tokenBigInt * BigInt(100)) /
                              walletTokenBalances[address]?.[tokenIn],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);

                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                          }px`;
                      }
                    }
                  } else {
                    setInputString(value);

                    const tokenBigInt = BigInt(
                      Math.round(
                        (parseFloat(value || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    );
                    debouncedSetAmount(tokenBigInt);
                    setswitched(false);

                    const usd = calculateUSDValue(
                      tokenBigInt,
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                      ],
                      tokenIn,
                      getMarket(
                        activeMarket.path.at(0),
                        activeMarket.path.at(1),
                      ),
                    ).toFixed(2);
                    setsendInputString(`$${usd}`);

                    const percentage = !walletTokenBalances[address]?.[tokenIn]
                      ? 0
                      : Math.min(
                        100,
                        Math.floor(
                          Number(
                            (tokenBigInt * BigInt(100)) /
                            walletTokenBalances[address]?.[tokenIn],
                          ),
                        ),
                      );
                    setSliderPercent(percentage);

                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                }
              }}
              onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                if (isComposing) {
                  if (displayMode === 'usd') {
                    setsendInputString(e.target.value);
                  } else {
                    setInputString(e.target.value);
                  }
                  return;
                }

                const value = e.target.value;
                if (/^\$?\d*\.?\d{0,18}$/.test(value)) {
                  if (displayMode === 'usd') {
                    if (value === '$') {
                      setsendInputString('');
                      setInputString('');
                      debouncedSetAmount(BigInt(0));
                      setSliderPercent(0);

                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        (popup as HTMLElement).style.left = `${15 / 2}px`;
                      }
                    } else {
                      const numericValue = value.replace(/^\$/, '');
                      setsendInputString(`$${numericValue}`);

                      const tokenBigInt = calculateTokenAmount(
                        numericValue,
                        tradesByMarket[
                        (({ baseAsset, quoteAsset }) =>
                          (baseAsset === wethticker ? ethticker : baseAsset) +
                          (quoteAsset === wethticker ? ethticker : quoteAsset)
                        )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                        ],
                        tokenIn,
                        getMarket(
                          activeMarket.path.at(0),
                          activeMarket.path.at(1),
                        ),
                      );

                      setInputString(
                        customRound(
                          Number(tokenBigInt) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                      );
                      debouncedSetAmount(tokenBigInt);
                      setswitched(false);

                      const percentage = !walletTokenBalances[address]?.[tokenIn]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (tokenBigInt * BigInt(100)) /
                              walletTokenBalances[address]?.[tokenIn],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);

                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                          }px`;
                      }
                    }
                  } else {
                    setInputString(value);
                    const tokenBigInt = BigInt(
                      Math.round(
                        (parseFloat(value || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    );
                    debouncedSetAmount(tokenBigInt);
                    setswitched(false);

                    const usd = calculateUSDValue(
                      tokenBigInt,
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                      ],
                      tokenIn,
                      getMarket(
                        activeMarket.path.at(0),
                        activeMarket.path.at(1),
                      ),
                    ).toFixed(2);
                    setsendInputString(`$${usd}`);

                    const percentage = !walletTokenBalances[address]?.[tokenIn]
                      ? 0
                      : Math.min(
                        100,
                        Math.floor(
                          Number(
                            (tokenBigInt * BigInt(100)) /
                            walletTokenBalances[address]?.[tokenIn],
                          ),
                        ),
                      );
                    setSliderPercent(percentage);

                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                }
              }}
              placeholder={displayMode === 'usd' ? '$0.00' : '0.00'}
              value={displayMode === 'usd' ? sendInputString : inputString}
              autoFocus={!(windowWidth <= 1020)}
            />
          </div>
          <div className="send-balance-wrapper">
            <div className="send-balance-max-container">
              <div className="send-balance1">
                <img src={walleticon} className="send-balance-wallet-icon" />{' '}
                {formatSubscript(formatDisplayValue(
                  walletTokenBalances[address]?.[tokenIn],
                  Number(tokendict[tokenIn].decimals),
                ))}
              </div>
              <div
                className="send-max-button"
                onClick={() => {
                  if (walletTokenBalances[address]?.[tokenIn] != BigInt(0)) {
                    let amount =
                      (tokenIn == eth && !client)
                        ? walletTokenBalances[address]?.[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? walletTokenBalances[address]?.[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : walletTokenBalances[address]?.[tokenIn];
                    debouncedSetAmount(BigInt(amount));
                    setswitched(false);
                    setInputString(
                      customRound(
                        Number(amount) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      ).toString(),
                    );
                    setsendInputString(
                      `$${calculateUSDValue(
                        amount,
                        tradesByMarket[
                        (({ baseAsset, quoteAsset }) =>
                          (baseAsset === wethticker ? ethticker : baseAsset) +
                          (quoteAsset === wethticker ? ethticker : quoteAsset)
                        )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                        ],
                        tokenIn,
                        getMarket(
                          activeMarket.path.at(0),
                          activeMarket.path.at(1),
                        ),
                      ).toFixed(2)}`,
                    );
                    setSliderPercent(100);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      const trackWidth = rect.width - 15;
                      const thumbPosition = trackWidth + 15 / 2;
                      (popup as HTMLElement).style.left = `${thumbPosition}px`;
                    }
                  }
                }}
              >
                {t('max')}
              </div>
            </div>
            <div
              className="send-usd-switch-wrapper"
              onClick={() => {
                if (displayMode === 'usd') {
                  setDisplayMode('token');
                  if (parseFloat(sendInputString.replace(/^\$|,/g, '')) == 0) {
                    setInputString('');
                  }
                } else {
                  setDisplayMode('usd');
                  if (parseFloat(inputString) == 0) {
                    setsendInputString('');
                  }
                }
              }}
            >
              <div className="send-usd-value">
                {displayMode === 'usd'
                  ? `${customRound(
                    Number(amountIn) /
                    10 ** Number(tokendict[tokenIn].decimals),
                    3,
                  )} ${tokendict[tokenIn].ticker}`
                  : amountIn === BigInt(0)
                    ? '$0.00'
                    : Math.round(
                      (parseFloat(inputString || '0') || 0) *
                      10 ** Number(tokendict[tokenIn].decimals),
                    ) == 0
                      ? '$0.00'
                      : formatUSDDisplay(
                        calculateUSDValue(
                          BigInt(
                            Math.round(
                              (parseFloat(inputString || '0') || 0) *
                              10 ** Number(tokendict[tokenIn].decimals),
                            ),
                          ),
                          tradesByMarket[
                          (({ baseAsset, quoteAsset }) =>
                            (baseAsset === wethticker ? ethticker : baseAsset) +
                            (quoteAsset === wethticker ? ethticker : quoteAsset)
                          )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                          ],
                          tokenIn,
                          getMarket(
                            activeMarket.path.at(0),
                            activeMarket.path.at(1),
                          ),
                        ),
                      )}
              </div>
              <img src={sendSwitch} className="send-arrow" />
            </div>
          </div>
        </div>
        <div className="swap-container-divider" />

        <div className="sendaddressbg">
          <div className="send-To">{t('to')}</div>
          <div className="send-address-input-container">
            <input
              className="send-output"
              onChange={(e) => {
                if (e.target.value === '' || /^(0x[0-9a-fA-F]{0,40}|0)$/.test(e.target.value)) {
                  setrecipient(e.target.value);
                }
              }}
              value={recipient}
              placeholder={t('enterWalletAddress')}
            />
            <button
              className="address-paste-button"
              onClick={async () => {
                try {
                  const text = await navigator.clipboard.readText();
                  if (/^(0x[0-9a-fA-F]{40})$/.test(text)) {
                    setrecipient(text);
                  }
                } catch (err) {
                  console.error('Failed to read clipboard: ', err);
                }
              }}
            >
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
              </svg>
            </button>
          </div>
        </div>
        <button
          className={`send-swap-button ${isSigning ? 'signing' : ''}`}
          onClick={async () => {
            if (
              connected &&
              userchain === activechain
            ) {
              let hash: any;
              setIsSigning(true)
              if (client) {
                txPending.current = true
              }
              try {
                if (tokenIn == eth) {
                  hash = await sendUserOperationAsync({
                    uo: sendeth(
                      recipient as `0x${string}`,
                      amountIn,
                    )
                  });
                  if (!client) {
                    txPending.current = true
                  }
                  newTxPopup(
                    (hash),
                    'send',
                    eth,
                    '',
                    customRound(
                      Number(amountIn) / 10 ** Number(tokendict[eth].decimals),
                      3,
                    ),
                    0,
                    '',
                    recipient,
                  );
                } else {
                  hash = await sendUserOperationAsync({
                    uo: sendtokens(
                      tokenIn as `0x${string}`,
                      recipient as `0x${string}`,
                      amountIn,
                    )
                  });
                  if (!client) {
                    txPending.current = true
                  }
                  newTxPopup(
                    (hash),
                    'send',
                    tokenIn,
                    '',
                    customRound(
                      Number(amountIn) /
                      10 ** Number(tokendict[tokenIn].decimals),
                      3,
                    ),
                    0,
                    '',
                    recipient,
                  );
                }
                setInputString('');
                setsendInputString('');
                setamountIn(BigInt(0));
                setSliderPercent(0);
                setSendButton(0);
                setSendButtonDisabled(true);
                setIsSigning(false)
                const slider = document.querySelector('.balance-amount-slider');
                const popup = document.querySelector(
                  '.slider-percentage-popup',
                );
                if (slider && popup) {
                  (popup as HTMLElement).style.left = `${15 / 2}px`;
                }
                await refetch()
                txPending.current = false
              } catch (error) {
                if (!(error instanceof TransactionExecutionError)) {
                  newTxPopup(
                    hash,
                    "sendFailed",
                    tokenIn === eth ? eth : tokenIn,
                    "",
                    customRound(
                      Number(amountIn) / 10 ** Number(tokendict[tokenIn === eth ? eth : tokenIn].decimals),
                      3,
                    ),
                    0,
                    "",
                    recipient,
                  );
                }
              } finally {
                txPending.current = false
                setIsSigning(false)
              }
            } else {
              !connected
                ? setpopup(4)
                : handleSetChain()
            }
          }}
          disabled={sendButtonDisabled || isSigning}
        >
          {isSigning ? (
            <div className="button-content">
              <div className="loading-spinner" />
              {validOneCT ? t('') : t('signTransaction')}
            </div>
          ) : !connected ? (
            t('connectWallet')
          ) : sendButton == 0 ? (
            t('enterAmount')
          ) : sendButton == 1 ? (
            t('enterWalletAddress')
          ) : sendButton == 2 ? (
            t('send')
          ) : sendButton == 3 ? (
            t('insufficient') +
            (tokendict[tokenIn].ticker || '?') +
            ' ' +
            t('bal')
          ) : sendButton == 4 ? (
            `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
          ) : (
            t('connectWallet')
          )}
        </button>
      </div>
    </div>
  );

  // scale ui component
  const scale = (
    <div className="rectangle">
      <div className="navlinkwrapper" onClick={() => {
        if (windowWidth <= 1020 && !simpleView && !showTrade) {
          setShowTrade(true);
          document.querySelector('.trade-mobile-switch')?.classList.add('open');
        }
      }} data-active={location.pathname.slice(1)}>
        <div className="innernavlinkwrapper">
          <Link
            to={simpleView ? "/swap" : "/market"}
            className={`navlink ${location.pathname.slice(1) === 'swap' ? 'active' : ''}`}
          >
            {simpleView ? t('swap') : t('market')}
          </Link>
          <Link
            to="/limit"
            className={`navlink ${location.pathname.slice(1) === 'limit' ? 'active' : ''}`}
          >
            {t('limit')}
          </Link>
          <span
            ref={(el: HTMLSpanElement | null) => {
              sendButtonRef.current = el;
            }}
            className={`navlink ${location.pathname.slice(1) != 'swap' && location.pathname.slice(1) != 'limit' ? 'active' : ''}`}
            onClick={(e: React.MouseEvent) => {
              e.preventDefault();
              setShowSendDropdown(!showSendDropdown);
            }}
          >
            <span className="current-pro-text">{t(currentProText)}</span>
            <svg
              className={`dropdown-arrow ${showSendDropdown ? 'open' : ''}`}
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="12"
              height="12"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            >
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </span>

          {showSendDropdown && (
            <div className="navlink-dropdown" ref={sendDropdownRef}>
              <Link
                to="/send"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('send');
                }}
              >
                {t('send')}
              </Link>
              <Link
                to="/scale"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('scale');
                }}
              >
                <TooltipLabel
                  label={t('scale')}
                  tooltipText={
                    <div>
                      <div className="tooltip-description">
                        {t('scaleTooltip')}
                      </div>
                    </div>
                  }
                  className="impact-label"
                />
              </Link>

            </div>
          )}
        </div>
        <div className="sliding-tab-indicator" />
      </div>
      <div className="swapmodal">
        <div
          className={`inputbg ${connected &&
            ((amountIn > tokenBalances[tokenIn] &&
              !isLoading &&
              !stateIsLoading) ||
              (amountIn != BigInt(0) &&
                (tokenIn == activeMarket.quoteAddress
                  ? amountIn < activeMarket.minSize
                  : (amountIn * limitPrice) / activeMarket.scaleFactor <
                  activeMarket.minSize))) && !txPending.current
            ? 'exceed-balance'
            : ''
            }`}
        >
          <div className="Pay">{t('pay')}</div>
          <div className="inputbutton1container">
            <input
              inputMode="decimal"
              className={`input ${connected &&
                ((amountIn > tokenBalances[tokenIn] &&
                  !isLoading &&
                  !stateIsLoading) ||
                  (amountIn !== BigInt(0) &&
                    (tokenIn === activeMarket.quoteAddress
                      ? amountIn < activeMarket.minSize
                      : (amountIn * limitPrice) / activeMarket.scaleFactor <
                      activeMarket.minSize))) && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onCompositionStart={() => {
                setIsComposing(true);
              }}
              onCompositionEnd={(
                e: React.CompositionEvent<HTMLInputElement>,
              ) => {
                setIsComposing(false);
                if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                  setInputString(e.currentTarget.value);
                  if (
                    (inputString.endsWith('.') && e.currentTarget.value === inputString.slice(0, -1)) ||
                    (e.currentTarget.value.endsWith('.') && e.currentTarget.value.slice(0, -1) === inputString)
                  ) {
                    return;
                  }
                  const inputValue = BigInt(
                    Math.round(
                      (parseFloat(e.currentTarget.value || '0') || 0) *
                      10 ** Number(tokendict[tokenIn].decimals),
                    ),
                  );
                  if (scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                    setScaleOutput(Number(inputValue), Number(scaleStart), Number(scaleEnd), Number(scaleOrders), Number(scaleSkew))
                  }
                  else {
                    setScaleOutput(Number(inputValue), Number(scaleStart), Number(scaleEnd), Number(0), Number(scaleSkew))
                  }

                  debouncedSetAmount(inputValue);
                  setswitched(false);

                  const percentage = !tokenBalances[tokenIn]
                    ? 0
                    : Math.min(
                      100,
                      Math.floor(
                        Number(
                          (inputValue * BigInt(100)) / tokenBalances[tokenIn],
                        ),
                      ),
                    );
                  setSliderPercent(percentage);

                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    (popup as HTMLElement).style.left =
                      `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                  }
                }
              }}
              onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                if (isComposing) {
                  setInputString(e.target.value);
                  return;
                }

                if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                  setInputString(e.target.value);
                  if (
                    (inputString.endsWith('.') && e.target.value === inputString.slice(0, -1)) ||
                    (e.target.value.endsWith('.') && e.target.value.slice(0, -1) === inputString)
                  ) {
                    return;
                  }
                  const inputValue = BigInt(
                    Math.round(
                      (parseFloat(e.currentTarget.value || '0') || 0) *
                      10 ** Number(tokendict[tokenIn].decimals),
                    ),
                  );
                  if (scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                    setScaleOutput(Number(inputValue), Number(scaleStart), Number(scaleEnd), Number(scaleOrders), Number(scaleSkew))
                  }
                  else {
                    setScaleOutput(Number(inputValue), Number(scaleStart), Number(scaleEnd), Number(0), Number(scaleSkew))
                  }

                  debouncedSetAmount(inputValue);
                  setswitched(false);

                  const percentage = !tokenBalances[tokenIn]
                    ? 0
                    : Math.min(
                      100,
                      Math.floor(
                        Number(
                          (inputValue * BigInt(100)) / tokenBalances[tokenIn],
                        ),
                      ),
                    );
                  setSliderPercent(percentage);

                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    (popup as HTMLElement).style.left =
                      `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                  }
                }
              }}
              placeholder="0.00"
              value={inputString}
              autoFocus={!(windowWidth <= 1020)}
            />
            <button
              className={`button1 ${connected &&
                ((amountIn > tokenBalances[tokenIn] &&
                  !isLoading &&
                  !stateIsLoading) ||
                  (amountIn != BigInt(0) &&
                    (tokenIn == activeMarket.quoteAddress
                      ? amountIn < activeMarket.minSize
                      : (amountIn * limitPrice) / activeMarket.scaleFactor <
                      activeMarket.minSize))) && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onClick={() => {
                setpopup(1);
              }}
            >
              <img className="button1pic" src={tokendict[tokenIn].image} />
              <span>{tokendict[tokenIn].ticker || '?'}</span>
              <svg
                className={`button-arrow ${popup == 1 ? 'open' : ''}`}
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="16"
                height="16"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </button>
          </div>
          <div className="balance1maxcontainer">
            <span className="usd-value">
              {Math.round(
                (parseFloat(inputString || '0') || 0) *
                10 ** Number(tokendict[tokenIn].decimals),
              ) == 0
                ? '$0.00'
                : formatUSDDisplay(
                  calculateUSDValue(
                    BigInt(
                      Math.round(
                        (parseFloat(inputString || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    ),
                    tradesByMarket[
                    (({ baseAsset, quoteAsset }) =>
                      (baseAsset === wethticker ? ethticker : baseAsset) +
                      (quoteAsset === wethticker ? ethticker : quoteAsset)
                    )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                    ],
                    tokenIn,
                    getMarket(
                      activeMarket.path.at(0),
                      activeMarket.path.at(1),
                    ),
                  ),
                )}
            </span>
            <div className="balance1">
              <img src={walleticon} className="balance-wallet-icon" />{' '}
              {formatSubscript(formatDisplayValue(
                tokenBalances[tokenIn],
                Number(tokendict[tokenIn].decimals),
              ))}
            </div>
            <div
              className="max-button"
              onClick={() => {
                if (tokenBalances[tokenIn] != BigInt(0)) {
                  let amount =
                    (tokenIn == eth && !client)
                      ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : tokenBalances[tokenIn];
                  debouncedSetAmount(BigInt(amount));
                  setswitched(false);
                  setInputString(
                    customRound(
                      Number(amount) /
                      10 ** Number(tokendict[tokenIn].decimals),
                      3,
                    ).toString(),
                  );
                  if (scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                    setScaleOutput(Number(amount), Number(scaleStart), Number(scaleEnd), Number(scaleOrders), Number(scaleSkew))
                  }
                  else {
                    setScaleOutput(Number(amount), Number(scaleStart), Number(scaleEnd), Number(0), Number(scaleSkew))
                  }
                  setSliderPercent(100);
                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    const trackWidth = rect.width - 15;
                    const thumbPosition = trackWidth + 15 / 2;
                    (popup as HTMLElement).style.left = `${thumbPosition}px`;
                  }
                }
              }}
            >
              {t('max')}{' '}
            </div>
          </div>
        </div>
        <div
          className="switch-button"
          onClick={() => {
            setTokenIn(tokenOut);
            setTokenOut(tokenIn);
            setswitched((switched) => { return !switched });
            if (amountIn != BigInt(0) && scaleStart && scaleEnd && scaleOrders && scaleSkew) {
              setInputString(outputString);
              setoutputString(inputString);
              setamountIn(amountOutSwap);
              setamountOutSwap(amountIn);
              const percentage = !tokenBalances[tokenOut]
                ? 0
                : Math.min(
                  100,
                  Math.floor(
                    Number(
                      (amountOutSwap * BigInt(100)) /
                      tokenBalances[tokenOut],
                    ),
                  ),
                );
              setSliderPercent(percentage);
              const slider = document.querySelector('.balance-amount-slider');
              const popup = document.querySelector('.slider-percentage-popup');
              if (slider && popup) {
                const rect = slider.getBoundingClientRect();
                (popup as HTMLElement).style.left =
                  `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
              }
            }
            else {
              setamountIn(BigInt(0))
              setInputString('')
            }
          }}
        >
          <img src={tradearrow} className="switch-arrow" />
        </div>
        <div className="swap-container-divider" />
        <div className="outputbg">
          <div className="Recieve">{t('receive')}</div>
          <div className="outputbutton2container">
            <>
              <input
                inputMode="decimal"
                className="output"
                onCompositionStart={() => {
                  setIsComposing(true);
                }}
                onCompositionEnd={(
                  e: React.CompositionEvent<HTMLInputElement>,
                ) => {
                  setIsComposing(false);
                  if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                    setoutputString(e.currentTarget.value);
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.currentTarget.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    )
                    setamountOutSwap(outputValue);
                    setswitched(true);
                    if (scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                      const requiredInput = calculateScaleInput(
                        outputValue,
                        Number(scaleStart),
                        Number(scaleEnd),
                        Number(scaleOrders),
                        Number(scaleSkew)
                      );
                      setamountIn(requiredInput);
                      setInputString(
                        customRound(
                          Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                          3
                        ).toString()
                      );
                      const percentage =
                        tokenBalances[tokenIn] === BigInt(0)
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (requiredInput) * BigInt(100) / tokenBalances[tokenIn])
                            ),
                          );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                          }px`;
                      }
                    }
                    else {
                      const requiredInput = calculateScaleInput(
                        outputValue,
                        Number(scaleStart),
                        Number(scaleEnd),
                        Number(0),
                        Number(scaleSkew)
                      );
                      setamountIn(requiredInput);
                      setInputString('');
                      const percentage =
                        tokenBalances[tokenIn] === BigInt(0)
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (requiredInput) * BigInt(100) / tokenBalances[tokenIn])
                            ),
                          );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                          }px`;
                      }
                    }
                  }
                }}
                onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                  if (isComposing) {
                    setoutputString(e.target.value);
                    return;
                  }
                  if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                    setoutputString(e.target.value);
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    )
                    setamountOutSwap(outputValue);
                    setswitched(true);
                    if (scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                      const requiredInput = calculateScaleInput(
                        outputValue,
                        Number(scaleStart),
                        Number(scaleEnd),
                        Number(scaleOrders),
                        Number(scaleSkew)
                      );
                      setamountIn(requiredInput);
                      setInputString(
                        customRound(
                          Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                          3
                        ).toString()
                      );
                      const percentage =
                        tokenBalances[tokenIn] === BigInt(0)
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (requiredInput) * BigInt(100) / tokenBalances[tokenIn])
                            ),
                          );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                          }px`;
                      }
                    }
                    else {
                      const requiredInput = calculateScaleInput(
                        outputValue,
                        Number(scaleStart),
                        Number(scaleEnd),
                        Number(0),
                        Number(scaleSkew)
                      );
                      setamountIn(requiredInput);
                      setInputString('');
                      const percentage =
                        tokenBalances[tokenIn] === BigInt(0)
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (requiredInput) * BigInt(100) / tokenBalances[tokenIn])
                            ),
                          );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                          }px`;
                      }
                    }
                  }
                }}
                placeholder="0.00"
                value={outputString}
              />
              <button
                className="button2"
                onClick={() => {
                  setpopup(2);
                }}
              >
                <img className="button2pic" src={tokendict[tokenOut].image} />
                <span>{tokendict[tokenOut].ticker || "?"}</span>
                <svg
                  className={`button-arrow ${popup == 2 ? 'open' : ''}`}
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  width="16"
                  height="16"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
              </button>
            </>
          </div>
          <div className="balance1maxcontainer">
            <div className="output-usd-value">
              {amountOutSwap === BigInt(0)
                ? "$0.00"
                : (() => {
                  const outputUSD = calculateUSDValue(
                    amountOutSwap,
                    tradesByMarket[
                    (({ baseAsset, quoteAsset }) =>
                      (baseAsset === wethticker ? ethticker : baseAsset) +
                      (quoteAsset === wethticker ? ethticker : quoteAsset)
                    )(getMarket(activeMarket.path.at(-2), activeMarket.path.at(-1)))
                    ],
                    tokenOut,
                    getMarket(
                      activeMarket.path.at(-2),
                      activeMarket.path.at(-1)
                    )
                  );

                  const inputUSD = calculateUSDValue(
                    BigInt(
                      Math.round(
                        (parseFloat(inputString || "0") || 0) *
                        10 ** Number(tokendict[tokenIn].decimals)
                      )
                    ),
                    tradesByMarket[
                    (({ baseAsset, quoteAsset }) =>
                      (baseAsset === wethticker ? ethticker : baseAsset) +
                      (quoteAsset === wethticker ? ethticker : quoteAsset)
                    )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                    ],
                    tokenIn,
                    getMarket(
                      activeMarket.path.at(0),
                      activeMarket.path.at(1)
                    )
                  );

                  const percentageDiff =
                    inputUSD > 0 ? ((outputUSD - inputUSD) / inputUSD) * 100 : 0;

                  return (
                    <div className="output-usd-container">
                      <span>{formatUSDDisplay(outputUSD)}</span>
                      {inputUSD > 0 && (
                        <span
                          className={`output-percentage ${percentageDiff >= 0 ? "positive" : "negative"
                            }`}
                        >
                          ({percentageDiff >= 0 ? "+" : ""}
                          {percentageDiff.toFixed(2)}%)
                        </span>
                      )}
                    </div>
                  );
                })()}
            </div>
            <div className="balance2">
              <img src={walleticon} className="balance-wallet-icon" />{" "}
              {formatSubscript(formatDisplayValue(
                tokenBalances[tokenOut],
                Number(tokendict[tokenOut].decimals)
              ))}
            </div>
          </div>
        </div>
        <div className="scale-start-end-container">
          <div
            className={`scalebgtop ${connected &&
              !(
                amountIn > tokenBalances[tokenIn] &&
                !isLoading &&
                !stateIsLoading
              ) &&
              amountIn != BigInt(0) &&
              ((scaleStart >= lowestAsk &&
                tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
                (scaleStart <= highestBid &&
                  tokenIn == activeMarket.baseAddress && (addliquidityonly))) &&
              !(tokenIn == activeMarket.quoteAddress
                ? amountIn < activeMarket.minSize
                : (amountIn * scaleStart) / activeMarket.scaleFactor <
                activeMarket.minSize) && !txPending.current
              ? 'exceed-balance'
              : ''
              }`}
          >
            <div className="scalepricecontainer">
              <span className="scale-order-start-label">{t('start')}</span>
              <input
                inputMode="decimal"
                className={`scale-input ${connected &&
                  !(
                    amountIn > tokenBalances[tokenIn] &&
                    !isLoading &&
                    !stateIsLoading
                  ) &&
                  amountIn != BigInt(0) &&
                  ((scaleStart >= lowestAsk &&
                    tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
                    (scaleStart <= highestBid &&
                      tokenIn == activeMarket.baseAddress && (addliquidityonly))) &&
                  !(tokenIn == activeMarket.quoteAddress
                    ? amountIn < activeMarket.minSize
                    : (amountIn * scaleStart) / activeMarket.scaleFactor <
                    activeMarket.minSize) && !txPending.current
                  ? 'exceed-balance'
                  : ''
                  }`}
                onChange={(e) => {
                  if (
                    new RegExp(
                      `^\\d*\\.?\\d{0,${Math.floor(Math.log10(activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(Number(e.target.value) == 0 ? 1 : Number(e.target.value) ?? 1)) - 1) : Number(activeMarket.priceFactor)))}}$`
                    ).test(e.target.value)
                  ) {
                    setScaleStartString(e.target.value);
                    let price = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        Number(activeMarket.priceFactor)
                      )
                    );
                    setScaleStart(price);
                    if (price && scaleEnd && scaleOrders && scaleSkew) {
                      if (!switched) {
                        setScaleOutput(
                          Number(amountIn),
                          Number(price),
                          Number(scaleEnd),
                          Number(scaleOrders),
                          Number(scaleSkew)
                        );
                      } else {
                        const requiredInput = calculateScaleInput(
                          BigInt(Number(outputString) * 10 ** Number(tokendict[tokenOut].decimals)),
                          Number(price),
                          Number(scaleEnd),
                          Number(scaleOrders),
                          Number(scaleSkew)
                        );
                        setamountIn(BigInt(requiredInput));
                        setInputString(
                          customRound(
                            Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                            3
                          ).toString()
                        );
                      }
                    }
                  }
                }}
                placeholder="0.00"
                value={scaleStartString}
              />
            </div>
          </div>
          <div
            className={`scalebgtop ${connected &&
              !(
                amountIn > tokenBalances[tokenIn] &&
                !isLoading &&
                !stateIsLoading
              ) &&
              amountIn != BigInt(0) &&
              ((scaleEnd >= lowestAsk &&
                tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
                (scaleEnd <= highestBid &&
                  tokenIn == activeMarket.baseAddress && (addliquidityonly))) &&
              !(tokenIn == activeMarket.quoteAddress
                ? amountIn < activeMarket.minSize
                : (amountIn * scaleEnd) / activeMarket.scaleFactor <
                activeMarket.minSize) && !txPending.current
              ? 'exceed-balance'
              : ''
              }`}
          >
            <div className="scalepricecontainer">
              <span className="scale-order-end-label">{t('end')}</span>
              <input
                inputMode="decimal"
                className={`scale-input ${connected &&
                  !(
                    amountIn > tokenBalances[tokenIn] &&
                    !isLoading &&
                    !stateIsLoading
                  ) &&
                  amountIn != BigInt(0) &&
                  ((scaleEnd >= lowestAsk &&
                    tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
                    (scaleEnd <= highestBid &&
                      tokenIn == activeMarket.baseAddress && (addliquidityonly))) &&
                  !(tokenIn == activeMarket.quoteAddress
                    ? amountIn < activeMarket.minSize
                    : (amountIn * scaleEnd) / activeMarket.scaleFactor <
                    activeMarket.minSize) && !txPending.current
                  ? 'exceed-balance'
                  : ''
                  }`}
                onChange={(e) => {
                  if (
                    new RegExp(
                      `^\\d*\\.?\\d{0,${Math.floor(Math.log10(activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(Number(e.target.value) == 0 ? 1 : Number(e.target.value) ?? 1)) - 1) : Number(activeMarket.priceFactor)))}}$`
                    ).test(e.target.value)
                  ) {
                    setScaleEndString(e.target.value);
                    let price = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        Number(activeMarket.priceFactor)
                      )
                    );
                    setScaleEnd(price);
                    if (price && scaleStart && scaleOrders && scaleSkew) {
                      if (!switched) {
                        setScaleOutput(
                          Number(amountIn),
                          Number(scaleStart),
                          Number(price),
                          Number(scaleOrders),
                          Number(scaleSkew)
                        );
                      } else {
                        const requiredInput = calculateScaleInput(
                          BigInt(Number(outputString) * 10 ** Number(tokendict[tokenOut].decimals)),
                          Number(scaleStart),
                          Number(price),
                          Number(scaleOrders),
                          Number(scaleSkew)
                        );
                        setamountIn(BigInt(requiredInput));
                        setInputString(
                          customRound(
                            Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                            3
                          ).toString()
                        );
                      }
                    }
                  }
                }}
                placeholder="0.00"
                value={scaleEndString}
              />
            </div>
          </div>
        </div>
        <div className="scale-size-skew">
          <div
            className={`scalebottombg ${scaleOrdersString == '1'
              ? 'exceed-balance'
              : ''
              }`}
          >
            <div className="scalebottomcontainer">
              <span className="scale-order-total-label">{t('orders')}</span>
              <input
                inputMode="numeric" pattern="[0-9]*"
                className={`scale-bottom-input ${scaleOrdersString == '1'
                  ? 'exceed-balance'
                  : ''
                  }`}
                onChange={(e) => {
                  if (/^\d*$/.test(e.target.value) && Number(e.target.value) <= 1000) {
                    setScaleOrdersString(e.target.value);
                    let temporders = BigInt(e.target.value == "1" ? 0 : e.target.value)
                    setScaleOrders(temporders)
                    if (temporders && scaleStart && scaleSkew && scaleEnd) {
                      if (!switched) {
                        setScaleOutput(
                          Number(amountIn),
                          Number(scaleStart),
                          Number(scaleEnd),
                          Number(temporders),
                          Number(scaleSkew)
                        );
                      } else {
                        const requiredInput = calculateScaleInput(
                          BigInt(Number(outputString) * 10 ** Number(tokendict[tokenOut].decimals)),
                          Number(scaleStart),
                          Number(scaleEnd),
                          Number(temporders),
                          Number(scaleSkew)
                        );
                        setamountIn(requiredInput);
                        setInputString(
                          customRound(
                            Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                            3
                          ).toString()
                        );
                      }
                    }
                    else {
                      setScaleOutput(Number(amountIn), Number(scaleStart), Number(scaleEnd), Number(0), Number(scaleSkew))
                    }
                  }
                }}
                placeholder="0"
                value={scaleOrdersString}
              />
            </div>
          </div>
          <div
            className={`scalebottombg`}
          >
            <div className="scalebottomcontainer">
              <span className="scale-order-size-label">{t('skew')}</span>
              <input
                inputMode="decimal"
                className={`scale-bottom-input`}
                onChange={(e) => {
                  if (/^\d*\.?\d{0,2}$/.test(e.target.value) && Number(e.target.value) <= 100) {
                    setScaleSkewString(e.target.value);
                    let skew = Number(e.target.value)
                    setScaleSkew(skew)
                    if (skew && scaleStart && scaleOrders && scaleEnd) {
                      if (!switched) {
                        setScaleOutput(
                          Number(amountIn),
                          Number(scaleStart),
                          Number(scaleEnd),
                          Number(scaleOrders),
                          Number(skew)
                        );
                      } else {
                        const requiredInput = calculateScaleInput(
                          BigInt(Number(outputString) * 10 ** Number(tokendict[tokenOut].decimals)),
                          Number(scaleStart),
                          Number(scaleEnd),
                          Number(scaleOrders),
                          Number(skew)
                        );
                        setamountIn(requiredInput);
                        setInputString(
                          customRound(
                            Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                            3
                          ).toString()
                        );
                      }
                    }
                  }
                }}
                placeholder="0.00"
                value={scaleSkewString}
              />
            </div>
          </div>
        </div>
        <div className="balance-slider-wrapper">
          {spotSliderMode === 'presets' ? (
            <div className="slider-container presets-mode">
              <div className="preset-buttons">
                {spotSliderPresets.map((preset: number, index: number) => (
                  <button
                    key={index}
                    className={`preset-button ${sliderPercent === preset ? 'active' : ''}`}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : tokenBalances[tokenIn]) *
                            BigInt(preset)) /
                          100n;
                        setSliderPercent(preset);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left = `${(rect.width - 15) * (preset / 100) + 15 / 2}px`;
                        }
                      }
                    }}
                    disabled={!connected}
                  >
                    {preset}%
                  </button>
                ))}
              </div>
            </div>
          ) : spotSliderMode === 'increment' ? (
            <div className="slider-container increment-mode">
              <button
                className="increment-button minus"
                onClick={() => {
                  if (connected && sliderPercent > 0) {
                    const newPercent = Math.max(0, sliderPercent - spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 0}
              >
                
              </button>
              <div className="increment-display">
                <div className="increment-amount">{spotSliderIncrement}%</div>
              </div>
              <button
                className="increment-button plus"
                onClick={() => {
                  if (connected && sliderPercent < 100) {
                    const newPercent = Math.min(100, sliderPercent + spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 100}
              >
                +
              </button>
            </div>
          ) : (
            <div className="slider-container slider-mode">
              <input
                type="range"
                className={`balance-amount-slider ${isDragging ? 'dragging' : ''}`}
                min="0"
                max="100"
                step="1"
                value={sliderPercent}
                disabled={!connected}
                onChange={(e) => {
                  const percent = parseInt(e.target.value);
                  const newAmount =
                    (((tokenIn == eth && !client)
                      ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : tokenBalances[tokenIn]) *
                      BigInt(percent)) /
                    100n;
                  setSliderPercent(percent);
                  setInputString(
                    newAmount == BigInt(0)
                      ? ''
                      : customRound(
                        Number(newAmount) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      ).toString(),
                  );
                  debouncedSetAmount(newAmount);
                  setswitched(false);
                  if (isWrap) {
                    setoutputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    setamountOutSwap(newAmount);
                  }
                  if (location.pathname.slice(1) === 'limit') {
                    setamountOutSwap(
                      limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                          : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                        : BigInt(0),
                    );
                    setoutputString(
                      (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                          : customRound(
                            Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                  }
                  const slider = e.target;
                  const rect = slider.getBoundingClientRect();
                  const trackWidth = rect.width - 15;
                  const thumbPosition = (percent / 100) * trackWidth + 15 / 2;
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) {
                    popup.style.left = `${thumbPosition}px`;
                  }
                }}
                onMouseDown={() => {
                  setIsDragging(true);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.add('visible');
                }}
                onMouseUp={() => {
                  setIsDragging(false);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.remove('visible');
                }}
                style={{
                  background: `linear-gradient(to right,rgb(171, 176, 224) ${sliderPercent}%,rgba(21, 21, 27, 1) ${sliderPercent}%)`,
                }}
              />
              <div className="slider-percentage-popup">{sliderPercent}%</div>
              <div className="balance-slider-marks">
                {[0, 25, 50, 75, 100].map((markPercent) => (
                  <span
                    key={markPercent}
                    className="balance-slider-mark"
                    data-active={sliderPercent >= markPercent}
                    data-percentage={markPercent}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : tokenBalances[tokenIn]) *
                            BigInt(markPercent)) /
                          100n;
                        setSliderPercent(markPercent);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup: HTMLElement | null = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          popup.style.left = `${(rect.width - 15) * (markPercent / 100) + 15 / 2
                            }px`;
                        }
                      }
                    }}
                  >
                    {markPercent}%
                  </span>
                ))}
              </div>
            </div>
          )}
        </div>
        <button
          className={`limit-swap-button ${isSigning ? 'signing' : ''}`}
          onClick={async () => {
            if (connected && userchain === activechain) {
              let finalAmountIn = amountIn;
              if (switched) {
                const desiredOutput =
                  Number(outputString) *
                  10 ** Number(tokendict[tokenOut].decimals);
                finalAmountIn = calculateScaleInput(
                  BigInt(desiredOutput),
                  Number(scaleStart),
                  Number(scaleEnd),
                  Number(scaleOrders),
                  Number(scaleSkew)
                );
              }
              let o = calculateScaleOutput(
                finalAmountIn,
                Number(scaleStart),
                Number(scaleEnd),
                Number(scaleOrders),
                Number(scaleSkew)
              );

              const orderbatch: Record<string, any> = {}

              o.forEach(order => {
                const k = activeMarket?.address
                if (!orderbatch[k]) orderbatch[k] = []
                orderbatch[k].push({
                  isRequireSuccess: false,
                  action: tokenIn == activeMarket.quoteAddress ? ((addliquidityonly) ? 2 : 4) : ((addliquidityonly) ? 3 : 5),
                  param1: order[0], // price
                  param2: tokenIn == activeMarket.quoteAddress ? order[2] : order[1], // size/id
                  param3: BigInt(0),  // cloid or extra id
                })
              })

              const batches: any = Object.entries(orderbatch).map(([market, actions]) => ({
                market: market as `0x${string}`,
                actions,
                options: BigInt(tokenIn == eth ? (1n << 48n) : 0)
              }))

              let hash;
              setIsSigning(true)
              if (client) {
                txPending.current = true
              }
              try {
                if (tokenIn == eth) { // sell
                  hash = await sendUserOperationAsync({
                    uo: multiBatchOrders(
                      router,
                      BigInt(finalAmountIn),
                      batches,
                      BigInt(Math.floor(Date.now() / 1000) + 900),
                      usedRefAddress
                    )
                  })
                } else {
                  if (allowance < finalAmountIn) {
                    if (client) {
                      let uo = []
                      uo.push(approve(
                        tokenIn as `0x${string}`,
                        router,
                        maxUint256,
                      ))
                      uo.push(multiBatchOrders(
                        router,
                        BigInt(0),
                        batches,
                        BigInt(Math.floor(Date.now() / 1000) + 900),
                        usedRefAddress
                      ))
                      hash = await sendUserOperationAsync({ uo: uo })
                      newTxPopup(
                        hash,
                        'approve',
                        tokenIn,
                        '',
                        customRound(
                          Number(finalAmountIn) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ),
                        0,
                        '',
                        router,
                      );
                    }
                    else {
                      hash = await sendUserOperationAsync({
                        uo: approve(
                          tokenIn as `0x${string}`,
                          router,
                          maxUint256,
                        )
                      })
                      newTxPopup(
                        hash,
                        'approve',
                        tokenIn,
                        '',
                        customRound(
                          Number(finalAmountIn) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ),
                        0,
                        '',
                        router,
                      );
                    }
                  }
                  if (!client || !(allowance < finalAmountIn)) {
                    hash = await sendUserOperationAsync({
                      uo: multiBatchOrders(
                        router,
                        BigInt(0),
                        batches,
                        BigInt(Math.floor(Date.now() / 1000) + 900),
                        usedRefAddress
                      )
                    }, 10000000n)
                  }
                }
                if (!client && hash) {
                  txPending.current = true
                }
                setInputString('');
                setamountIn(BigInt(0));
                setamountOutSwap(BigInt(0));
                setoutputString('');
                setScaleButtonDisabled(true);
                setScaleButton(0);
                setScaleStart(BigInt(0));
                setScaleEnd(BigInt(0));
                setScaleStartString('');
                setScaleEndString('');
                setScaleSkew(1);
                setScaleSkewString('1.00');
                setScaleOrders(BigInt(0));
                setScaleOrdersString('');
                setSliderPercent(0);
                setIsSigning(false)
                const slider = document.querySelector('.balance-amount-slider');
                const popup = document.querySelector('.slider-percentage-popup');
                if (slider && popup) {
                  (popup as HTMLElement).style.left = `${15 / 2}px`;
                }
                await refetch()
                txPending.current = false
              } catch (error) {
                if (!(error instanceof TransactionExecutionError)) {
                  newTxPopup(
                    hash,
                    "limitFailed",
                    tokenIn == eth ? eth : tokenIn,
                    tokenOut == eth ? eth : tokenOut,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn == eth ? eth : tokenIn].decimals), 3),
                    customRound(Number(amountOutSwap) / 10 ** Number(tokendict[tokenOut == eth ? eth : tokenOut].decimals), 3),
                    "",
                    "",
                  );
                }
              } finally {
                txPending.current = false
                setIsSigning(false)
              }
            } else {
              !connected ? setpopup(4) : handleSetChain();
            }
          }}
          disabled={scaleButtonDisabled || isSigning}
        >
          {isSigning ? (
            <div className="button-content">
              <div className="loading-spinner" />
              {validOneCT ? t('') : t('signTransaction')}
            </div>
          ) : scaleButton == 0 ? (
            t('enterAmount')
          ) : scaleButton == 1 ? (
            t('enterStartPrice')
          ) : scaleButton == 2 ? (
            t('enterEndPrice')
          ) : scaleButton == 3 ? (
            t('startPriceHigh')
          ) : scaleButton == 4 ? (
            t('startPriceLow')
          ) : scaleButton == 5 ? (
            t('endPriceHigh')
          ) : scaleButton == 6 ? (
            t('endPriceLow')
          ) : scaleButton == 7 ? (
            t('scaleMinSize')
          ) : scaleButton == 8 ? (
            t('enterOrders')
          ) : scaleButton == 9 ? (
            t('enterSkew')
          ) : scaleButton == 10 ? (
            t('insufficient') + (tokendict[tokenIn].ticker || '?') + ' ' + t('bal')
          ) : scaleButton == 11 ? (
            `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
          ) : scaleButton == 12 ? (
            t('connectWallet')
          ) : scaleButton == 13 ? (
            client ? (tokenIn == activeMarket.quoteAddress ? t('buy') : t('sell')) + ' ' + activeMarket.baseAsset : t('approve')
          ) : (
            (tokenIn == activeMarket.quoteAddress ? t('buy') : t('sell')) + ' ' + activeMarket.baseAsset
          )}
        </button>
      </div>
      <div className="limit-info-rectangle">
        <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={t('addLiquidityOnly')}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {t('addLiquidityOnlySubtitle')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <ToggleSwitch
            checked={addliquidityonly}
            onChange={() => {
              const newValue = !addliquidityonly;
              setAddLiquidityOnly(newValue);
              localStorage.setItem(
                'crystal_add_liquidity_only',
                JSON.stringify(newValue),
              );
            }}
          />
        </div>
        <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={`${t('fee')} (0.00%)`}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {t('makerfeeexplanation')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <div className="value-container">
            {`${0} ${tokendict[tokenIn].ticker}`}
          </div>
        </div>
      </div>
      {simpleView && <div className="orders-info-rectangle">
        <SimpleOrdersContainer
          orders={orders}
          router={router}
          address={address}
          refetch={refetch}
          sendUserOperationAsync={sendUserOperationAsync}
          setChain={handleSetChain}
        />
      </div>}
    </div>
  );

  const renderChartComponent = useMemo(() => (
    <ChartComponent
      activeMarket={activeMarket}
      tradehistory={tradehistory}
      isMarksVisible={isMarksVisible}
      setIsMarksVisible={setIsMarksVisible}
      orders={orders}
      isOrdersVisible={isOrdersVisible}
      showChartOutliers={showChartOutliers}
      setShowChartOutliers={setShowChartOutliers}
      router={router}
      refetch={refetch}
      sendUserOperationAsync={sendUserOperationAsync}
      setChain={handleSetChain}
      usedRefAddress={usedRefAddress}
      data={chartData}
      setData={setChartData}
      realtimeCallbackRef={realtimeCallbackRef}
      limitPrice={limitPrice}
      updateLimitAmount={updateLimitAmount}
      tokenIn={tokenIn}
      amountIn={amountIn}
      isLimitOrderMode={location.pathname.slice(1) === 'limit'}
      selectedInterval={selectedInterval}
      setSelectedInterval={setSelectedInterval}
    />
  ), [
    activeMarket,
    tradehistory,
    isMarksVisible,
    orders,
    isOrdersVisible,
    showChartOutliers,
    router,
    refetch,
    handleSetChain,
    usedRefAddress,
    chartData,
    realtimeCallbackRef,
    limitPrice,
    updateLimitAmount,
    tokenIn,
    amountIn,
    location.pathname,
    selectedInterval
  ]);

  const TradeLayout = (swapComponent: JSX.Element) => (
    <div className="trade-container">
      {windowWidth <= 1020 && (
        <div className="mobile-nav" data-active={mobileView}>
          <div className="mobile-nav-inner">
            <button
              className={`mobile-nav-link ${mobileView === 'chart' ? 'active' : ''}`}
              onClick={() => setMobileView('chart')}
            >
              {t('chart')}
            </button>
            <button
              className={`mobile-nav-link ${mobileView === 'orderbook' ? 'active' : ''}`}
              onClick={() => {
                setMobileView('orderbook');
                setOBTab('orderbook');
              }}
            >
              {t('orderbook')}
            </button>
            <button
              className={`mobile-nav-link ${mobileView === 'trades' ? 'active' : ''}`}
              onClick={() => {
                setMobileView('trades');
                setOBTab('trades');
              }}
            >
              {t('trades')}
            </button>
            <div className="mobile-sliding-indicator" />
          </div>
        </div>
      )}
      <div
        className={`main-content-wrapper ${simpleView ? 'simple-view' : ''}`}
        style={{
          flexDirection:
            spotLayoutSettings === 'alternative' ? 'row-reverse' : 'row',
        }}
      >
        {simpleView ? (
          <>
            <div className="right-column">{swapComponent}</div>
          </>
        ) : (
          <>
            <div className="chartandorderbookandordercenter">
              <div className="chartandorderbook">
                <ChartOrderbookPanel
                  layoutSettings={spotLayoutSettings}
                  orderbookPosition={spotOrderbookPosition}
                  orderdata={{
                    roundedBuyOrders: roundedBuyOrders?.orders,
                    roundedSellOrders: roundedSellOrders?.orders,
                    spreadData,
                    priceFactor: Number(markets[roundedBuyOrders?.key]?.priceFactor),
                    marketType: markets[roundedBuyOrders?.key]?.marketType,
                    symbolIn: markets[roundedBuyOrders?.key]?.quoteAsset,
                    symbolOut: markets[roundedBuyOrders?.key]?.baseAsset,
                  }}
                  windowWidth={windowWidth}
                  mobileView={mobileView}
                  isOrderbookVisible={isOrderbookVisible}
                  orderbookWidth={orderbookWidth}
                  setOrderbookWidth={setOrderbookWidth}
                  obInterval={obInterval}
                  amountsQuote={roundedBuyOrders?.amountsQuote}
                  setAmountsQuote={setAmountsQuote}
                  obtrades={trades}
                  setOBInterval={setOBInterval}
                  baseInterval={baseInterval}
                  viewMode={viewMode}
                  setViewMode={setViewMode}
                  activeTab={obTab}
                  setActiveTab={setOBTab}
                  updateLimitAmount={updateLimitAmount}
                  renderChartComponent={renderChartComponent}
                  reserveQuote={reserveQuote}
                  reserveBase={reserveBase}
                />
              </div>
              <div
                className={`oc-spacer ${!isOrderCenterVisible ? 'collapsed' : ''}`}
              >
                <div
                  className="ordercenter-drag-handle"
                  onMouseDown={handleVertMouseDown}
                />
              </div>
              <OrderCenter
                orders={orders}
                tradehistory={tradehistory}
                canceledorders={canceledorders}
                router={router}
                address={address}
                trades={tradesByMarket}
                currentMarket={
                  activeMarketKey.replace(
                    new RegExp(
                      `^${wethticker}|${wethticker}$`,
                      'g'
                    ),
                    ethticker
                  )
                }
                orderCenterHeight={orderCenterHeight}
                hideBalances={true}
                tokenList={memoizedTokenList}
                onMarketSelect={onMarketSelect}
                setSendTokenIn={setSendTokenIn}
                setpopup={setpopup}
                sortConfig={memoizedSortConfig}
                onSort={emptyFunction}
                tokenBalances={tokenBalances}
                activeSection={activeSection}
                setActiveSection={setActiveSection}
                filter={filter}
                setFilter={setFilter}
                onlyThisMarket={onlyThisMarket}
                setOnlyThisMarket={setOnlyThisMarket}
                refetch={refetch}
                sendUserOperationAsync={sendUserOperationAsync}
                setChain={handleSetChain}
                isVertDragging={isVertDragging}
                isOrderCenterVisible={isOrderCenterVisible}
                onLimitPriceUpdate={setCurrentLimitPrice}
                openEditOrderPopup={openEditOrderPopup}
                openEditOrderSizePopup={openEditOrderSizePopup}
                marketsData={marketsData}
              />
            </div>
            {windowWidth > 1020 && (
              <div className="right-column"> {swapComponent} </div>
            )}
          </>
        )}
      </div>
    </div>
  );

  return (
    <div className="app-wrapper" key={language}>
      <NavigationProgress location={location} />
      <MemeTransactionPopupManager trackedWallets={trackedWallets} />

      {Modals}
      <SidebarNav simpleView={simpleView} setSimpleView={setSimpleView} />
      {windowWidth <= 1020 && !simpleView && ['swap', 'limit', 'send', 'scale', 'market'].includes(location.pathname.slice(1)) && (
        <>
          <div
            className={`right-column ${showTrade ? 'show' : ''} ${isMobileDragging ? 'dragging' : ''}`}
            style={{
              transform: showTrade && isMobileDragging
                ? `translateY(${mobileDragY}px)`
                : showTrade
                  ? 'translateY(0)'
                  : 'translateY(calc(100% - 91px))'
            }}
            onTouchStart={(e: React.TouchEvent) => {
              if (windowWidth <= 1020 && showTrade) {
                setMobileStartY(e.touches[0].clientY);
                setIsMobileDragging(true);
              }
            }}
            onTouchMove={(e: React.TouchEvent) => {
              if (!isMobileDragging || windowWidth > 1020 || !showTrade) return;

              const currentY = e.touches[0].clientY;
              const deltaY = currentY - mobileStartY;

              if (deltaY > 0) {
                setMobileDragY(deltaY);
              }
            }}
            onTouchEnd={() => {
              if (!isMobileDragging || windowWidth > 1020) return;

              setIsMobileDragging(false);

              if (mobileDragY > 100) {
                setShowTrade(false);
                document.body.style.overflow = 'auto';
                document.querySelector('.right-column')?.classList.add('hide');
                document.querySelector('.right-column')?.classList.remove('show');
                document.querySelector('.trade-mobile-switch')?.classList.remove('open');
              }
              setMobileDragY(0);
            }}
          >
            <div className="mobile-drag-handle">
              <div className="drag-indicator"></div>
            </div>

            {location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market' ? swap : location.pathname.slice(1) == 'limit' ? limit : location.pathname.slice(1) == 'send' ? send : scale}
          </div>
        </>
      )}
      <Header
        setTokenIn={setTokenIn}
        setTokenOut={setTokenOut}
        setorders={setorders}
        settradehistory={settradehistory}
        settradesByMarket={settradesByMarket}
        setcanceledorders={setcanceledorders}
        setpopup={setpopup}
        setChain={handleSetChain}
        account={{
          connected: connected,
          address: address,
          chainId: userchain,
        }}
        activechain={activechain}
        tokenIn={tokenIn}
        setShowTrade={setShowTrade}
        simpleView={simpleView}
        setSimpleView={setSimpleView}
        tokendict={tokendict}
        transactions={transactions}
        activeMarket={activeMarket}
        orderdata={{
          liquidityBuyOrders,
          liquiditySellOrders,
          reserveQuote,
          reserveBase
        }}
        onMarketSelect={onMarketSelect}
        marketsData={sortedMarkets}
        tradesloading={tradesloading}
        tradesByMarket={tradesByMarket}
        currentWalletIcon={currentWalletIcon}
        subWallets={subWallets}
        walletTokenBalances={walletTokenBalances}
        activeWalletPrivateKey={oneCTSigner}
        setOneCTSigner={setOneCTSigner}
        refetch={refetch}
        isBlurred={isBlurred}
        terminalRefetch={terminalRefetch}
        tokenList={memoizedTokenList}
        logout={logout}
        tokenBalances={tokenBalances}
        lastRefGroupFetch={lastRefGroupFetch}
        tokenData={token}
        monUsdPrice={monUsdPrice}
        sendUserOperationAsync={sendUserOperationAsync}
        setTokenData={setTokenData}
        quickAmounts={quickAmounts}
        setQuickAmount={setQuickAmount}
        activePresets={activePresets}
        setActivePreset={setActivePreset}
        handleInputFocus={handleInputFocus}
        buyPresets={buyPresetsWithAmount}
        sellPresets={sellPresets}
        perpsActiveMarketKey={perpsActiveMarketKey}
        setperpsActiveMarketKey={handlePerpsMarketSelect}
        perpsMarketsData={perpsMarketsData}
        perpsFilterOptions={perpsFilterOptions}
        externalUserStats={memeUserStats}
        lastNonceGroupFetch={lastNonceGroupFetch}
        scaAddress={scaAddress}
        onSharePNL={handleSharePNL}
        client={client}
      />
      <div className="app-container" style={{
        marginLeft: (() => {
          let total = 0;
          if (trackerWidgetSnap === 'left') total += trackerWidgetWidth;
          if (spectraWidgetSnap === 'left') total += spectraWidgetWidth;
          if (pnlWidgetSnap === 'left') total += pnlWidgetWidth;
          if (walletTrackerWidgetSnap === 'left') total += walletTrackerWidgetWidth;
          return total > 0 ? `${total}px` : '';
        })(),
        marginRight: (() => {
          let total = 0;
          if (trackerWidgetSnap === 'right') total += trackerWidgetWidth;
          if (spectraWidgetSnap === 'right') total += spectraWidgetWidth;
          if (pnlWidgetSnap === 'right') total += pnlWidgetWidth;
          if (walletTrackerWidgetSnap === 'right') total += walletTrackerWidgetWidth;
          return total > 0 ? `${total}px` : '';
        })(),
      }}>
        <Routes>
          <Route path="/" element={<Navigate to="/spectra" replace />} />
          <Route path="*" element={<Navigate to="/spectra" replace />} />
          <Route path="/spectra"
            element={
              <TokenExplorer
                setpopup={setpopup}
                appliedFilters={appliedExplorerFilters}
                onOpenFiltersForColumn={handleOpenFiltersForColumn}
                sendUserOperationAsync={sendUserOperationAsync}
                terminalQueryData={terminalQueryData}
                terminalRefetch={terminalRefetch}
                setTokenData={setTokenData}
                monUsdPrice={monUsdPrice}
                subWallets={subWallets}
                walletTokenBalances={walletTokenBalances}
                activeWalletPrivateKey={oneCTSigner}
                refetch={refetch}
                activechain={activechain}
                logout={logout}
                lastRefGroupFetch={lastRefGroupFetch}
                lastNonceGroupFetch={lastNonceGroupFetch}
                isBlurred={isBlurred}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                quickAmounts={quickAmounts}
                setQuickAmounts={setQuickAmounts}
                alertSettingsRef={alertSettingsRef}
                pausedColumnRef={pausedColumnRef}
                pausedTokenQueueRef={pausedTokenQueueRef}
                dispatch={dispatch}
                hidden={hidden}
                tokensByStatus={tokensByStatus}
                alertSettings={alertSettings}
                setAlertSettings={setAlertSettings}
                loading={teLoading}
                isLoading={isTokenExplorerLoading}
                nonces={nonces}
                selectedWallets={selectedWallets}
                setSelectedWallets={setSelectedWallets}
                createSubWallet={createSubWallet}
                setOneCTDepositAddress={setOneCTDepositAddress}
              />
            }
          />
          <Route
            path="/meme/:tokenAddress"
            element={
              <MemeInterface
                sliderMode={'spot' === 'spot' ? spotSliderMode : trenchesSliderMode}
                sliderPresets={'spot' === 'spot' ? spotSliderPresets : trenchesSliderPresets}
                sliderIncrement={'spot' === 'spot' ? spotSliderIncrement : trenchesSliderIncrement}
                marketsData={marketsData}
                onMarketSelect={onMarketSelect}
                setSendTokenIn={setSendTokenIn}
                setpopup={setpopup}
                tokenList={memoizedTokenList}
                sendUserOperationAsync={sendUserOperationAsync}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                setChain={handleSetChain}
                address={address}
                subWallets={subWallets}
                walletTokenBalances={walletTokenBalances}
                activeWalletPrivateKey={oneCTSigner}
                refetch={refetch}
                isBlurred={isBlurred}
                tokendict={tokendict}
                wethticker={wethticker}
                ethticker={ethticker}
                terminalRefetch={terminalRefetch}
                setTokenData={setTokenData}
                monUsdPrice={monUsdPrice}
                buyPresets={buyPresetsWithAmount}
                sellPresets={sellPresets}
                monPresets={monPresets}
                setMonPresets={setMonPresets}
                onTokenDataChange={setCurrentTokenData}
                nonces={nonces}
                trades={memeTrades}
                setTrades={setMemeTrades}
                holders={memeHolders}
                topTraders={memeTopTraders}
                positions={memePositions}
                devTokens={memeDevTokens}
                top10HoldingPercentage={memeTop10HoldingPct}
                userStats={memeUserStats}
                realtimeCallbackRef={memeRealtimeCallbackRef}
                selectedInterval={memeSelectedInterval}
                setSelectedInterval={setMemeSelectedInterval}
                chartData={chartData}
                page={page}
                similarTokens={memeSimilarTokens}
                token={token}
                selectedWallets={selectedWallets}
                setSelectedWallets={setSelectedWallets}
                selectedIntervalRef={memeSelectedIntervalRef}
                isTerminalDataFetching={isTerminalDataFetching}
                trackedAddresses={trackedAddresses}
                setTrackedAddresses={setTrackedAddresses}
                isLoadingTrades={isLoadingTrades}
                setIsLoadingTrades={setIsLoadingTrades}
                trackedWalletsRef={trackedWalletsRef}
                createSubWallet={createSubWallet}
                setOneCTDepositAddress={setOneCTDepositAddress}
                scaAddress={scaAddress}
                signTypedDataAsync={signTypedDataUnified}
                transactionSounds={transactionSounds}
                buySound={buySound}
                sellSound={sellSound}
                volume={volume}
              />
            }
          />
          <Route path="/sneakyboard"
            element={
              <TokenBoard
                sendUserOperationAsync={sendUserOperationAsync}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                setChain={handleSetChain}
                setpopup={setpopup}
                terminalQueryData={terminalQueryData}
                terminalRefetch={terminalRefetch}
                setTokenData={setTokenData}
                monUsdPrice={monUsdPrice}
                tokens={tokensByStatus}
              />
            }
          />
          <Route path="/sneakyboard/:tokenAddress"
            element={
              <TokenDetail
                sendUserOperationAsync={sendUserOperationAsync}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                setChain={handleSetChain}
                setpopup={setpopup}
                terminalQueryData={terminalQueryData}
                terminalRefetch={terminalRefetch}
                walletTokenBalances={walletTokenBalances}
                monUsdPrice={monUsdPrice}
                token={token}
                selectedInterval={memeSelectedInterval}
                setSelectedInterval={setMemeSelectedInterval}
                holders={memeHolders}
                chartData={chartData}
                trades={memeTrades}
                realtimeCallbackRef={memeRealtimeCallbackRef}
                selectedIntervalRef={memeSelectedIntervalRef}
              />
            }
          />
          <Route path="/sneakyearn" element={<Navigate to="/earn/vaults" replace />} />
          <Route path="/sneakyearn/*"
            element={
              <Earn
                setpopup={setpopup}
                onSelectToken={(token) => {
                  setSelectedToken(token);
                  setTimeout(() => setSelectedToken(null), 100);
                }}
                setOnSelectTokenCallback={setOnSelectTokenCallback}
                selectedToken={selectedToken}
                tokenBalances={tokenBalances}
                tokendict={tokendict}
                address={address}
                connected={connected}
                refetch={refetch}
                tradesByMarket={tradesByMarket}
                markets={markets}
                usdc={usdc}
                wethticker={wethticker}
                ethticker={ethticker}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                sendUserOperationAsync={sendUserOperationAsync}
                activechain={activechain}
                setChain={handleSetChain}
                selectedVault={selectedVault}
                setselectedVault={setselectedVault}
                isVaultDepositSigning={isVaultDepositSigning}
                setIsVaultDepositSigning={setIsVaultDepositSigning}
                isVaultWithdrawSigning={isVaultWithdrawSigning}
                setIsVaultWithdrawSigning={setIsVaultWithdrawSigning}
                crystalVaultsAddress={crystalVaults}
                router={router}
                formatUSDDisplay={formatUSDDisplay}
                calculateUSDValue={calculateUSDValue}
                getMarket={getMarket}
                vaultList={vaultList}
                isLoading={isVaultsLoading}
                depositors={depositors}
                depositHistory={depositHistory}
                withdrawHistory={withdrawHistory}
                openOrders={openOrders}
                allOrders={_allOrders}
                selectedVaultStrategy={selectedVaultStrategy}
                setSelectedVaultStrategy={setSelectedVaultStrategy}
                valueSeries={valueSeries}
                pnlSeries={pnlSeries}
                seriesLoading={seriesLoading}
                seriesError={seriesError}
                activeVaultPerformance={activeVaultPerformance}
                vaultStrategyTimeRange={vaultStrategyTimeRange}
                setVaultStrategyTimeRange={setVaultStrategyTimeRange}
                vaultStrategyChartType={vaultStrategyChartType}
                setVaultStrategyChartType={setVaultStrategyChartType}
                chartData={vaultChartData}
              />
            } />
          <Route path="/sneakyearn/vaults/:vaultAddress"
            element={
              <Earn
                setpopup={setpopup}
                onSelectToken={(token) => {
                  setSelectedToken(token);
                  setTimeout(() => setSelectedToken(null), 100);
                }}
                setOnSelectTokenCallback={setOnSelectTokenCallback}
                selectedToken={selectedToken}
                tokenBalances={tokenBalances}
                tokendict={tokendict}
                address={address}
                connected={connected}
                refetch={refetch}
                tradesByMarket={tradesByMarket}
                markets={markets}
                usdc={usdc}
                wethticker={wethticker}
                ethticker={ethticker}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                sendUserOperationAsync={sendUserOperationAsync}
                activechain={activechain}
                setChain={handleSetChain}
                selectedVault={selectedVault}
                setselectedVault={setselectedVault}
                isVaultDepositSigning={isVaultDepositSigning}
                setIsVaultDepositSigning={setIsVaultDepositSigning}
                isVaultWithdrawSigning={isVaultWithdrawSigning}
                setIsVaultWithdrawSigning={setIsVaultWithdrawSigning}
                crystalVaultsAddress={crystalVaults}
                router={router}
                formatUSDDisplay={formatUSDDisplay}
                calculateUSDValue={calculateUSDValue}
                getMarket={getMarket}
                vaultList={vaultList}
                isLoading={isVaultsLoading}
                depositors={depositors}
                depositHistory={depositHistory}
                withdrawHistory={withdrawHistory}
                openOrders={openOrders}
                allOrders={_allOrders}
                selectedVaultStrategy={selectedVaultStrategy}
                setSelectedVaultStrategy={setSelectedVaultStrategy}
                valueSeries={valueSeries}
                pnlSeries={pnlSeries}
                seriesLoading={seriesLoading}
                seriesError={seriesError}
                activeVaultPerformance={activeVaultPerformance}
                vaultStrategyTimeRange={vaultStrategyTimeRange}
                setVaultStrategyTimeRange={setVaultStrategyTimeRange}
                vaultStrategyChartType={vaultStrategyChartType}
                setVaultStrategyChartType={setVaultStrategyChartType}
                chartData={vaultChartData}
              />
            } />
          <Route path="/portfolio"
            element={
              <Portfolio
                orders={orders}
                tradehistory={tradehistory}
                trades={tradesByMarket}
                canceledorders={canceledorders}
                tokenList={memoizedTokenList}
                router={router}
                address={address ?? ''}
                isBlurred={isBlurred}
                setIsBlurred={setIsBlurred}
                onMarketSelect={onMarketSelect}
                setSendTokenIn={setSendTokenIn}
                setpopup={setpopup}
                tokenBalances={tokenBalances}
                totalAccountValue={totalAccountValue}
                setTotalVolume={setTotalVolume}
                totalVolume={totalVolume}
                chartData={typeof totalAccountValue === 'number' ? [
                  ...portGraph.slice(0, -1),
                  {
                    ...portGraph[portGraph.length - 1],
                    value: totalAccountValue,
                  },
                ] : portGraph}
                portChartLoading={portChartLoading}
                chartDays={chartDays}
                setChartDays={setChartDays}
                totalClaimableFees={totalClaimableFees}
                claimableFees={claimableFees}
                refLink={refLink}
                setRefLink={setRefLink}
                filter={filter}
                setFilter={setFilter}
                onlyThisMarket={onlyThisMarket}
                setOnlyThisMarket={setOnlyThisMarket}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                  logout: logout,
                }}
                refetch={refetch}
                sendUserOperationAsync={sendUserOperationAsync}
                setChain={handleSetChain}
                marketsData={marketsData}
                usedRefLink={usedRefLink}
                setUsedRefLink={setUsedRefLink}
                setClaimableFees={setClaimableFees}
                setUsedRefAddress={setUsedRefAddress}
                client={client}
                activechain={activechain}
                markets={markets}
                tokendict={tokendict}
                subWallets={subWallets}
                setSubWallets={saveSubWallets}
                walletTokenBalances={walletTokenBalances}
                walletsLoading={walletsLoading}
                terminalRefetch={terminalRefetch}
                isVaultDepositSigning={isVaultDepositSigning}
                setIsVaultDepositSigning={setIsVaultDepositSigning}
                handleSetChain={handleSetChain}
                createSubWallet={createSubWallet}
                Wallet={Wallet}
                setShowRefModal={undefined}
                lastRefGroupFetch={lastRefGroupFetch}
                scaAddress={scaAddress}
                nonces={nonces}
                setOneCTDepositAddress={setOneCTDepositAddress}
                positions={memePositions}
                monUsdPrice={monUsdPrice}
                selectedWallets={selectedWallets}
                setSelectedWallets={setSelectedWallets}
                onTrenchesWalletsChange={handleTrenchesWalletsChange}
                trenchesPositions={trenchesPositions}
                trenchesLoading={trenchesLoading}
                refreshTrenchesData={() => fetchTrenchesPositions(trenchesSelectedWallets)}
              />
            } />
          <Route path="/trackers"
            element={
              <Tracker
                monUsdPrice={monUsdPrice}
                walletTokenBalances={walletTokenBalances}
                activechain={activechain}
                settings={settings}
                allTrades={trackedWalletTrades}
                tokenList={memoizedTokenList}
                marketsData={marketsData}
                tradesByMarket={tradesByMarket}
                setpopup={setpopup}
                currentPopup={popup}
                sendUserOperationAsync={sendUserOperationAsync}
                terminalRefetch={terminalRefetch}
                nonces={nonces}
                subWallets={subWallets}
                activeWalletPrivateKey={oneCTSigner}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                selectedWallets={selectedWallets}
                onMarketSelect={onMarketSelect}
                setSendTokenIn={setSendTokenIn}
                positions={memePositions}
                trackedWalletsRef={trackedWalletsRef}
              />
            } />
          <Route path="/perps" element={<Navigate to={`/perps/${perpsActiveMarketKey}`} replace />} />
          <Route path="/perps/:marketKey"
            element={
              <Perps
                layoutSettings={perpsLayoutSettings}
                orderbookPosition={perpsOrderbookPosition}
                windowWidth={windowWidth}
                mobileView={mobileView}
                isOrderbookVisible={isOrderbookVisible}
                orderbookWidth={orderbookWidth}
                setOrderbookWidth={setOrderbookWidth}
                viewMode={viewMode}
                setViewMode={setViewMode}
                activeTab={obTab}
                setActiveTab={setOBTab}
                router={router}
                address={scaAddress}
                orderCenterHeight={orderCenterHeight}
                setSendTokenIn={setSendTokenIn}
                setpopup={setpopup}
                sortConfig={memoizedSortConfig}
                onSort={emptyFunction}
                activeSection={activeSection}
                setActiveSection={setActiveSection}
                filter={filter}
                setFilter={setFilter}
                onlyThisMarket={onlyThisMarket}
                setOnlyThisMarket={setOnlyThisMarket}
                refetch={refetch}
                sendUserOperationAsync={sendUserOperationAsync}
                setChain={handleSetChain}
                isOrderCenterVisible={isOrderCenterVisible}
                openEditOrderPopup={openEditOrderPopup}
                openEditOrderSizePopup={openEditOrderSizePopup}
                wethticker={wethticker}
                ethticker={ethticker}
                memoizedSortConfig={memoizedSortConfig}
                emptyFunction={emptyFunction}
                handleSetChain={handleSetChain}
                selectedInterval={selectedInterval}
                setSelectedInterval={setSelectedInterval}
                perpsActiveMarketKey={perpsActiveMarketKey}
                setperpsActiveMarketKey={setperpsActiveMarketKey}
                perpsMarketsData={perpsMarketsData}
                setPerpsMarketsData={setPerpsMarketsData}
                perpsFilterOptions={perpsFilterOptions}
                setPerpsFilterOptions={setPerpsFilterOptions}
                signMessageAsync={signMessageAsync}
                leverage={perpsLeverage}
                setLeverage={setPerpsLeverage}
                userLeverage={userLeverage}
                setUserLeverage={setUserLeverage}
                signer={perpsKeystore}
                setSigner={setPerpsKeystore}
                setOrderCenterHeight={setOrderCenterHeight}
                isMarksVisible={isMarksVisible}
                setIsMarksVisible={setIsMarksVisible}
                setPerpsLimitChase={setPerpsLimitChase}
                perpsLimitChase={perpsLimitChase}
                handlePerpsMarketSelect={handlePerpsMarketSelect}
              />
            } />
          <Route path="/leaderboard"
            element={
              <Leaderboard
                setpopup={setpopup}
                orders={orders}
                address={address}
                username={username}
              />
            } />
          <Route path="/referrals"
            element={
              <Referrals
                tokenList={memoizedTokenList}
                markets={markets}
                router={router}
                address={address}
                usedRefLink={usedRefLink}
                setUsedRefLink={setUsedRefLink}
                usedRefAddress={usedRefAddress}
                setUsedRefAddress={setUsedRefAddress}
                totalClaimableFees={totalClaimableFees}
                claimableFees={claimableFees || {}}
                refLink={refLink}
                setRefLink={setRefLink}
                showModal={showModal}
                setShowModal={setShowModal}
                setChain={handleSetChain}
                setpopup={setpopup}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                  logout: logout,
                }}
                refetch={refetch}
                sendUserOperationAsync={sendUserOperationAsync}
                waitForTxReceipt={(hash: string) => waitForTransactionReceipt(config, { hash: hash as `0x${string}` })}
                client={client}
                monUsdPrice={monUsdPrice}
              />
            } />
          <Route path="/sneakylaunchpad"
            element={
              <Launchpad
                address={address}
                sendUserOperationAsync={sendUserOperationAsync}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                  logout: logout,
                }}
                setChain={handleSetChain}
                setpopup={setpopup}
              />
            } />
          <Route path="/sneakylending"
            element={
              <EarnVaults
                setpopup={setpopup}
                onSelectToken={(token) => {
                  setSelectedToken(token);
                  setTimeout(() => setSelectedToken(null), 100);
                }}
                setOnSelectTokenCallback={setOnSelectTokenCallback}
                selectedToken={selectedToken}
                tokenBalances={tokenBalances}
                tokendict={tokendict}
                address={address}
                connected={connected}
                refetch={refetch}
                tradesByMarket={tradesByMarket}
                markets={markets}
                usdc={usdc}
                wethticker={wethticker}
                ethticker={ethticker}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                sendUserOperationAsync={sendUserOperationAsync}
                activechain={activechain}
                setChain={handleSetChain}
              />
            } />
          <Route path="/swap" element={TradeLayout(tempswap)} />
          <Route path="/sneakymarket" element={TradeLayout(swap)} />
          <Route path="/sneakylimit" element={TradeLayout(limit)} />
          <Route path="/send" element={TradeLayout(send)} />
          <Route path="/sneakyscale" element={TradeLayout(scale)} />
        </Routes>
        <TransactionPopupManager
          transactions={transactions}
          setTransactions={setTransactions}
          tokendict={tokendict}
          showPreview={showPreview}
          previewPosition={previewPosition}
          previewExiting={previewExiting}
        />
        <TrackerWidget
          isOpen={isTrackerWidgetOpen}
          onClose={() => setIsTrackerWidgetOpen(false)}
          onSnapChange={handleTrackerWidgetSnapChange}
        />
        <SpectraWidget
          isOpen={isSpectraWidgetOpen}
          onClose={() => setIsSpectraWidgetOpen(false)}
          onSnapChange={handleSpectraWidgetSnapChange}
          tokensByStatus={tokensByStatus}
          monUsdPrice={monUsdPrice}
          routerAddress={settings.chainConfig[activechain]?.launchpadRouter?.toLowerCase()}
          sendUserOperationAsync={sendUserOperationAsync}
          showLoadingPopup={showLoadingPopup}
          updatePopup={updatePopup}
          onOpenFiltersForColumn={handleOpenFiltersForColumn}
          setTokenData={setTokenData}
          selectedWallets={selectedWallets}
          subWallets={subWallets}
          walletTokenBalances={walletTokenBalances}
          activeWalletPrivateKey={oneCTSigner}
          tokenList={memoizedTokenList}
          activechain={activechain}
          nonces={nonces}
          account={{
            connected: connected,
            address: address,
            chainId: userchain,
          }}
          terminalRefetch={terminalRefetch}
          hidden={hidden}
          dispatch={dispatch}
          pausedTokenQueueRef={pausedTokenQueueRef}
          pausedColumnRef={pausedColumnRef}
        />
        <PNLWidget
          isOpen={isPNLWidgetOpen}
          onClose={() => setIsPNLWidgetOpen(false)}
          onSnapChange={handlePNLWidgetSnapChange}
        />
        <WalletTrackerWidget
          isOpen={isWalletTrackerWidgetOpen}
          onClose={() => setIsWalletTrackerWidgetOpen(false)}
          onSnapChange={handleWalletTrackerWidgetSnapChange}
          monUsdPrice={monUsdPrice}
          walletTokenBalances={walletTokenBalances}
          activechain={activechain}
          settings={settings}
          allTrades={trackedWalletTrades}
          tokenList={memoizedTokenList}
          marketsData={marketsData}
          tradesByMarket={tradesByMarket}
          setpopup={setpopup}
          currentPopup={popup}
          sendUserOperationAsync={sendUserOperationAsync}
          terminalRefetch={terminalRefetch}
          nonces={nonces}
          subWallets={subWallets}
          activeWalletPrivateKey={oneCTSigner}
          account={{
            connected: connected,
            address: address,
            chainId: userchain,
          }}
          selectedWallets={selectedWallets}
        />
      </div>
      <Footer
        subWallets={subWallets}
        selectedWallets={selectedWallets}
        setSelectedWallets={setSelectedWallets}
        walletTokenBalances={walletTokenBalances}
        address={address}
        activeChain={activechain}
        monUsdPrice={monUsdPrice}
        isTrackerWidgetOpen={isTrackerWidgetOpen}
        onToggleTrackerWidget={setIsTrackerWidgetOpen}
        isSpectraWidgetOpen={isSpectraWidgetOpen}
        onToggleSpectraWidget={(open: any) => {
          if (!open && spectraWidgetSnap) {
            setSpectraWidgetSnap(null);
            setSpectraWidgetWidth(0);
          }
          setIsSpectraWidgetOpen(open);
        }}
        isPNLWidgetOpen={isPNLWidgetOpen}
        onTogglePNLWidget={setIsPNLWidgetOpen}
        isWalletTrackerWidgetOpen={isWalletTrackerWidgetOpen}
        onToggleWalletTrackerWidget={setIsWalletTrackerWidgetOpen}
        setpopup={setpopup}
        createSubWallet={createSubWallet}
        activeWalletPrivateKey={oneCTSigner}
      />
    </div>
  );
}

export default Loader;